/* ========== バトル状態 ========= */
let battle=null;

/* ルール固定：通常ドロー制限／インク置き制限 */
function sideLabel(side){ return side==="player" ? "自分" : "相手"; }

function addLog(text){
  const logEl=document.getElementById("log");
  if(!logEl) return;
  const div=document.createElement("div");
  div.textContent=text;
  logEl.appendChild(div);
  logEl.scrollTop=logEl.scrollHeight;
}

function drawCardFor(side){
  const s=battle?.[side];
  if(!s) return;
  if(s.deck.length===0){ addLog(`${sideLabel(side)}のデッキが切れた！`); return; }
  s.hand.push(s.deck.shift());
}

/* ===== 行動可否 ===== */
function isSummonSick(card){
  if(!battle || !card) return false;
  return (card.summonTurn === battle.turnCount);
}
function canCharacterActBase(card){
  if(!card) return false;
  if(card.type!=="character") return false;
  if(card.rest) return false;
  if(card.frozen) return false;
  return true;
}
function canSeekOrSing(card){
  if(!canCharacterActBase(card)) return false;
  // 召喚酔い：シーク／歌うは不可
  if(isSummonSick(card)) return false;
  return true;
}
function canCharacterAttack(card){
  if(!canCharacterActBase(card)) return false;
  // 召喚ターンは攻撃不可（突進のみ例外）
  if(isSummonSick(card) && !card.rush) return false;
  return true;
}

/* ===== インク置き回数（リンで+1） ===== */
function countLinOnField(side){
  const f=battle?.[side]?.field || [];
  return f.filter(c=>c.id===ID_LIN).length;
}
function inkPlaysLimit(side){
  // ルール：基本1枚、リンがいる間+1（複数リンなら複数加算）
  return 1 + countLinOnField(side);
}

/* ===== 勝敗判定 ===== */
function checkWin(){
  if(!battle) return false;
  if(battle.player.lore>=20){ alert("ロア20到達！あなたの勝ち！"); endBattleToMenu(); return true; }
  if(battle.cpu.lore>=20){ alert("相手がロア20に到達…負け"); endBattleToMenu(); return true; }
  return false;
}

/* ========== バトル開始 ========= */
function buildCpuDeck(selectedColors){
  if(!selectedColors || selectedColors.length===0) selectedColors=["red","purple"];
  if(selectedColors.length===1) selectedColors=[selectedColors[0],selectedColors[0]];
  const pool=cards.filter(c=>selectedColors.includes(c.color));
  const deckEntries=[];
  while(deckEntries.length<60){
    const base=pool[Math.floor(Math.random()*pool.length)];
    deckEntries.push({id:base.id,isEnchanted:false});
  }
  shuffle(deckEntries);
  return buildDeckInstancesFromSaved(deckEntries);
}

function startBattle(){
  if(cpuSelectedColors.length===0){
    if(!confirm("CPU色が未選択。赤＋紫で開始しますか？")) return;
    cpuSelectedColors=["red","purple"];
    updateCpuButtons();
  }

  let playerDeckDef;
  if(playerDeckMode==="default"){
    playerDeckDef = makeDefaultDeck().map(id=>({id,isEnchanted:false}));
  } else if(playerDeckMode==="deck1") playerDeckDef = savedDecks[0]||[];
  else if(playerDeckMode==="deck2") playerDeckDef = savedDecks[1]||[];
  else if(playerDeckMode==="deck3") playerDeckDef = savedDecks[2]||[];
  else playerDeckDef=[];

  const playerDeck=buildDeckInstancesFromSaved(playerDeckDef);
  if(playerDeck.length<60){ alert("プレイヤーデッキが60枚未満"); return; }
  const cpuDeck=buildCpuDeck(cpuSelectedColors);

  battle = {
    turnCount: 1,
    currentPlayer: "player",

    // 1ターンの通常ドロー制御
    normalDrawUsed: false,

    // 1ターンのインク置き制御
    inkPlaysUsed: { player:0, cpu:0 },

    player: { deck:playerDeck, hand:[], field:[], inkCurrent:0, inkMax:0, lore:0 },
    cpu:    { deck:cpuDeck,    hand:[], field:[], inkCurrent:0, inkMax:0, lore:0 }
  };

  document.getElementById("log").innerHTML="";

  // ★ 初期手札：7枚
  for(let i=0;i<7;i++){
    drawCardFor("player");
    drawCardFor("cpu");
  }

  showScreen("battle");
  addLog("バトル開始！");
  startPlayerTurn(true);
}

/* ========== ターン処理 ========= */
function startPlayerTurn(isFirst){
  if(!battle) return;
  if(!isFirst) battle.turnCount++;
  else battle.turnCount=1;

  battle.currentPlayer="player";
  battle.normalDrawUsed=false;
  battle.inkPlaysUsed.player=0;

  // ターン開始：インクは全回復（使える状態に戻る）
  battle.player.inkCurrent = battle.player.inkMax;

  // アンレスト＆凍結解除
  battle.player.field.forEach(c=>{ c.rest=false; if(c.frozen) c.frozen=false; });

  // ★ 先行（プレイヤー）1ターン目はノードロー
  if(battle.turnCount!==1){
    // 通常ドローを「ターン開始で消費」
    drawCardFor("player");
    battle.normalDrawUsed=true;
    addLog("自分はターン開始時に1枚ドローした。");
  } else {
    addLog("先行1ターン目のためドローは行われない。");
  }

  addLog(`=== 自分のターン ${battle.turnCount} ===`);
  updateBattleUI();
}

function startCpuTurn(){
  if(!battle) return;
  battle.currentPlayer="cpu";
  battle.inkPlaysUsed.cpu=0;
  battle.normalDrawUsed=false;

  battle.cpu.inkCurrent = battle.cpu.inkMax;
  battle.cpu.field.forEach(c=>{ c.rest=false; if(c.frozen) c.frozen=false; });

  // CPUは後攻なので turnCount==1 でもドローしてOK（あなたの固定ルールに矛盾が出る場合は言って）
  // 今回は「先行のみ1Tノードロー」扱いで実装
  drawCardFor("cpu");
  battle.normalDrawUsed=true;
  addLog("相手はターン開始時に1枚ドローした。");

  addLog(`=== 相手のターン ${battle.turnCount} ===`);
  cpuDoTurn();
}

/* ===== プレイヤー：通常ドロー（1T1回まで） ===== */
function playerDraw(){
  if(!battle) return;
  if(battle.currentPlayer!=="player"){ alert("今は自分のターンではありません"); return; }
  if(battle.normalDrawUsed){ alert("このターンはすでに通常ドロー済みです（2枚目以降は効果のみ）"); return; }
  drawCardFor("player");
  battle.normalDrawUsed=true;
  addLog("自分はドローボタンで1枚ドローした。");
  updateBattleUI();
}

/* ===== ターン終了 ===== */
function endTurn(){
  if(!battle || battle.currentPlayer!=="player") return;
  addLog("自分はターンを終了した。");
  updateBattleUI();
  startCpuTurn();
}

function endBattleToMenu(){ battle=null; showScreen("menu"); }

/* ========== インクにする（手札から） ========= */
function canInkCard(card){ return !!card?.inkable; }

function tryInkFromHand(handIndex){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;

  const card=battle.player.hand[handIndex];
  if(!card) return;

  const limit = inkPlaysLimit("player");
  if(battle.inkPlaysUsed.player >= limit){
    alert(`このターンはこれ以上インクを置けません（上限 ${limit}）`);
    return;
  }

  if(!canInkCard(card)){
    alert("このカードはコスト化不可（×）です。※効果で置く場合は別処理");
    return;
  }

  // 手札からインクへ（即時使用可）
  battle.player.hand.splice(handIndex,1);
  battle.player.inkMax += 1;
  battle.player.inkCurrent += 1;
  battle.inkPlaysUsed.player += 1;

  addLog(`自分は「${card.name}」をインクに置いた。（インク ${battle.player.inkCurrent}/${battle.player.inkMax}）`);
  updateBattleUI();
}

/* ========== シーク（ロア獲得＝カードのlore） ========= */
function doSeek(fieldIndex){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;
  const card=battle.player.field[fieldIndex];
  if(!card || !canSeekOrSing(card)) { alert("このキャラは今シークできません"); return; }

  card.rest=true;
  battle.player.lore += card.lore;
  addLog(`自分の「${card.name}」がシークし、ロア+${card.lore}（計${battle.player.lore}）`);
  updateBattleUI();
  checkWin();
}

/* ========== チャレンジ（対象はレストしているキャラのみ） ========= */
function listRestedTargets(side){
  const field = battle?.[side]?.field || [];
  const result=[];
  field.forEach((c,i)=>{ if(c.type==="character" && c.rest) result.push({idx:i, card:c}); });
  return result;
}

function doChallenge(attackerIdx){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;

  const attacker=battle.player.field[attackerIdx];
  if(!attacker || !canCharacterAttack(attacker)){ alert("このキャラはチャレンジできません"); return; }

  const targets = listRestedTargets("cpu");
  if(targets.length===0){ alert("相手にレストしているキャラがいないためチャレンジできません"); return; }

  let msg="チャレンジ対象（レスト中）を番号で選んでください\n";
  targets.forEach((t,n)=>{ msg += `${n}: ${t.card.name} (ATK:${t.card.atk} HP:${t.card.hp}/${t.card.maxHp})\n`; });
  const pick = prompt(msg, "0");
  if(pick===null) return;
  const n=parseInt(pick,10);
  if(Number.isNaN(n) || n<0 || n>=targets.length){ alert("選択が不正"); return; }
  resolveCombat("player", attackerIdx, targets[n].idx);
  updateBattleUI();
  checkWin();
}

function resolveCombat(attackerSide, attackerIndex, defenderIndex){
  const atkSide=battle[attackerSide];
  const defSide = attackerSide==="player" ? battle.cpu : battle.player;

  const attacker=atkSide.field[attackerIndex];
  const defender=defSide.field[defenderIndex];
  if(!attacker || !defender) return;

  // 対象制限：キャラはレストしてるもののみ
  if(defender.type==="character" && !defender.rest){
    if(attackerSide==="player") alert("相手がレストしていないためチャレンジできません");
    return;
  }

  if(attackerSide==="player" && !canCharacterAttack(attacker)){
    alert("このキャラはチャレンジできません");
    return;
  }

  addLog(`${sideLabel(attackerSide)}の「${attacker.name}」が${sideLabel(attackerSide==="player"?"cpu":"player")}の「${defender.name}」にチャレンジ！`);

  defender.hp -= attacker.atk;
  attacker.hp -= defender.atk;

  // チャレンジしたらレスト
  attacker.rest=true;

  if(defender.hp<=0){ addLog(`「${defender.name}」は退場した。`); defSide.field.splice(defenderIndex,1); }
  if(attacker.hp<=0){ addLog(`「${attacker.name}」は退場した。`); atkSide.field.splice(attackerIndex,1); }
}

/* ========== 召喚 ========= */
function playPlayerCharacter(handIndex){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;
  const card=battle.player.hand[handIndex];
  if(!card || card.type!=="character") return;

  if(battle.player.inkCurrent < card.cost){ alert("インクが足りません"); return; }

  battle.player.inkCurrent -= card.cost;
  battle.player.hand.splice(handIndex,1);
  card.rest=false; card.frozen=false; card.summonTurn=battle.turnCount;
  battle.player.field.push(card);

  addLog(`自分は「${card.name}」を召喚した。`);
  updateBattleUI();
}

/* ========== ソング（最低限：支払い or 歌う） ========= */
function listSingersForSong(side, songCard){
  const f = battle?.[side]?.field || [];
  const result=[];
  f.forEach((c,i)=>{
    if(c.type!=="character") return;
    if(!canSeekOrSing(c)) return; // 召喚酔い/レスト/凍結は不可
    // ルール：ロアではなく「コストが同等以上」
    if(c.cost >= songCard.cost) result.push({idx:i, card:c});
    // 歌声（songPower）がある場合は上限を拡張
    else if((c.songPower||0) >= songCard.cost) result.push({idx:i, card:c});
  });
  return result;
}

function playPlayerSong(handIndex){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;
  const song=battle.player.hand[handIndex];
  if(!song || song.type!=="song") return;

  const singers = listSingersForSong("player", song);

  // 選択：インク支払い か 歌う
  let msg = `ソング「${song.name}」（コスト${song.cost}）\n`;
  msg += `0: インクで支払って使用\n`;
  singers.forEach((s,n)=>{ msg += `${n+1}: 「${s.card.name}」で歌う（インク不要／そのキャラはレスト）\n`; });
  const pick = prompt(msg, "0");
  if(pick===null) return;
  const n=parseInt(pick,10);
  if(Number.isNaN(n) || n<0 || n> singers.length){ alert("選択が不正"); return; }

  if(n===0){
    if(battle.player.inkCurrent < song.cost){ alert("インクが足りません"); return; }
    battle.player.inkCurrent -= song.cost;
    battle.player.hand.splice(handIndex,1);
    addLog(`自分はソング「${song.name}」をインクで使用した。（効果は今後拡張）`);
  } else {
    const singer = singers[n-1];
    if(!singer) return;
    // 歌う → 歌ったキャラがレスト、インク不使用
    battle.player.field[singer.idx].rest=true;
    battle.player.hand.splice(handIndex,1);
    addLog(`自分は「${singer.card.name}」でソング「${song.name}」を歌った。（効果は今後拡張）`);
  }
  updateBattleUI();
}

/* ========== CPU行動（レスト対象がいないと殴れない） ========= */
function cpuDoTurn(){
  if(!battle) return;
  const cpu=battle.cpu;
  const me=battle.player;

  // 1) インク置き（可能なら1枚）
  const limit = inkPlaysLimit("cpu");
  if(battle.inkPlaysUsed.cpu < limit){
    const idx = cpu.hand.findIndex(c=>c.inkable);
    if(idx>=0){
      cpu.hand.splice(idx,1);
      cpu.inkMax += 1;
      cpu.inkCurrent += 1;
      battle.inkPlaysUsed.cpu += 1;
      addLog("相手は手札を1枚インクに置いた。");
    }
  }

  // 2) 召喚できるだけ召喚
  let loop=true;
  while(loop){
    loop=false;
    for(let i=0;i<cpu.hand.length;i++){
      const c=cpu.hand[i];
      if(c.type==="character" && c.cost<=cpu.inkCurrent){
        cpu.inkCurrent -= c.cost;
        cpu.hand.splice(i,1);
        c.rest=false; c.summonTurn=battle.turnCount;
        cpu.field.push(c);
        addLog(`相手は「${c.name}」を召喚した。`);
        loop=true;
        break;
      }
    }
  }

  // 3) 行動：殴れるなら「レストしている相手」だけ殴る、いないならシーク
  cpu.field.forEach((card, idx)=>{
    if(!canCharacterAttack(card) && !canSeekOrSing(card)) return;

    const restedTargets = listRestedTargets("player");
    if(canCharacterAttack(card) && restedTargets.length>0 && card.atk>0){
      const t = restedTargets[Math.floor(Math.random()*restedTargets.length)];
      resolveCombat("cpu", idx, t.idx);
      return;
    }

    if(canSeekOrSing(card) && card.lore>0){
      card.rest=true;
      cpu.lore += card.lore;
      addLog(`相手の「${card.name}」がシークし、相手ロア+${card.lore}（計${cpu.lore}）`);
    }
  });

  updateBattleUI();
  if(checkWin()) return;

  addLog("相手はターンを終了した。");
  startPlayerTurn(false);
}

/* ========== クリック処理（手札：召喚/ソング/インク） ========= */
function onPlayerHandCardClick(index){
  if(!battle || battle.currentPlayer!=="player") return;
  const card=battle.player.hand[index];
  if(!card) return;

  const actionArea=document.getElementById("actionArea");
  let html=`<div>手札：「${card.name}」を選択中</div>`;

  // インクにする（手札→インク）
  const limit = inkPlaysLimit("player");
  const canInk = canInkCard(card) && (battle.inkPlaysUsed.player < limit);
  if(canInk){
    html += `<button class="btn small" onclick="tryInkFromHand(${index})">インクにする（残り ${limit-battle.inkPlaysUsed.player}）</button>`;
  } else {
    html += `<div style="font-size:11px;opacity:0.8;">インク不可 or このターンの上限に達しました</div>`;
  }

  if(card.type==="character"){
    html += `<button class="btn small" onclick="playPlayerCharacter(${index})">召喚（コスト${card.cost}）</button>`;
  } else if(card.type==="song"){
    html += `<button class="btn small" onclick="playPlayerSong(${index})">ソング使用（コスト${card.cost}）</button>`;
  }

  html += `<button class="btn small" onclick="showCardDetailFromBattle('player','hand',${index})">カード詳細</button>`;
  actionArea.innerHTML=html;
}

function onPlayerFieldCardClick(index){
  if(!battle) return;
  const card=battle.player.field[index];
  if(!card) return;

  const actionArea=document.getElementById("actionArea");
  let html=`<div>場：「${card.name}」を選択中</div>`;

  if(battle.currentPlayer==="player"){
    if(card.type==="character"){
      if(canSeekOrSing(card) && card.lore>0){
        html += `<button class="btn small" onclick="doSeek(${index})">シーク（ロア+${card.lore}）</button>`;
      }
      if(canCharacterAttack(card)){
        const targets=listRestedTargets("cpu");
        if(targets.length>0 && card.atk>0){
          html += `<button class="btn small" onclick="doChallenge(${index})">チャレンジ（対象選択）</button>`;
        } else {
          html += `<div style="font-size:11px;opacity:0.8;">相手にレストしているキャラがいません</div>`;
        }
      } else {
        html += `<div style="font-size:11px;opacity:0.8;">召喚酔い/レスト/凍結で行動不可</div>`;
      }
    }
  }

  html += `<button class="btn small" onclick="showCardDetailFromBattle('player','field',${index})">カード詳細</button>`;
  actionArea.innerHTML=html;
}

function showCardDetailFromBattle(side, place, index){
  if(!battle) return;
  const card = (place==="hand") ? battle[side].hand[index] : battle[side].field[index];
  if(card) showCardDetail(card);
}

/* ========== UI更新 ========= */
function updateBattleUI(){
  if(!battle) return;

  document.getElementById("cpuHandCount").textContent = String(battle.cpu.hand.length);
  document.getElementById("cLore").textContent = String(battle.cpu.lore);
  document.getElementById("cDeck").textContent = String(battle.cpu.deck.length);

  document.getElementById("playerLore").textContent = String(battle.player.lore);
  document.getElementById("playerInkCurrent").textContent = String(battle.player.inkCurrent);
  document.getElementById("playerInkMax").textContent = String(battle.player.inkMax);
  document.getElementById("playerDeck").textContent = String(battle.player.deck.length);

  document.getElementById("turnInfo").textContent = (battle.currentPlayer==="player") ? "自分のターン" : "相手のターン";

  const cpuFieldEl=document.getElementById("cpuField");
  cpuFieldEl.innerHTML="";
  battle.cpu.field.forEach(card=>{
    const wrap=document.createElement("div");
    wrap.innerHTML=renderCardHtml(card);
    cpuFieldEl.appendChild(wrap.firstElementChild);
  });

  const playerFieldEl=document.getElementById("playerField");
  playerFieldEl.innerHTML="";
  battle.player.field.forEach((card,idx)=>{
    const wrap=document.createElement("div");
    wrap.innerHTML=renderCardHtml(card);
    const el=wrap.firstElementChild;
    el.onclick=()=>onPlayerFieldCardClick(idx);
    playerFieldEl.appendChild(el);
  });

  const playerHandEl=document.getElementById("playerHand");
  playerHandEl.innerHTML="";
  battle.player.hand.forEach((card,idx)=>{
    const wrap=document.createElement("div");
    wrap.innerHTML=renderCardHtml(card);
    const el=wrap.firstElementChild;
    el.onclick=()=>onPlayerHandCardClick(idx);
    playerHandEl.appendChild(el);
  });

  // 行動欄：ターン/インク置き残りを軽く表示
  const actionArea=document.getElementById("actionArea");
  if(actionArea && (!actionArea.dataset.locked || actionArea.dataset.locked==="0")){
    const lim=inkPlaysLimit("player");
    actionArea.innerHTML = `
      <div style="font-size:12px;opacity:0.9;">
        通常ドロー: ${battle.normalDrawUsed ? "使用済" : "未使用"}<br>
        インク置き: ${battle.inkPlaysUsed.player}/${lim}
      </div>
      <div style="font-size:12px;opacity:0.8;">カードをタップすると行動を選べます。</div>
    `;
  }
}

/* ========== 初期化 ========= */
window.addEventListener("load", ()=>{
  loadData();
  initFirebase();
});
</script>
</body>
</html>
