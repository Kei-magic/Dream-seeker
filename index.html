<!DOCTYPE html>
<html lang="ja">
<head>
 <meta charset="UTF-8" />
 <title>Dream-seeker TCG</title>
 <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <style>
   * { box-sizing: border-box; }

   body {
     margin: 0;
     font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
     background: #181818;
     color: #f5f5f5;
   }

   h1, h2 { text-align: center; margin: 12px 0; }

   .screen {
     display: none;
     padding: 10px;
     max-width: 520px;
     margin: 0 auto;
   }
   .screen.active { display: block; }

   .btn {
     width: 100%;
     padding: 10px;
     margin: 6px 0;
     border-radius: 8px;
     border: none;
     cursor: pointer;
     font-size: 14px;
     background: #444;
     color: #f5f5f5;
   }
   .btn.primary { background: #2ecc71; color: #000; }
   .btn.danger  { background: #e74c3c; }
   .btn.small {
     width: auto;
     padding: 4px 8px;
     font-size: 12px;
     margin: 2px 4px 0 0;
   }

   .topbar {
     display: flex;
     justify-content: space-between;
     font-size: 12px;
     margin-bottom: 8px;
   }

   .card-box {
     border: 1px solid #555;
     border-radius: 8px;
     padding: 6px;
     margin: 4px 0;
     font-size: 12px;
     background: #202020;
     cursor: pointer;
   }
   .card-name  { font-weight: bold; }
   .card-stats { font-size: 11px; opacity: 0.9; margin-top: 2px; }

   .red    { border-color: #e74c3c; }
   .purple { border-color: #9b59b6; }
   .blue   { border-color: #3498db; }
   .yellow { border-color: #f1c40f; }
   .white  { border-color: #ecf0f1; }
   .green  { border-color: #2ecc71; }

   .log {
     background: #111;
     border-radius: 8px;
     padding: 6px;
     font-size: 11px;
     height: 120px;
     overflow-y: auto;
     border: 1px solid #333;
     margin-top: 6px;
   }

   .section-title {
     font-size: 13px;
     margin: 10px 0 4px;
     font-weight: bold;
   }

   .stone-bar {
     font-size: 13px;
     padding: 4px 6px;
     border-radius: 8px;
     background: #222;
     display: inline-block;
     margin-bottom: 8px;
   }

   .row { display: flex; gap: 6px; }
   .row > .btn { flex: 1; }

   .toggle-selected {
     background: #f39c12 !important;
     color: #000 !important;
   }

   /* ===== ãƒãƒˆãƒ«ç”»é¢ç”¨ ===== */

   .battle-screen {
     padding: 16px;
   }

   .enemy-title {
     text-align: center;
     font-size: 20px;
     margin-bottom: 8px;
   }

   .enemy-status {
     display: flex;
     justify-content: space-around;
     margin-bottom: 8px;
     font-size: 13px;
   }

   #cpuField,
   #playerField,
   #playerHand {
     display: flex;
     align-items: flex-start;
     gap: 12px;
     overflow-x: auto;
     padding: 8px 0;
     min-height: 160px;
     -webkit-overflow-scrolling: touch;
   }

   .divider {
     border-top: 3px dashed #ffffff;
     margin: 12px 0;
   }

   .bottom-ui {
     display: flex;
     justify-content: space-between;
     gap: 16px;
     flex-wrap: wrap;
   }

   .status-box,
   .effect-box {
     width: 48%;
     min-height: 120px;
     border: 3px solid #ffffff;
     box-sizing: border-box;
     padding: 8px;
     font-size: 14px;
   }

   .status-box-title,
   .effect-box-title {
     font-weight: bold;
     margin-bottom: 4px;
   }

   .turn-info {
     margin-top: 4px;
     font-weight: bold;
   }

   .status-buttons {
     margin-top: 8px;
     display: flex;
     flex-wrap: wrap;
     gap: 4px;
   }

   .status-buttons button {
     font-size: 12px;
     padding: 4px 8px;
   }

   /* ã‚«ãƒ¼ãƒ‰è¦‹ãŸç›®ï¼ˆæ–°ã‚«ãƒ¼ãƒ‰å‹ï¼‰ */
   .card {
     flex: 0 0 auto;
     width: 96px;
     height: 160px;
     border-radius: 10px;
     border: 3px solid #555;
     background: #b30000;
     color: #ffffff;
     font-size: 10px;
     box-sizing: border-box;
     padding: 4px;
     display: flex;
     flex-direction: column;
     justify-content: flex-start;
     cursor: pointer;
     transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
   }

   .card:hover {
     transform: translateY(-2px);
     box-shadow: 0 0 8px rgba(255,255,255,0.3);
   }

   .card.rest {
     opacity: 0.6;
     transform: rotate(8deg);
   }

   .card.red {
     border-color: #e74c3c;
     background: #8b1a1a;
   }
   .card.purple {
     border-color: #9b59b6;
     background: #4b2b63;
   }
   .card.blue {
     border-color: #3498db;
     background: #1f3f5f;
   }
   .card.yellow {
     border-color: #f1c40f;
     background: #866d07;
   }
   .card.white {
     border-color: #ecf0f1;
     background: #aaaaaa;
     color: #000;
   }
   .card.green {
     border-color: #2ecc71;
     background: #145437;
   }

   .card-header {
     display: flex;
     align-items: center;
     justify-content: space-between;
     background: #000000;
     border-radius: 4px;
     padding: 2px 3px;
     margin-bottom: 3px;
     font-weight: bold;
   }

   .card-cost {
     min-width: 16px;
     text-align: center;
   }

   .card-name-header {
     flex: 1;
     text-align: center;
     font-size: 9px;
   }

   .card-inkable {
     min-width: 16px;
     text-align: center;
   }

   .card-illustration {
     flex: 1;
     background: #ffffff;
     border-radius: 4px;
     margin-bottom: 3px;
     overflow: hidden;
   }

   .card-illustration img {
     width: 100%;
     height: 100%;
     object-fit: cover;
     display: block;
   }

   .card-stats-row {
     display: flex;
     justify-content: space-between;
     font-size: 9px;
     padding: 0 2px;
     margin-bottom: 3px;
   }

   .card-footer {
     background: #000000;
     border-radius: 4px;
     padding: 2px 3px;
     font-size: 9px;
   }

   .card-footer-buttons {
     display: flex;
     gap: 2px;
     margin-top: 2px;
   }

   /* ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
   #cardDetailOverlay {
     display: none;
     position: fixed;
     inset: 0;
     background: rgba(0,0,0,0.7);
     z-index: 1000;
   }
   #cardDetailInner {
     background: #222;
     max-width: 320px;
     margin: 40px auto;
     padding: 12px;
     border-radius: 10px;
     border: 1px solid #ffffff;
     font-size: 13px;
   }
 </style>
</head>
<body>

<!-- ===== ãƒ›ãƒ¼ãƒ  ===== -->
<div id="menuScreen" class="screen active">
 <h1>Dream-seeker TCG</h1>
 <div class="stone-bar">
   ğŸ’ ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="stoneCount">0</span>
 </div>
 <button class="btn primary" onclick="openCpuConfig()">ãƒãƒˆãƒ«</button>
 <button class="btn" onclick="showShop()">ã‚·ãƒ§ãƒƒãƒ—</button>
 <button class="btn" onclick="showPack()">ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</button>
 <button class="btn" onclick="openDeckBuilder()">ãƒ‡ãƒƒã‚­ç·¨é›†</button>
 <button class="btn" onclick="openCollection()">ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</button>
</div>

<!-- ===== CPUè¨­å®š ===== -->
<div id="cpuScreen" class="screen">
 <h2>CPUè¨­å®š</h2>

 <div class="section-title">CPUã®å¼·ã•</div>
 <div class="row">
   <button id="btnCpuNormal" class="btn" onclick="setCpuStrength('normal')">æ™®é€š</button>
   <button id="btnCpuStrong" class="btn" onclick="setCpuStrength('strong')">å¼·ã„ï¼ˆè¶…CPUï¼‰</button>
 </div>

 <div class="section-title">CPUãƒ‡ãƒƒã‚­è‰²ï¼ˆ2è‰²ã¾ã§é¸æŠï¼‰</div>
 <div class="row">
   <button id="cpuRed"    class="btn" onclick="toggleCpuColor('red')">èµ¤</button>
   <button id="cpuPurple" class="btn" onclick="toggleCpuColor('purple')">ç´«</button>
 </div>
 <div class="row">
   <button id="cpuBlue"   class="btn" onclick="toggleCpuColor('blue')">é’</button>
   <button id="cpuYellow" class="btn" onclick="toggleCpuColor('yellow')">é»„</button>
 </div>
 <div class="row">
   <button id="cpuWhite"  class="btn" onclick="toggleCpuColor('white')">ç™½</button>
   <button id="cpuGreen"  class="btn" onclick="toggleCpuColor('green')">ç·‘</button>
 </div>

 <div class="section-title">è‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­</div>
 <button id="btnPlayerDefault" class="btn" onclick="selectPlayerDeck('default')">
   ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèµ¤ãƒ‡ãƒƒã‚­
 </button>
 <button id="btnDeck1" class="btn" onclick="selectPlayerDeck('deck1')">
   ãƒ‡ãƒƒã‚­1ï¼ˆæœªä¿å­˜ï¼‰
 </button>
 <button id="btnDeck2" class="btn" onclick="selectPlayerDeck('deck2')">
   ãƒ‡ãƒƒã‚­2ï¼ˆæœªä¿å­˜ï¼‰
 </button>
 <button id="btnDeck3" class="btn" onclick="selectPlayerDeck('deck3')">
   ãƒ‡ãƒƒã‚­3ï¼ˆæœªä¿å­˜ï¼‰
 </button>

 <button class="btn primary" onclick="startBattle()">ãƒãƒˆãƒ«é–‹å§‹</button>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒãƒˆãƒ« ===== -->
<div id="battleScreen" class="screen">
 <div class="battle-screen">

   <!-- ç›¸æ‰‹ã‚¨ãƒªã‚¢ -->
   <div class="enemy-area">
     <div class="enemy-title">ç›¸æ‰‹</div>
     <div class="enemy-status">
       <span>æ‰‹æœ­ï¼š<span id="cpuHandCount">0</span>æš</span>
       <span>ãƒ­ã‚¢ï¼š<span id="cLore">0</span>å€‹</span>
       <span>æ®‹ã‚Šå±±æœ­ï¼š<span id="cDeck">0</span>æš</span>
     </div>
     <div id="cpuField"></div>
   </div>

   <div class="divider"></div>

   <!-- è‡ªåˆ†ã‚¨ãƒªã‚¢ -->
   <div class="player-area">

     <div id="playerField"></div>

     <div id="playerHand"></div>

     <div class="bottom-ui">
       <div class="status-box">
         <div class="status-box-title">è‡ªåˆ†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
         <div>ãƒ­ã‚¢ï¼š<span id="playerLore">0</span></div>
         <div>ã‚¤ãƒ³ã‚¯ï¼š<span id="playerInkCurrent">0</span> / <span id="playerInkMax">0</span></div>
         <div>æ®‹ã‚Šå±±æœ­ï¼š<span id="playerDeck">0</span></div>
         <div id="turnInfo" class="turn-info">è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³</div>

         <div class="status-buttons">
           <button class="btn small" onclick="playerDraw()">ãƒ‰ãƒ­ãƒ¼</button>
           <button class="btn small" onclick="endTurn()">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
           <button class="btn small danger" onclick="endBattleToMenu()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
         </div>
       </div>

       <div class="effect-box">
         <div class="effect-box-title">è¡Œå‹• / æƒ…å ±</div>
         <div id="actionArea">ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚</div>
       </div>
     </div>

     <div class="section-title">ãƒ­ã‚°</div>
     <div id="log" class="log"></div>

   </div>
 </div>
</div>

<!-- ===== ã‚·ãƒ§ãƒƒãƒ— ===== -->
<div id="shopScreen" class="screen">
 <h2>ã‚·ãƒ§ãƒƒãƒ—</h2>
 <p>â€» ä»Šã¯ãƒ†ã‚¹ãƒˆç”¨ã€‚çŸ³ã‚’å¢—ã‚„ã—æ”¾é¡Œã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚</p>
 <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="shopStoneCount">0</span></p>
 <button class="btn" onclick="debugAddStones()">çŸ³ã‚’100å€‹å¢—ã‚„ã™ï¼ˆãƒ†ã‚¹ãƒˆï¼‰</button>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‘ãƒƒã‚¯ ===== -->
<div id="packScreen" class="screen">
 <h2>ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</h2>
 <p>ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³5å€‹ã§1ãƒ‘ãƒƒã‚¯ï¼ˆ5æšå…¥ã‚Šï¼‰</p>
 <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="packStoneCount">0</span></p>
 <button class="btn primary" onclick="openPack()">ãƒ‘ãƒƒã‚¯ã‚’é–‹ã‘ã‚‹</button>
 <div class="section-title">ä»Šå›ã®çµæœ</div>
 <div id="packResult"></div>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‡ãƒƒã‚­ç·¨é›† ===== -->
<div id="deckScreen" class="screen">
 <h2>ãƒ‡ãƒƒã‚­ç·¨é›†</h2>
 <p style="font-size:12px; opacity:0.8;">
   æ‰€æŒã‚«ãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒƒã‚­ã«å…¥ã‚Œã‚‹æšæ•°ã‚’æ±ºã‚ã¦ãã ã•ã„ã€‚ä¿å­˜ã—ãŸãƒ‡ãƒƒã‚­ã¯ãƒãƒˆãƒ«ã§ã€Œè‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­ã€ã§é¸ã¹ã¾ã™ã€‚<br>
   â€» ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ï¼åŒåã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ï¼ˆåŸºæœ¬6ç¨®ã¯ä½•æšã§ã‚‚å¯ï¼‰ï¼æœ€çµ‚çš„ã«60æšä»¥ä¸Š
 </p>

 <div style="margin-bottom:8px;">
   <button class="btn small" onclick="switchDeck(0)">ãƒ‡ãƒƒã‚­1</button>
   <button class="btn small" onclick="switchDeck(1)">ãƒ‡ãƒƒã‚­2</button>
   <button class="btn small" onclick="switchDeck(2)">ãƒ‡ãƒƒã‚­3</button>
   <div style="font-size:12px; opacity:0.9; margin-top:4px;">
     ç¾åœ¨ç·¨é›†ã—ã¦ã„ã‚‹ã®ã¯ï¼šãƒ‡ãƒƒã‚­<span id="currentDeckLabel">1</span>
   </div>
 </div>

 <div id="deckCardList"></div>
 <button class="btn primary" onclick="saveDeck()">ã“ã®å†…å®¹ã§ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜</button>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« ===== -->
<div id="collectionScreen" class="screen">
 <h2>ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</h2>
 <div id="collectionList"></div>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ï¼å„ç¨®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å…±ç”¨ ===== -->
<div id="cardDetailOverlay">
 <div id="cardDetailInner">
   <div id="cardDetailContent"></div>
   <button class="btn" onclick="closeCardDetail()">æˆ»ã‚‹ / é–‰ã˜ã‚‹</button>
 </div>
</div>

<script>
/* ========== ç‰¹æ®ŠID ========== */
const ID_RATABAA   = 14;
const ID_LIN       = 13;
const ID_TITAN     = 9;
const ID_PRETZEL   = 16;
const ID_CHAMELEON = 24; // æ–°ï¼šã‚«ãƒ¡ãƒ¬ã‚ªãƒ³

/* ========== ç”»é¢åˆ‡ã‚Šæ›¿ãˆ ========== */
function showScreen(name) {
 const ids = ["menuScreen","cpuScreen","battleScreen","shopScreen","packScreen","deckScreen","collectionScreen"];
 ids.forEach(id => {
   const el = document.getElementById(id);
   if (el) el.classList.remove("active");
 });
 const map = {
   menu: "menuScreen",
   cpu: "cpuScreen",
   battle: "battleScreen",
   shop: "shopScreen",
   pack: "packScreen",
   deck: "deckScreen",
   collection: "collectionScreen"
 };
 document.getElementById(map[name]).classList.add("active");
}

/* ========== ã‚«ãƒ¼ãƒ‰å®šç¾© ========== */
const cards = [
 // åŸºæœ¬6ç¨®
 {id:0, name:"ã‚«ãƒ¼",   color:"red",    type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:1, name:"ãƒ«ãƒ‘ãƒ—", color:"purple", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:2, name:"ãƒ«ãƒ–ãƒ–", color:"blue",   type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:3, name:"ãƒ­ã‚¤ã‚¨", color:"yellow", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:4, name:"ãƒ­ãƒ¼ã‚·", color:"white",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:5, name:"ãƒ‰ãƒªãƒŸ", color:"green",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 // æ—¢å­˜SR/L
 {id:6, name:"çµ‚ç„‰ã®å¤§ç«",        color:"red",    type:"song",      cost:7, atk:0, hp:0, lore:0, rarity:"SR", inkable:false, effect:"boardwipe"},
 {id:7, name:"æ°·çµã®å¥³ç‹ã‚±ãƒ«ã‚µ",  color:"purple", type:"character", cost:8, atk:4, hp:6, lore:3, rarity:"L",  inkable:false, effect:"freeze2", evolveCost:6},
 {id:8, name:"ä¼èª¬ã®å‹‡è€…ã‚¤ãƒ•ãƒªãƒ¼ãƒˆ", color:"red", type:"character", cost:8, atk:5, hp:5, lore:4, rarity:"L",  inkable:true,  evade:true},

 // èµ¤
 {id:9,  name:"ã‚¿ã‚¤ã‚¿ãƒ³",        color:"red",    type:"character", cost:5, atk:6, hp:5, lore:0, rarity:"SR", inkable:true,  mustAttack:true},
 {id:10, name:"ãƒã‚¸ãƒ§ãƒ‰ãƒ©",      color:"red",    type:"character", cost:9, atk:7, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"destroyOnSummon"},
 {id:11, name:"ãã‚ãã‚ãƒ€ãƒƒã‚¯",  color:"red",    type:"character", cost:2, atk:2, hp:3, lore:1, rarity:"N",  inkable:true},

 // é’
 {id:12, name:"ã‚´ãƒ¼ã‚º",       color:"blue",   type:"character", cost:7, atk:3, hp:6, lore:2, rarity:"L",  inkable:false, effect:"toInkOnSummon"},
 {id:13, name:"ãƒªãƒ³",         color:"blue",   type:"character", cost:4, atk:2, hp:4, lore:1, rarity:"L",  inkable:true},
 {id:14, name:"ã‚‰ãŸã°ã‚",     color:"blue",   type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N",  inkable:true},
 {id:15, name:"ã‚ã‚Šã®ã¾ã¾ã§", color:"blue",   type:"song",      cost:5, atk:0, hp:0, lore:0, rarity:"SR", inkable:true,  effect:"songToInk1"},

 // é»„
 {id:16, name:"ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«",   color:"yellow", type:"character", cost:4, atk:1, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"pretzelHealDraw"},
 {id:17, name:"ãƒŸã‚¹ã‚¿ãƒ¼ãƒã‚¸",   color:"yellow", type:"character", cost:3, atk:2, hp:5, lore:1, rarity:"N",  inkable:true},
 {id:18, name:"ãƒ•ãƒ³ãƒãƒ¼",       color:"yellow", type:"character", cost:4, atk:3, hp:5, lore:1, rarity:"N",  inkable:true},
 {id:19, name:"ã‚¢ãƒªã‚¨ãƒŠã‚¤",     color:"yellow", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"SR", inkable:true,  effect:"arienaiSearchSong", songPower:5},

 /* ===== æ–°ã‚«ãƒ¼ãƒ‰ ===== */

 // èµ¤ã‚°ãƒ«ãƒ¼ãƒ—
 {id:20, name:"ã‚¸ãƒ¼ãƒ¦ãƒ¼",       color:"green",    type:"character", cost:6, atk:3, hp:4, lore:2, rarity:"SR", inkable:false, effect:"giyuBounce"},
 {id:21, name:"ã‚¨ãƒ³ãƒãƒ³ã‚¹",     color:"green",    type:"character", cost:4, atk:3, hp:3, lore:3, rarity:"N",  inkable:true},
 {id:22, name:"èƒŒç­‹ãŒãƒ’ãƒ¤ãƒª",   color:"green",    type:"song",      cost:2, atk:0, hp:0, lore:0, rarity:"N",  inkable:true,  effect:"hiyariDiscard"},

 // ç´«ã‚°ãƒ«ãƒ¼ãƒ—
 {id:23, name:"ã»ã†ã",         color:"purple", type:"character", cost:2, atk:2, hp:2, lore:1, rarity:"N",  inkable:true},
 {id:24, name:"ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³",     color:"purple", type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N",  inkable:true},
 {id:25, name:"ãƒ†ã‚£ãƒ©ãƒŸã‚¹ã®ãŸãã‚‰ã¿", color:"purple", type:"song", cost:3, atk:0, hp:0, lore:0, rarity:"R", inkable:true,  effect:"tiramisuDraw3"},
 {id:26, name:"ãƒã‚¸ãƒ§",         color:"purple", type:"character", cost:3, atk:2, hp:2, lore:1, rarity:"N",  inkable:true,  effect:"majoDraw1"},
 {id:27, name:"ã‚±ãƒ«ã‚µ",         color:"purple", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"N",  inkable:true},

 // ç™½ã‚°ãƒ«ãƒ¼ãƒ—
 {id:28, name:"AHNW",           color:"white",  type:"song",      cost:5, atk:0, hp:0, lore:0, rarity:"SR", inkable:false, effect:"ahnwResetHands"},
 {id:29, name:"ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼",   color:"white",  type:"song",      cost:3, atk:0, hp:0, lore:0, rarity:"R",  inkable:true,  effect:"slash3Damage"},
 {id:30, name:"å‰£ã§åˆºã›",       color:"white",  type:"song",      cost:5, atk:0, hp:0, lore:0, rarity:"R",  inkable:false, effect:"stabAoE2"},
 {id:31, name:"ã‚¨ãƒ©ãƒƒã‚¿ç‹å­",   color:"white",  type:"character", cost:2, atk:1, hp:3, lore:1, rarity:"N",  inkable:true,  ferocious:2}
];

function makeCardInstance(base) {
 return {
   id: base.id,
   name: base.name,
   color: base.color,
   type: base.type,
   cost: base.cost,
   atk: base.atk,
   hp: base.hp,
   maxHp: base.hp,
   lore: base.lore,
   rarity: base.rarity,
   inkable: base.inkable,
   effect: base.effect,
   evolveCost: base.evolveCost,
   evade: base.evade || false,
   mustAttack: base.mustAttack || false,
   songPower: base.songPower || base.cost,
   ferocious: base.ferocious || 0,  // ç°çŒ›ï¼ˆã‚¨ãƒ©ãƒƒã‚¿ç‹å­ç”¨ï¼‰
   rest: false,
   frozen: false,
   summonTurn: 0
 };
}

/* ========== ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ ========== */
let stones = 0;
let collection = {};
let savedDecks = [[], [], []];
let currentDeckIndex = 0;

function loadData() {
 const s = localStorage.getItem("ds_stones");
 stones = s ? parseInt(s,10) : 0;

 const c = localStorage.getItem("ds_collection");
 collection = c ? JSON.parse(c) : {};

 const d3 = localStorage.getItem("ds_playerDecks");
 if (d3) {
   try {
     const parsed = JSON.parse(d3);
     if (Array.isArray(parsed) && parsed.length === 3) {
       savedDecks = parsed;
     }
   } catch(e) {}
 } else {
   const dOld = localStorage.getItem("ds_playerDeck");
   if (dOld) {
     try {
       const one = JSON.parse(dOld);
       if (Array.isArray(one)) {
         savedDecks[0] = one;
       }
     } catch(e) {}
   }
 }

 updateStoneDisplays();
}

function saveStones() {
 localStorage.setItem("ds_stones", String(stones));
 updateStoneDisplays();
}

function saveCollection() {
 localStorage.setItem("ds_collection", JSON.stringify(collection));
}

function savePlayerDecks() {
 localStorage.setItem("ds_playerDecks", JSON.stringify(savedDecks));
}

function updateStoneDisplays() {
 const v1 = document.getElementById("stoneCount");
 const v2 = document.getElementById("shopStoneCount");
 const v3 = document.getElementById("packStoneCount");
 if (v1) v1.textContent = stones;
 if (v2) v2.textContent = stones;
 if (v3) v3.textContent = stones;
}

/* ========== ã‚·ãƒ§ãƒƒãƒ— ========== */
function showShop() {
 updateStoneDisplays();
 showScreen("shop");
}
function debugAddStones() {
 stones += 100;
 saveStones();
}

/* ========== ã‚¬ãƒãƒ£ ========== */
function showPack() {
 updateStoneDisplays();
 document.getElementById("packResult").innerHTML = "";
 showScreen("pack");
}

/* ãƒãƒˆãƒ«ã¨åŒã˜ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ä½¿ã£ã¦è¡¨ç¤ºã™ã‚‹ãŸã‚ã®å…±é€šæç”» */
function renderSingleCardDivFromBaseCard(baseCard) {
 const cardInst = makeCardInstance(baseCard);
 const wrap = document.createElement("div");
 wrap.style.display = "inline-block";
 wrap.style.margin = "4px";
 wrap.innerHTML = renderCardHtml(cardInst);
 const cardEl = wrap.firstElementChild;
 cardEl.onclick = () => showCardDetail(cardInst);
 return wrap;
}

function openPack() {
 const COST = 5;
 if (stones < COST) {
   alert("ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼ˆ5å€‹å¿…è¦ï¼‰");
   return;
 }
 stones -= COST;
 saveStones();

 const pulled = [];

 for (let i=0;i<5;i++) {
   const r = Math.random();
   let rarity;
   if (r < 0.78) rarity = "N";
   else if (r < 0.90) rarity = "R";
   else if (r < 0.98) rarity = "SR";
   else rarity = "L";

   let candidates = cards.filter(c => c.rarity === rarity);
   if (candidates.length === 0) {
     const order = ["L","SR","R","N"];
     for (const rr of order) {
       const list = cards.filter(c => c.rarity === rr);
       if (list.length) { candidates = list; break; }
     }
     if (!candidates.length) candidates = cards.slice();
   }

   const card = candidates[Math.floor(Math.random()*candidates.length)];
   pulled.push(card);
   if (!collection[card.id]) collection[card.id] = 0;
   collection[card.id]++;
 }
 saveCollection();

 const pr = document.getElementById("packResult");
 pr.innerHTML = "";
 pulled.forEach(c => {
   const cardDiv = renderSingleCardDivFromBaseCard(c);
   pr.appendChild(cardDiv);
 });
}

/* ========== ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— ========== */
function getCardEffectText(card) {
 switch(card.id) {
   case 6:
     return "ã‚½ãƒ³ã‚°ï¼ˆ7ï¼‰ï¼šå ´ã®ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ©ã‚’ç ´å£Šã™ã‚‹ã€‚ã‚­ãƒ£ãƒ©ãŒæ­Œã†å ´åˆã€ã‚³ã‚¹ãƒˆã‚’æ”¯æ‰•ã‚ãšã«ä½¿ç”¨ã§ãã‚‹ã€‚ä½¿ç”¨å¾Œã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
   case 7:
     return "å¤‰èº«6ï¼šè‡ªåˆ†ã®ã€Œã‚«ãƒ¼ã€ã‹ã‚‰å¤‰èº«ã§ãã‚‹ã€‚\nå¬å–šæ™‚ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ã‚’æœ€å¤§2ä½“ã¾ã§å‡çµã™ã‚‹ã€‚å‡çµä¸­ã®ã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ããªã„ã€‚";
   case 8:
     return "å›é¿ï¼šå›é¿ã‚’æŒã¤ã‚­ãƒ£ãƒ©ã«ã—ã‹ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã•ã‚Œãªã„ã€‚";
   case 9:
     return "ãƒ­ã‚¢0ï¼ˆã‚·ãƒ¼ã‚¯ã—ã¦ã‚‚ãƒ­ã‚¢ã¯å¾—ã‚‰ã‚Œãªã„ï¼‰ã€‚\nã“ã®ã‚­ãƒ£ãƒ©ã¯æ”»æ’ƒå¯èƒ½ã§æœ‰åŠ¹ãªãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆãŒã„ã‚‹å ´åˆã€å¿…ãšãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚";
   case 10:
     return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®å ´ã®å¥½ããªã‚­ãƒ£ãƒ©1ä½“ã‚’é€€å ´ã•ã›ã‚‹ã€‚";
   case 11:
     return "ç‰¹ã«ãªã—ã€‚";
   case 12:
     return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®å ´ã®å¥½ããªã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚³ã‚¹ãƒˆã‚¾ãƒ¼ãƒ³ã«é€ã‚‹ã€‚";
   case 13:
     return "â‘ ã“ã®ã‚­ãƒ£ãƒ©ãŒå ´ã«ã„ã‚‹é–“ã€è‡ªåˆ†ã¯1ã‚¿ãƒ¼ãƒ³ã«ç½®ã‘ã‚‹ã‚¤ãƒ³ã‚¯ãŒ1æšå¢—ãˆã‚‹ã€‚\nâ‘¡è‡ªåˆ†ã®ã‚³ã‚¹ãƒˆãŒ10æšä»¥ä¸Šã‚ã‚‹é–“ã€ã“ã®ã‚­ãƒ£ãƒ©ã®ãƒ­ã‚¢ã¯5ã«ãªã‚‹ã€‚";
   case 14:
     return "ãƒ­ã‚¢1ã€‚\nã“ã®ã‚«ãƒ¼ãƒ‰ãŒç ´å£Šã•ã‚ŒãŸã¨ãã€å¢“åœ°ã«è¡Œã‹ãšã‚³ã‚¹ãƒˆã‚¾ãƒ¼ãƒ³ã«ç½®ã‹ã‚Œã‚‹ã€‚";
   case 15:
     return "ã‚½ãƒ³ã‚°ï¼ˆ5ï¼‰ï¼šç›¸æ‰‹ã®å ´ã®å¥½ããªã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚³ã‚¹ãƒˆã‚¾ãƒ¼ãƒ³ã«é€ã‚‹ã€‚ä½¿ç”¨å¾Œã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
   case 16:
     return "å¬å–šæ™‚ï¼šè‡ªåˆ†ã®å ´ã®ã‚­ãƒ£ãƒ©ã‹ã‚‰åˆè¨ˆ3ãƒ€ãƒ¡ãƒ¼ã‚¸ã¾ã§å¥½ããªã‚ˆã†ã«å›å¾©ã—ã€ãã®å›å¾©ã—ãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã®æ•°ã ã‘è¿½åŠ ã§ãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
   case 17:
   case 18:
     return "ç‰¹ã«ãªã—ã€‚";
   case 19:
     return "æ­Œå£°5ï¼šã“ã®ã‚­ãƒ£ãƒ©ã¯ã‚½ãƒ³ã‚°ã‚’æ­Œã†ã¨ãã€ã‚³ã‚¹ãƒˆ5ã®ã‚½ãƒ³ã‚°ã‚’æ­Œãˆã‚‹ã‚­ãƒ£ãƒ©ã¨ã—ã¦æ‰±ã†ã€‚\nå¬å–šæ™‚ï¼šè‡ªåˆ†ã®ãƒ‡ãƒƒã‚­ã®ä¸Šã‹ã‚‰4æšè¦‹ã¦ã€ãã®ä¸­ã‹ã‚‰ã‚½ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã‚’1æšã¾ã§æ‰‹æœ­ã«åŠ ãˆã‚‹ã€‚æ®‹ã‚Šã¯å¥½ããªé †ç•ªã§ãƒ‡ãƒƒã‚­ã®ä¸‹ã«ç½®ãã€‚";

   /* æ–°ã‚«ãƒ¼ãƒ‰èª¬æ˜ */
   case 20:
     return "å¬å–šæ™‚ï¼šå¥½ããªç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’é¸ã‚“ã§ã€ç›¸æ‰‹ã®æ‰‹æœ­ã«æˆ»ã—ã¦ã‚‚ã‚ˆã„ã€‚";
   case 21:
     return "ç‰¹ã«ãªã—ã€‚";
   case 22:
     return "ã‚½ãƒ³ã‚°ï¼ˆ2ï¼‰ï¼šç›¸æ‰‹ã¯æ‰‹æœ­ã‹ã‚‰1æšã‚’é¸ã‚“ã§æ¨ã¦ã‚‹ã€‚";
   case 23:
     return "ç‰¹ã«ãªã—ã€‚";
   case 24:
     return "ã“ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯è‡ªåˆ†ã®å ´ã«ä»–ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã„ã‚‹é–“ã€å›é¿ã€ã‚’å¾—ã‚‹ã€‚";
   case 25:
     return "ã‚½ãƒ³ã‚°ï¼ˆ3ï¼‰ï¼šè‡ªåˆ†ã¯å±±æœ­ã‹ã‚‰3æšãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
   case 26:
     return "å¬å–šæ™‚ï¼šå±±æœ­ã‹ã‚‰1æšãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
   case 27:
     return "ç‰¹ã«ãªã—ã€‚";
   case 28:
     return "ã‚½ãƒ³ã‚°ï¼ˆ5ï¼‰ï¼šãŠäº’ã„ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ‰‹æœ­ã‚’ã™ã¹ã¦æ¨ã¦ã¦ã‹ã‚‰7æšãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
   case 29:
     return "ã‚½ãƒ³ã‚°ï¼ˆ3ï¼‰ï¼šé¸ã‚“ã ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼1ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
   case 30:
     return "ã‚½ãƒ³ã‚°ï¼ˆ5ï¼‰ï¼šç›¸æ‰‹ã®å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
   case 31:
     return "ç°çŒ›2ï¼ˆã“ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯ãƒãƒ£ãƒ¬ãƒ³ã‚¸æ™‚ã®ã¿æ”»æ’ƒåŠ›+2ã•ã‚Œã‚‹ï¼‰ã€‚";
   default:
     return "ç‰¹ã«ãªã—ã€‚";
 }
}

function showCardDetail(card) {
 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 const effectText = getCardEffectText(card);

 const statsPart = (card.type === "character")
   ? `<div style="margin-bottom:4px;">ATK:${card.atk} / HP:${card.hp}/${card.maxHp} / ãƒ­ã‚¢:${card.lore}</div>`
   : `<div style="margin-bottom:4px;">${card.type === "song" ? "ã‚½ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰" : "ãƒã‚¸ãƒƒã‚¯/ã‚¹ãƒšãƒ«"}</div>`;

 content.innerHTML = `
   <div style="font-weight:bold; margin-bottom:4px;">${card.name}</div>
   <div style="font-size:12px; margin-bottom:4px;">
     è‰²:${card.color} ï¼ ç¨®é¡:${card.type} ï¼ ã‚³ã‚¹ãƒˆ:${card.cost}
   </div>
   ${statsPart}
   <div style="font-size:12px; white-space:pre-wrap;">${effectText}</div>
 `;
 overlay.style.display = "block";
}

function showCardDetailById(id) {
 const base = cards.find(c => c.id === id);
 if (!base) return;
 const inst = makeCardInstance(base);
 showCardDetail(inst);
}

/* ã‚¢ãƒªã‚¨ãƒŠã‚¤ï¼ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§ã‚‚ overlay ã‚’ä½¿ã†ã®ã§
   ã€Œæˆ»ã‚‹ã€ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã¯ã€åŠ¹æœã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹æŒ™å‹•ã«ã—ã¦ãŠã */
function closeCardDetail() {
 const overlay = document.getElementById("cardDetailOverlay");
 if (overlay) overlay.style.display = "none";

 // ã‚¢ãƒªã‚¨ãƒŠã‚¤åŠ¹æœä¸­ãªã‚‰ã€Œã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ã¨ã—ã¦ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒƒã‚­ã«æˆ»ã™
 if (arienaiState && arienaiState.owner && arienaiState.revealed) {
   const owner = arienaiState.owner;
   const arr = arienaiState.revealed;
   for (let i = arr.length - 1; i >= 0; i--) {
     owner.deck.push(arr[i]);
   }
   addLog("ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€ã®åŠ¹æœã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã€ã‚«ãƒ¼ãƒ‰ã‚’å±±æœ­ã«æˆ»ã—ãŸã€‚");
   arienaiState = null;
 }

 // ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã‚‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ‰±ã„
 if (pretzelState) {
   addLog("ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã€‚");
   pretzelState = null;
 }
}

/* ========== ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ ========== */
function openCollection() {
 const list = document.getElementById("collectionList");
 list.innerHTML = "";

 cards.forEach(c => {
   const cnt = collection[c.id] || 0;
   const row = document.createElement("div");
   row.style.display = "flex";
   row.style.alignItems = "center";
   row.style.gap = "8px";
   row.style.marginBottom = "4px";

   const cardDiv = renderSingleCardDivFromBaseCard(c);
   row.appendChild(cardDiv);

   const info = document.createElement("div");
   info.style.fontSize = "12px";
   info.innerHTML = `
     <div>${c.name}</div>
     <div>è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type}</div>
     <div>æ‰€æŒæšæ•°: Ã—${cnt}</div>
   `;
   row.appendChild(info);

   list.appendChild(row);
 });

 showScreen("collection");
}

/* ========== ãƒ‡ãƒƒã‚­ç·¨é›† ========== */
let deckCounts = {};

function openDeckBuilder(index) {
 if (typeof index === "number") {
   currentDeckIndex = index;
 }
 rebuildDeckEditor();
 showScreen("deck");
}

function switchDeck(idx) {
 currentDeckIndex = idx;
 rebuildDeckEditor();
}

function rebuildDeckEditor() {
 deckCounts = {};
 const currentDeck = savedDecks[currentDeckIndex] || [];
 currentDeck.forEach(id => {
   deckCounts[id] = (deckCounts[id] || 0) + 1;
 });

 const label = document.getElementById("currentDeckLabel");
 if (label) label.textContent = currentDeckIndex + 1;

 const area = document.getElementById("deckCardList");
 let html = "";
 cards.forEach(c => {
   const have = collection[c.id] || 0;
   const inDeck = deckCounts[c.id] || 0;
   html += `
     <div class="card-box ${c.color}" onclick="showCardDetailById(${c.id})">
       <div class="card-name">${c.name}</div>
       <div class="card-stats">
         è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type} / ã‚³ã‚¹ãƒˆ:${c.cost}
       </div>
       <div class="card-stats">
         æ‰€æŒ: Ã—${have} ï¼ ãƒ‡ãƒƒã‚­: Ã—<span id="deck-count-${c.id}">${inDeck}</span>
       </div>
       <button class="btn small" onclick="event.stopPropagation(); changeDeckCount(${c.id}, -1)">ï¼</button>
       <button class="btn small" onclick="event.stopPropagation(); changeDeckCount(${c.id}, +1)">ï¼‹</button>
     </div>`;
 });
 area.innerHTML = html;
}

function isBasicCard(cardId) {
 return cardId >= 0 && cardId <= 5;
}

function getDeckColors(counts) {
 const colors = new Set();
 Object.entries(counts).forEach(([idStr, cnt]) => {
   if (cnt > 0) {
     const base = cards.find(c => c.id === parseInt(idStr,10));
     if (base) colors.add(base.color);
   }
 });
 return colors;
}

function changeDeckCount(cardId, diff) {
 const card = cards.find(c => c.id === cardId);
 if (!card) return;

 let cur = deckCounts[cardId] || 0;
 const before = cur;
 cur += diff;
 if (cur < 0) cur = 0;

 deckCounts[cardId] = cur;

 if (cur > before) {
   const colors = getDeckColors(deckCounts);
   if (colors.size > 2) {
     deckCounts[cardId] = before;
     cur = before;
     alert("ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ã§ã™ã€‚3è‰²ç›®ã®ã‚«ãƒ¼ãƒ‰ã¯å…¥ã‚Œã‚‰ã‚Œã¾ã›ã‚“ã€‚");
   }
 }

 const basic = isBasicCard(cardId);
 if (!basic && cur > 4) {
   cur = 4;
   deckCounts[cardId] = cur;
   if (diff > 0) {
     alert("åŒã˜åå‰ã®ã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ã§ã™ã€‚");
   }
 }

 const span = document.getElementById("deck-count-"+cardId);
 if (span) span.textContent = cur;
}

function saveDeck() {
 const newDeck = [];
 Object.entries(deckCounts).forEach(([idStr,cnt]) => {
   const id = parseInt(idStr,10);
   for (let i=0;i<cnt;i++) newDeck.push(id);
 });

 if (newDeck.length < 60) {
   alert("ãƒ‡ãƒƒã‚­ã¯60æšä»¥ä¸Šã«ã—ã¦ãã ã•ã„ã€‚ï¼ˆç¾åœ¨ " + newDeck.length + "æšï¼‰");
   return;
 }

 savedDecks[currentDeckIndex] = newDeck;
 savePlayerDecks();
 alert("ãƒ‡ãƒƒã‚­" + (currentDeckIndex+1) + "ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ï¼ˆ" + newDeck.length + "æšï¼‰");
 updatePlayerDeckButtons();
}

/* ========== CPUè¨­å®š ========== */
let cpuStrength = "normal";
// CPUãƒ‡ãƒƒã‚­ã«ä½¿ã†è‰²ï¼ˆ2è‰²ã¾ã§ï¼‰
let cpuColors = ["red","purple"];
let playerDeckMode = "default";

function openCpuConfig() {
 updateCpuButtons();
 updatePlayerDeckButtons();
 showScreen("cpu");
}
function setCpuStrength(s) {
 cpuStrength = s;
 updateCpuButtons();
}

// è‰²ãƒœã‚¿ãƒ³ã®ãƒˆã‚°ãƒ«ï¼ˆæœ€å¤§2è‰²ï¼‰
function toggleCpuColor(color) {
 const idx = cpuColors.indexOf(color);
 if (idx >= 0) {
   cpuColors.splice(idx,1);
 } else {
   if (cpuColors.length >= 2) {
     alert("é¸ã¹ã‚‹è‰²ã¯2ã¤ã¾ã§ã§ã™ã€‚");
     return;
   }
   cpuColors.push(color);
 }
 updateCpuButtons();
}

function updateCpuButtons() {
 document.getElementById("btnCpuNormal").classList.toggle("toggle-selected", cpuStrength==="normal");
 document.getElementById("btnCpuStrong").classList.toggle("toggle-selected", cpuStrength==="strong");
 const colors = ["red","purple","blue","yellow","white","green"];
 colors.forEach(c => {
   const btnId = "cpu" + c.charAt(0).toUpperCase() + c.slice(1);
   const btn = document.getElementById(btnId);
   if (!btn) return;
   btn.classList.toggle("toggle-selected", cpuColors.includes(c));
 });
}

function hasCustomDeck(index) {
 const deck = savedDecks[index];
 return Array.isArray(deck) && deck.length > 0;
}

function updatePlayerDeckButtons() {
 const btnDef = document.getElementById("btnPlayerDefault");
 const btn1 = document.getElementById("btnDeck1");
 const btn2 = document.getElementById("btnDeck2");
 const btn3 = document.getElementById("btnDeck3");

 btnDef.classList.toggle("toggle-selected", playerDeckMode==="default");
 btn1.classList.toggle("toggle-selected", playerDeckMode==="deck1");
 btn2.classList.toggle("toggle-selected", playerDeckMode==="deck2");
 btn3.classList.toggle("toggle-selected", playerDeckMode==="deck3");

 const btns = [btn1, btn2, btn3];
 for (let i=0;i<3;i++) {
   if (!hasCustomDeck(i)) {
     btns[i].disabled = true;
     btns[i].textContent = "ãƒ‡ãƒƒã‚­" + (i+1) + "ï¼ˆæœªä¿å­˜ï¼‰";
   } else {
     btns[i].disabled = false;
     btns[i].textContent = "ãƒ‡ãƒƒã‚­" + (i+1);
   }
 }
}

function selectPlayerDeck(mode) {
 if (mode.startsWith("deck")) {
   const idx = parseInt(mode.slice(4), 10) - 1;
   if (!hasCustomDeck(idx)) {
     alert("ã¾ãšãƒ‡ãƒƒã‚­ç·¨é›†ã§ãƒ‡ãƒƒã‚­" + (idx+1) + "ã‚’ä¿å­˜ã—ã¦ãã ã•ã„ã€‚");
     return;
   }
 }
 playerDeckMode = mode;
 updatePlayerDeckButtons();
}

/* ========== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ========== */
function shuffle(arr) {
 for (let i=arr.length-1;i>0;i--) {
   const j = Math.floor(Math.random()*(i+1));
   [arr[i],arr[j]] = [arr[j],arr[i]];
 }
}

/* ========== ãƒãƒˆãƒ«é–¢é€£ ========== */
let battle = null;
let pendingAttackIndex = null;
let freezeSelectMode = false;
let destroySelectMode = false;
let destroySelectOwner = null;
let sendToInkSelectMode = false;
let sendToInkOwner = null;

let freezeTargets = [];

/* ã‚¢ãƒªã‚¨ãƒŠã‚¤ï¼ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ç”¨ã®çŠ¶æ…‹ */
let arienaiState = null;   // { owner, revealed: [cardInst], stage: 'choose'|'order' }
let pretzelState = null;   // { owner, targets:[{index,name,damage,heal}], totalHeal, maxHeal }

/* ã‚¸ãƒ¼ãƒ¦ãƒ¼ï¼ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ç”¨ */
let giyuOwnerSide = null;

/* ========== ã‚¤ãƒ³ã‚¯é–¢é€£ï¼ˆãƒªãƒ³å¯¾å¿œï¼‰ ========== */
function ownerHasLin(owner) {
 return owner.field.some(card => card.id === ID_LIN);
}
function getMaxInkPerTurn(owner) {
 let base = 1;
 if (ownerHasLin(owner)) base += 1;
 return base;
}

/* ========== ãƒªãƒ³ã®ãƒ­ã‚¢å‹•çš„æ›´æ–°ï¼‹ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³å›é¿ ========== */
function updateLinLore() {
 if (!battle) return;
 [battle.player, battle.cpu].forEach(owner => {
   owner.field.forEach(card => {
     if (card.id === ID_LIN) {
       card.lore = (owner.inkTotal >= 10 ? 5 : 1);
     }
   });

   // ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³ï¼šä»–ã®ã‚­ãƒ£ãƒ©ãŒã„ã‚‹é–“ã ã‘å›é¿ã‚’å¾—ã‚‹
   owner.field.forEach(card => {
     if (card.id === ID_CHAMELEON) {
       const others = owner.field.filter(c => c !== card);
       card.evade = (others.length > 0);
     }
   });
 });
}

/* ========== æ­»äº¡æ™‚å‡¦ç†ï¼ˆã‚‰ãŸã°ã‚ç­‰ï¼‰ ========== */
function onCardDestroyed(owner, card) {
 if (card.id === ID_RATABAA) {
   owner.inkTotal++;
   owner.inkAvail++;
   addLog(`ã€Œ${card.name}ã€ã¯ç ´å£Šã•ã‚Œã€ã‚³ã‚¹ãƒˆã«ãªã£ãŸã€‚`);
 }
}

/* ========== ã‚³ã‚¹ãƒˆé€ã‚Š ========== */
function sendCharacterToInk(owner, index) {
 const card = owner.field[index];
 if (!card) return;
 owner.field.splice(index,1);
 owner.inkTotal++;
 owner.inkAvail++;
 addLog(`ã€Œ${card.name}ã€ã¯ã‚³ã‚¹ãƒˆã«é€ã‚‰ã‚ŒãŸã€‚`);
}

/* ========== æ”»æ’ƒåŠ›è¨ˆç®—ï¼ˆç°çŒ›2å¯¾å¿œï¼‰ ========== */
function getAttackPower(card, asChallenger) {
 if (!card) return 0;
 let atk = card.atk;
 if (asChallenger && card.ferocious) {
   atk += card.ferocious;
 }
 return atk;
}

/* ========== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³é–‹å§‹ ========== */
function startPlayerTurn(isFirstTurn) {
 if (!battle) return;
 const p = battle.player;

 battle.turn = "player";

 p.field.forEach(card => {
   card.rest = false;
   if (card.frozen) card.frozen = false;
 });

 p.inkUsedThisTurn = 0;
 p.inkAvail = p.inkTotal;

 if (!isFirstTurn) {
   if (p.deck.length) {
     p.hand.push(p.deck.pop());
     addLog("è‡ªåˆ†ã¯1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚");
   } else {
     addLog("è‡ªåˆ†ã¯å±±æœ­ãŒãªãã€ãƒ‰ãƒ­ãƒ¼ã§ããªã„ã€‚");
   }
 }

 addLog("è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã€‚");
 document.getElementById("actionArea").textContent = "ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚";
 updateBattleView();
}

/* ========== ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æç”» ========== */
function renderCardHtml(card) {
 const powerText = (card.type === "character")
   ? `${card.atk} / ${card.hp}/${card.maxHp}`
   : "ã‚½ãƒ³ã‚°";
 const loreText = card.lore ? `ãƒ­ã‚¢${card.lore}` : "";
 const costable = card.inkable ? "â­•ï¸" : "âŒ";
 let frozenMark = card.frozen ? "â„" : "";

 return `
   <div class="card ${card.color} ${card.rest ? "rest" : ""}">
     <div class="card-header">
       <span class="card-cost">${card.cost}</span>
       <span class="card-name-header">${card.name}${frozenMark}</span>
       <span class="card-inkable">${costable}</span>
     </div>
     <div class="card-illustration"></div>
     <div class="card-stats-row">
       <span>${powerText}</span>
       <span>${loreText}</span>
     </div>
     <div class="card-footer">
       ${card.type === "song" ? "ã‚½ãƒ³ã‚°" : "ã‚­ãƒ£ãƒ©"}
     </div>
   </div>
 `;
}

function updateBattleView() {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;

 updateLinLore();

 document.getElementById("playerLore").textContent = p.lore;
 document.getElementById("playerInkCurrent").textContent = p.inkAvail;
 document.getElementById("playerInkMax").textContent = p.inkTotal;
 document.getElementById("playerDeck").textContent = p.deck.length;

 document.getElementById("cpuHandCount").textContent = c.hand.length;
 document.getElementById("cLore").textContent = c.lore;
 document.getElementById("cDeck").textContent = c.deck.length;

 const pf = document.getElementById("playerField");
 pf.innerHTML = "";
 p.field.forEach((card, idx)=>{
   const wrap = document.createElement("div");
   wrap.innerHTML = renderCardHtml(card);
   const el = wrap.firstElementChild;
   el.onclick = ()=>onPlayerFieldClick(idx);
   pf.appendChild(el);
 });

 const cf = document.getElementById("cpuField");
 cf.innerHTML = "";
 c.field.forEach((card, idx)=>{
   const wrap = document.createElement("div");
   wrap.innerHTML = renderCardHtml(card);
   const el = wrap.firstElementChild;
   el.onclick = ()=>onCpuFieldClick(idx);
   cf.appendChild(el);
 });

 const ph = document.getElementById("playerHand");
 ph.innerHTML = "";
 p.hand.forEach((card, idx)=>{
   const wrap = document.createElement("div");
   wrap.innerHTML = renderCardHtml(card);
   const cardEl = wrap.firstElementChild;

   cardEl.onclick = ()=>showCardDetail(card);

   const btnArea = document.createElement("div");
   btnArea.className = "card-footer-buttons";

   const inkBtn = document.createElement("button");
   inkBtn.className = "btn small";
   inkBtn.textContent = "ã‚¤ãƒ³ã‚¯";
   inkBtn.onclick = (e)=>{ e.stopPropagation(); inkFromHand(idx); };
   btnArea.appendChild(inkBtn);

   const actionBtn = document.createElement("button");
   actionBtn.className = "btn small";
   if (card.type === "song") {
     actionBtn.textContent = "ä½¿ç”¨";
     actionBtn.onclick = (e)=>{ e.stopPropagation(); useSongFromHand(idx); };
   } else {
     actionBtn.textContent = "å¬å–š";
     actionBtn.onclick = (e)=>{ e.stopPropagation(); playFromHand(idx); };
   }
   btnArea.appendChild(actionBtn);

   cardEl.appendChild(btnArea);
   ph.appendChild(cardEl);
 });

 document.getElementById("turnInfo").textContent =
   (battle.turn === "player") ? "è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³" : "ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³";

 checkWin();
}

/* ========== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œå‹• ========== */
function playerDraw() {
 alert("ãƒ‰ãƒ­ãƒ¼ã¯ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«è‡ªå‹•ã§1æšè¡Œã‚ã‚Œã¾ã™ã€‚ï¼ˆå…ˆæ”»1ã‚¿ãƒ¼ãƒ³ç›®ã‚’é™¤ãï¼‰");
}

function inkFromHand(index) {
 if (!battle) return;
 const p = battle.player;
 const card = p.hand[index];
 if (!card) return;

 const maxInk = getMaxInkPerTurn(p);
 if (p.inkUsedThisTurn >= maxInk) {
   alert("ã“ã®ã‚¿ãƒ¼ãƒ³ã«ç½®ã‘ã‚‹ã‚¤ãƒ³ã‚¯ã¯ã“ã‚Œä»¥ä¸Šã‚ã‚Šã¾ã›ã‚“ã€‚");
   return;
 }

 if (!card.inkable) {
   alert("ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ã‚¤ãƒ³ã‚¯ã«ã§ãã¾ã›ã‚“ã€‚");
   return;
 }
 p.hand.splice(index,1);
 p.inkTotal++;
 p.inkAvail++;
 p.inkUsedThisTurn++;
 addLog(`ã€Œ${card.name}ã€ã‚’ã‚¤ãƒ³ã‚¯ã«ç½®ã„ãŸã€‚`);
 updateBattleView();
}

/* ====== ã‚½ãƒ³ã‚°ã‚’æ‰‹æœ­ã‹ã‚‰ã€Œä½¿ç”¨ã€ ====== */
function useSongFromHand(index) {
 if (!battle) return;
 const p = battle.player;
 const card = p.hand[index];
 if (!card || card.type !== "song") return;

 if (p.inkAvail < card.cost) {
   alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
   return;
 }

 p.inkAvail -= card.cost;
 p.hand.splice(index,1);

 addLog(`ã€Œ${card.name}ã€ã‚’ä½¿ç”¨ã—ã€ç ´å£Šã•ã‚ŒãŸã€‚`);

 if (card.effect === "boardwipe") {
   battle.player.field.forEach(cd => onCardDestroyed(battle.player, cd));
   battle.cpu.field.forEach(cd => onCardDestroyed(battle.cpu, cd));
   battle.player.field = [];
   battle.cpu.field = [];
   addLog("çµ‚ç„‰ã®å¤§ç«ãŒç™ºå‹•ï¼å ´ã®ã‚­ãƒ£ãƒ©ã¯ã™ã¹ã¦ç ´å£Šã•ã‚ŒãŸï¼");
 } else if (card.effect === "songToInk1") {
   if (battle.cpu.field.length === 0) {
     addLog("å¯¾è±¡ã®ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ã€Œã‚ã‚Šã®ã¾ã¾ã§ã€ã¯ä¸ç™ºã€‚");
   } else {
     selectCharacterForSongToInk("cpu");
   }
 } else if (card.effect === "hiyariDiscard") {
   doHiyariEffect(battle.player);
 } else if (card.effect === "tiramisuDraw3") {
   doTiramisuEffect(battle.player);
 } else if (card.effect === "ahnwResetHands") {
   doAhnwEffect();
 } else if (card.effect === "slash3Damage") {
   startSlashSelect("player");
 } else if (card.effect === "stabAoE2") {
   doStabAllEffect(battle.player);
 }

 document.getElementById("actionArea").textContent = "ã‚½ãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚";
 updateBattleView();
}

/* ====== ã‚­ãƒ£ãƒ©ã§ã‚½ãƒ³ã‚°ã‚’æ­Œã† ====== */
function playFromHand(index) {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;
 const card = p.hand[index];
 if (!card) return;

 if (card.type === "song") {
   useSongFromHand(index);
   return;
 }

 // å¤‰èº«ï¼ˆã‚±ãƒ«ã‚µï¼‰
 if (card.evolveCost !== undefined) {
   const baseNamePart = "ã‚«ãƒ¼";
   let baseIndex = -1;
   for (let i=0;i<p.field.length;i++) {
     if (p.field[i].name.includes(baseNamePart)) {
       baseIndex = i;
       break;
     }
   }
   if (baseIndex >= 0) {
     const base = p.field[baseIndex];
     if (p.inkAvail < card.evolveCost) {
       alert("å¤‰èº«ã‚³ã‚¹ãƒˆãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
       return;
     }
     p.inkAvail -= card.evolveCost;
     const lost = base.maxHp - base.hp;
     card.hp = card.maxHp - lost;
     if (card.hp < 1) card.hp = 1;
     card.rest = base.rest;
     card.summonTurn = base.summonTurn;
     p.field[baseIndex] = card;
     p.hand.splice(index,1);
     addLog(`ã€Œ${base.name}ã€ã¯ã€Œ${card.name}ã€ã«å¤‰èº«ã—ãŸï¼`);

     let openedEffectPopup = false;
     if (card.effect === "freeze2") {
       startFreezeSelect();
     } else if (card.effect === "pretzelHealDraw") {
       doPretzelEffect(p);
       openedEffectPopup = true;
     } else if (card.effect === "arienaiSearchSong") {
       doArienaiEffect(p);
       openedEffectPopup = true;
     } else if (card.effect === "giyuBounce") {
       doGiyuEffect(p);
       openedEffectPopup = true;
     } else if (card.effect === "majoDraw1") {
       doMajoEffect(p);
     }

     updateBattleView();
     if (!openedEffectPopup) {
       showCardDetail(card);
     }
     return;
   }
 }

 // é€šå¸¸å¬å–š
 if (p.inkAvail < card.cost) {
   alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
   return;
 }
 p.inkAvail -= card.cost;
 card.summonTurn = battle.turnCount;
 card.rest = false;
 p.hand.splice(index,1);
 p.field.push(card);
 addLog(`ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);

 let openedEffectPopup = false;
 if (card.effect === "freeze2") {
   startFreezeSelect();
 } else if (card.effect === "destroyOnSummon") {
   startDestroySelect("cpu");
 } else if (card.effect === "toInkOnSummon") {
   startSendToInkSelect("cpu");
 } else if (card.effect === "pretzelHealDraw") {
   doPretzelEffect(p);
   openedEffectPopup = true;
 } else if (card.effect === "arienaiSearchSong") {
   doArienaiEffect(p);
   openedEffectPopup = true;
 } else if (card.effect === "giyuBounce") {
   doGiyuEffect(p);
   openedEffectPopup = true;
 } else if (card.effect === "majoDraw1") {
   doMajoEffect(p);
 }

 updateBattleView();
 if (!openedEffectPopup) {
   showCardDetail(card);
 }
}

/* ========== ãƒ‰ãƒ­ãƒ¼ã®å…±é€šé–¢æ•°ï¼ˆãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ç”¨ãªã©ï¼‰ ========== */
function drawOne(owner) {
 if (!owner.deck.length) return false;
 owner.hand.push(owner.deck.pop());
 return true;
}

/* ========== ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«åŠ¹æœï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§é¸æŠ / CPUã¯è‡ªå‹•ï¼‰ ========== */
function doPretzelEffect(owner) {
 if (!battle) return;

 if (owner === battle.cpu) {
   doPretzelCpuEffect(owner);
   return;
 }

 const targets = owner.field.map((c, idx) => {
   const dmg = c.maxHp - c.hp;
   return {
     index: idx,
     name: c.name,
     damage: dmg,
     heal: 0
   };
 }).filter(t => t.damage > 0);

 pretzelState = {
   owner,
   targets,
   totalHeal: 0,
   maxHeal: 3
 };

 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 if (targets.length === 0) {
   content.innerHTML = `
     <div style="margin-bottom:6px;">ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœï¼šå›å¾©ã§ãã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æŒã¤ã‚­ãƒ£ãƒ©ãŒã„ã¾ã›ã‚“ã€‚</div>
     <div>ãã®ã¾ã¾åŠ¹æœã¯çµ‚äº†ã—ã¾ã™ã€‚</div>
   `;
   overlay.style.display = "block";
   return;
 }

 renderPretzelPopup();
}

function renderPretzelPopup() {
 if (!pretzelState) return;
 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 const st = pretzelState;
 let html = `
   <div style="font-weight:bold; margin-bottom:6px;">ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ï¼šå›å¾©ï¼†ãƒ‰ãƒ­ãƒ¼</div>
   <div style="font-size:12px; margin-bottom:4px;">
     è‡ªåˆ†ã®å ´ã®ã‚­ãƒ£ãƒ©ã‹ã‚‰åˆè¨ˆ${st.maxHeal}ãƒ€ãƒ¡ãƒ¼ã‚¸ã¾ã§å›å¾©ã§ãã¾ã™ã€‚<br>
     å›å¾©ã—ãŸåˆè¨ˆãƒ€ãƒ¡ãƒ¼ã‚¸åˆ†ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‰ãƒ­ãƒ¼ã—ã¾ã™ï¼ˆ0ã€œ3æš OKï¼‰ã€‚
   </div>
   <div style="font-size:12px; margin-bottom:6px;">
     ç¾åœ¨ã®åˆè¨ˆå›å¾©äºˆå®šï¼š<b>${st.totalHeal}</b> / ${st.maxHeal}
   </div>
 `;

 st.targets.forEach((t, i) => {
   html += `
     <div style="border:1px solid #555; border-radius:6px; padding:4px; margin-bottom:4px;">
       <div style="font-weight:bold;">${t.name}</div>
       <div style="font-size:12px;">ç¾åœ¨ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼š${t.damage}</div>
       <div style="margin-top:2px; font-size:12px; display:flex; align-items:center; gap:4px;">
         <button class="btn small" style="flex:none;" onclick="pretzelAdjust(${i}, -1)">ï¼</button>
         <span>å›å¾©äºˆå®šï¼š${t.heal}</span>
         <button class="btn small" style="flex:none;" onclick="pretzelAdjust(${i}, 1)">ï¼‹</button>
       </div>
     </div>
   `;
 });

 html += `
   <div style="margin-top:6px; display:flex; gap:4px; flex-wrap:wrap;">
     <button class="btn small primary" onclick="pretzelConfirm()">é¸æŠçµ‚äº†ï¼ˆå®Ÿè¡Œï¼‰</button>
     <button class="btn small" onclick="pretzelCancel()">å›å¾©0ã§çµ‚äº†</button>
   </div>
 `;

 content.innerHTML = html;
 overlay.style.display = "block";
}

function pretzelAdjust(index, delta) {
 if (!pretzelState) return;
 const st = pretzelState;
 const t = st.targets[index];
 if (!t) return;

 const newHeal = t.heal + delta;
 if (newHeal < 0) return;
 if (newHeal > t.damage) return;

 const newTotal = st.totalHeal + delta;
 if (newTotal < 0 || newTotal > st.maxHeal) return;

 t.heal = newHeal;
 st.totalHeal = newTotal;
 renderPretzelPopup();
}

function pretzelConfirm() {
 if (!pretzelState) return;
 const st = pretzelState;
 const owner = st.owner;
 let total = 0;

 st.targets.forEach(t => {
   if (t.heal > 0) {
     const card = owner.field[t.index];
     if (!card) return;
     card.hp = Math.min(card.maxHp, card.hp + t.heal);
     total += t.heal;
   }
 });

 for (let i = 0; i < total; i++) {
   drawOne(owner);
 }

 if (total > 0) {
   if (owner === battle.player) {
     addLog(`ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã§åˆè¨ˆ${total}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å›å¾©ã—ã€${total}æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
   } else {
     addLog(`CPUã®ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã§${total}å›å¾©ï¼†${total}ãƒ‰ãƒ­ãƒ¼ã€‚`);
   }
 } else {
   addLog("ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã‚’ä½¿ç”¨ã—ã¾ã—ãŸãŒã€å›å¾©ãƒ»ãƒ‰ãƒ­ãƒ¼ã¯0ã§ã—ãŸã€‚");
 }

 pretzelState = null;
 closeCardDetail();
 updateBattleView();
}

function pretzelCancel() {
 if (!pretzelState) return;
 addLog("ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã‚’ä½¿ã‚ãšã«çµ‚äº†ã—ãŸã€‚");
 pretzelState = null;
 closeCardDetail();
 updateBattleView();
}

function doPretzelCpuEffect(owner) {
 let healed = 0;
 while (healed < 3) {
   const target = owner.field.find(c => c.hp < c.maxHp);
   if (!target) break;
   target.hp++;
   healed++;
 }
 if (healed > 0) {
   for (let i=0;i<healed;i++) {
     drawOne(owner);
   }
   if (owner === battle.player) {
     addLog(`ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã§åˆè¨ˆ${healed}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å›å¾©ã—ã€${healed}æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
   } else {
     addLog(`CPUã®ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã§${healed}å›å¾©ï¼†${healed}ãƒ‰ãƒ­ãƒ¼ã€‚`);
   }
 }
}

/* ========== ã‚¢ãƒªã‚¨ãƒŠã‚¤åŠ¹æœï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯é¸æŠï¼‹é †ç•ªæŒ‡å®šï¼‰ ========== */
function doArienaiEffect(owner) {
 if (!battle) return;

 if (owner === battle.cpu) {
   doArienaiCpuEffect(owner);
   return;
 }

 const temp = [];
 for (let i=0;i<4 && owner.deck.length;i++) {
   temp.push(owner.deck.pop());
 }
 if (temp.length === 0) {
   addLog("ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€ã®åŠ¹æœï¼šå±±æœ­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
   return;
 }

 arienaiState = {
   owner,
   revealed: temp,
   stage: "choose"
 };

 showArienaiChoosePopup();
}

function showArienaiChoosePopup() {
 if (!arienaiState) return;
 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 const st = arienaiState;
 let html = `
   <div style="font-weight:bold; margin-bottom:6px;">ã‚¢ãƒªã‚¨ãƒŠã‚¤ï¼šãƒ‡ãƒƒã‚­ã®ä¸Šã‹ã‚‰4æšã‚’è¦‹ã‚‹</div>
   <div style="font-size:12px; margin-bottom:6px;">
     ä¸‹ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã®ã†ã¡ã€ã‚½ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã‚’1æšã¾ã§é¸ã‚“ã§æ‰‹æœ­ã«åŠ ãˆã¾ã™ã€‚<br>
     é¸ã°ãªã‹ã£ãŸã‚«ãƒ¼ãƒ‰ã¯ã€ã“ã®ã‚ã¨é †ç•ªã‚’æŒ‡å®šã—ã¦ãƒ‡ãƒƒã‚­ã®ä¸€ç•ªä¸‹ã«æˆ»ã—ã¾ã™ã€‚
   </div>
 `;

 st.revealed.forEach((card, idx) => {
   const isSong = (card.type === "song");
   html += `
     <div style="border:1px solid ${isSong ? '#facc15' : '#555'}; border-radius:6px; padding:4px; margin-bottom:4px;">
       <div style="font-weight:bold;">${card.name}</div>
       <div style="font-size:12px;">ç¨®é¡:${card.type} / è‰²:${card.color}</div>
       <div style="margin-top:4px;">
         <button class="btn small" ${isSong ? `onclick="arienaiChooseSong(${idx})"` : "disabled"}>ã“ã®ã‚½ãƒ³ã‚°ã‚’æ‰‹æœ­ã«åŠ ãˆã‚‹</button>
       </div>
     </div>
   `;
 });

 html += `
   <div style="margin-top:6px;">
     <button class="btn small" onclick="arienaiSkipSong()">ã‚½ãƒ³ã‚°ã‚’é¸ã°ãªã„</button>
   </div>
 `;

 content.innerHTML = html;
 overlay.style.display = "block";
}

function arienaiChooseSong(index) {
 if (!arienaiState) return;
 const st = arienaiState;
 const card = st.revealed[index];
 if (!card || card.type !== "song") return;

 st.owner.hand.push(card);
 st.revealed.splice(index, 1);
 addLog(`ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€ã®åŠ¹æœã§ã‚½ãƒ³ã‚°ã€Œ${card.name}ã€ã‚’æ‰‹æœ­ã«åŠ ãˆãŸã€‚`);

 st.stage = "order";
 showArienaiOrderPopup();
}

function arienaiSkipSong() {
 if (!arienaiState) return;
 arienaiState.stage = "order";
 showArienaiOrderPopup();
}

function showArienaiOrderPopup() {
 if (!arienaiState) return;
 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 const st = arienaiState;
 let html = `
   <div style="font-weight:bold; margin-bottom:6px;">ã‚¢ãƒªã‚¨ãƒŠã‚¤ï¼šæ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒƒã‚­ã®ä¸‹ã«æˆ»ã™</div>
   <div style="font-size:12px; margin-bottom:6px;">
     ä¸‹ã«ä¸¦ã‚“ã§ã„ã‚‹é †ç•ªã§ã€ä¸Šã«ã‚ã‚‹ã‚«ãƒ¼ãƒ‰ã‹ã‚‰é †ã«ã€Œãƒ‡ãƒƒã‚­ã®ä¸€ç•ªä¸‹ã€ã«ç½®ã‹ã‚Œã¾ã™ã€‚<br>
     ï¼ˆã¤ã¾ã‚Šãƒªã‚¹ãƒˆã®ä¸€ç•ªä¸‹ã®ã‚«ãƒ¼ãƒ‰ãŒã€ã„ã¡ã°ã‚“ä¸Šå´ã«è¿‘ã„ä½ç½®ã«ãªã‚Šã¾ã™ï¼‰
   </div>
 `;

 st.revealed.forEach((card, idx) => {
   html += `
     <div style="border:1px solid #555; border-radius:6px; padding:4px; margin-bottom:4px;">
       <div style="font-weight:bold;">${card.name}</div>
       <div style="font-size:12px;">ç¨®é¡:${card.type} / è‰²:${card.color}</div>
       <div style="margin-top:4px; display:flex; gap:4px;">
         <button class="btn small" onclick="arienaiMoveUp(${idx})">â†‘ ä¸Šã¸</button>
         <button class="btn small" onclick="arienaiMoveDown(${idx})">â†“ ä¸‹ã¸</button>
       </div>
     </div>
   `;
 });

 html += `
   <div style="margin-top:6px;">
     <button class="btn small primary" onclick="arienaiConfirmOrder()">ã“ã®é †ç•ªã§ãƒ‡ãƒƒã‚­ã®ä¸‹ã«ç½®ã</button>
   </div>
 `;

 content.innerHTML = html;
 overlay.style.display = "block";
}

function arienaiMoveUp(index) {
 if (!arienaiState) return;
 if (index === 0) return;
 const arr = arienaiState.revealed;
 [arr[index-1], arr[index]] = [arr[index], arr[index-1]];
 showArienaiOrderPopup();
}

function arienaiMoveDown(index) {
 if (!arienaiState) return;
 const arr = arienaiState.revealed;
 if (index === arr.length - 1) return;
 [arr[index+1], arr[index]] = [arr[index], arr[index+1]];
 showArienaiOrderPopup();
}

function arienaiConfirmOrder() {
 if (!arienaiState) return;
 const st = arienaiState;
 const owner = st.owner;

 for (let i = st.revealed.length - 1; i >= 0; i--) {
   owner.deck.unshift(st.revealed[i]);
 }

 addLog("ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€ã®åŠ¹æœã§æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒƒã‚­ã®ä¸€ç•ªä¸‹ã«æˆ»ã—ãŸã€‚");

 arienaiState = null;
 closeCardDetail();
 updateBattleView();
}

function doArienaiCpuEffect(owner) {
 const temp = [];
 for (let i=0;i<4 && owner.deck.length;i++) {
   temp.push(owner.deck.pop());
 }
 let songIndex = -1;
 for (let i=0;i<temp.length;i++) {
   if (temp[i].type === "song") { songIndex = i; break; }
 }
 if (songIndex >= 0) {
   const card = temp.splice(songIndex,1)[0];
   owner.hand.push(card);
   addLog(`CPUã®ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€ã®åŠ¹æœã§ã‚½ãƒ³ã‚°ã€Œ${card.name}ã€ã‚’æ‰‹æœ­ã«åŠ ãˆãŸã€‚`);
 }
 for (let i=temp.length-1;i>=0;i--) {
   owner.deck.unshift(temp[i]);
 }
}

/* ========== ã‚±ãƒ«ã‚µã®å‡çµ ========== */
function startFreezeSelect() {
 if (!battle) return;
 const c = battle.cpu;
 if (c.field.length === 0) {
   addLog("ã‚±ãƒ«ã‚µåŠ¹æœï¼šå¯¾è±¡ã®ã‚­ãƒ£ãƒ©ãŒã„ã¾ã›ã‚“ã€‚");
   return;
 }
 freezeTargets = [];
 freezeSelectMode = true;
 document.getElementById("actionArea").innerHTML =
   `å‡çµã•ã›ã‚‹ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆæœ€å¤§2ä½“ï¼‰ã€‚<br>
    ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠã€‚<br>
    <button class="btn small" onclick="finishFreezeSelect()">é¸æŠçµ‚äº†</button>`;
}

function finishFreezeSelect() {
 if (!battle) return;
 const c = battle.cpu;
 freezeTargets.forEach(idx=>{
   if (c.field[idx]) {
     c.field[idx].frozen = true;
     addLog(`ã€Œ${c.field[idx].name}ã€ã¯å‡çµã•ã‚ŒãŸï¼`);
   }
 });
 freezeSelectMode = false;
 freezeTargets = [];
 document.getElementById("actionArea").textContent = "ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚";
 updateBattleView();
}

/* ========== ãƒã‚¸ãƒ§ãƒ‰ãƒ©ç ´å£Šé¸æŠ ========== */
function startDestroySelect(ownerSide) {
 destroySelectMode = true;
 destroySelectOwner = ownerSide;
 document.getElementById("actionArea").textContent =
   "é€€å ´ã•ã›ã‚‹ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’1ä½“é¸ã‚“ã§ãã ã•ã„ã€‚";
}

/* ========== ã‚³ã‚¹ãƒˆé€ã‚Šé¸æŠï¼ˆã‚´ãƒ¼ã‚ºç”¨ï¼‰ ========== */
function startSendToInkSelect(ownerSide) {
 sendToInkSelectMode = true;
 sendToInkOwner = ownerSide;
 document.getElementById("actionArea").textContent =
   "ã‚³ã‚¹ãƒˆã«é€ã‚‹ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚";
}

/* ========== ã€Œã‚ã‚Šã®ã¾ã¾ã§ã€å¯¾è±¡é¸æŠãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— ========== */
function selectCharacterForSongToInk(ownerSide) {
 const owner = (ownerSide === "cpu") ? battle.cpu : battle.player;
 if (!owner || owner.field.length === 0) return;

 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 let html = `<div style="font-weight:bold; margin-bottom:6px;">ã€Œã‚ã‚Šã®ã¾ã¾ã§ã€ã®å¯¾è±¡ã‚’é¸ã‚“ã§ãã ã•ã„</div>`;
 owner.field.forEach((card, idx) => {
   html += `<button class="btn small" style="margin-bottom:4px; width:100%;"
             onclick="songToInkChosen('${ownerSide}',${idx})">${card.name}</button>`;
 });
 html += `<button class="btn small" style="width:100%; margin-top:4px;"
           onclick="closeCardDetail()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>`;

 content.innerHTML = html;
 overlay.style.display = "block";
}

function songToInkChosen(ownerSide, index) {
 const owner = (ownerSide === "cpu") ? battle.cpu : battle.player;
 if (!owner || !owner.field[index]) return;
 sendCharacterToInk(owner, index);
 closeCardDetail();
 document.getElementById("actionArea").textContent = "ã‚½ãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚";
 updateBattleView();
}

/* ========== ã‚¿ã‚¤ã‚¿ãƒ³ã®å¼·åˆ¶ã‚¢ã‚¿ãƒƒã‚¯åˆ¤å®š ========== */
function hasValidChallengeTarget(attacker, attackerOwner, defenderOwner) {
 let targets = defenderOwner.field.filter(t => t.rest);
 if (!attacker.evade) {
   const evadeTargets = targets.filter(t => t.evade);
   if (evadeTargets.length) targets = evadeTargets;
 }
 return targets.length > 0;
}

/* ========== ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¯ãƒªãƒƒã‚¯ ========== */
function onPlayerFieldClick(index) {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;
 const card = p.field[index];
 if (!card) return;

 if (card.summonTurn === battle.turnCount && battle.turn === "player") {
   showCardDetail(card);
   document.getElementById("actionArea").textContent =
     "å¬å–šã—ãŸã‚¿ãƒ¼ãƒ³ã¯ã‚·ãƒ¼ã‚¯ï¼ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼ã‚½ãƒ³ã‚°ã¯ã§ãã¾ã›ã‚“ã€‚";
   return;
 }

 if (card.frozen) {
   alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯å‡çµä¸­ã§ã™ã€‚");
   showCardDetail(card);
   return;
 }
 if (card.rest) {
   showCardDetail(card);
   return;
 }

 const titanMustAttack =
   card.mustAttack && hasValidChallengeTarget(card, p, c);

 let html = `<div>${card.name} ã®è¡Œå‹•ã‚’é¸æŠï¼š</div>`;

 if (!titanMustAttack) {
   html += `<button class="btn small" onclick="doSeek(${index})">ã‚·ãƒ¼ã‚¯ï¼ˆãƒ­ã‚¢ï¼‹${card.lore}ï¼‰</button>`;
 }

 html += `<button class="btn small" onclick="prepareChallenge(${index})">ãƒãƒ£ãƒ¬ãƒ³ã‚¸</button>`;

 const songIndex = findSongInHand(card.songPower);
 if (!titanMustAttack && songIndex >= 0) {
   html += `<button class="btn small" onclick="songAsk(${index},${songIndex})">ã‚½ãƒ³ã‚°ã‚’æ­Œã†</button>`;
 }

 document.getElementById("actionArea").innerHTML = html;
 showCardDetail(card);
}

function onCpuFieldClick(index) {
 if (!battle) return;
 const c = battle.cpu;
 const p = battle.player;
 const card = c.field[index];
 if (!card) return;

 if (sendToInkSelectMode && sendToInkOwner === "cpu") {
   sendCharacterToInk(c, index);
   sendToInkSelectMode = false;
   sendToInkOwner = null;
   document.getElementById("actionArea").textContent =
     "ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚";
   updateBattleView();
   return;
 }

 if (destroySelectMode && destroySelectOwner === "cpu") {
   const target = c.field[index];
   if (target) {
     c.field.splice(index,1);
     onCardDestroyed(c, target);
     addLog(`ã€Œ${target.name}ã€ã¯ã€Œãƒã‚¸ãƒ§ãƒ‰ãƒ©ã€ã®åŠ¹æœã§é€€å ´ã—ãŸã€‚`);
   }
   destroySelectMode = false;
   destroySelectOwner = null;
   document.getElementById("actionArea").textContent =
     "ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚";
   updateBattleView();
   return;
 }

 if (freezeSelectMode) {
   if (!freezeTargets.includes(index)) {
     freezeTargets.push(index);
     addLog(`å‡çµå¯¾è±¡ã«ã€Œ${card.name}ã€ã‚’é¸æŠã€‚`);
     if (freezeTargets.length >= 2) {
       finishFreezeSelect();
     }
   }
   return;
 }

 if (pendingAttackIndex !== null) {
   challengeTarget(index);
   return;
 }

 showCardDetail(card);
}

/* ========== ã‚·ãƒ¼ã‚¯ / ãƒãƒ£ãƒ¬ãƒ³ã‚¸ ========== */
function doSeek(index) {
 const p = battle.player;
 const card = p.field[index];
 if (!card) return;
 if (card.rest || card.frozen) return;

 if (!card.lore) {
   alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯ãƒ­ã‚¢ã‚’æŒãŸãªã„ãŸã‚ã€ã‚·ãƒ¼ã‚¯ã—ã¦ã‚‚ãƒ­ã‚¢ã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“ã€‚");
 }

 p.lore += card.lore;
 card.rest = true;
 addLog(`ã€Œ${card.name}ã€ãŒã‚·ãƒ¼ã‚¯ã—ã¦ãƒ­ã‚¢ã‚’${card.lore}å¾—ãŸã€‚`);
 document.getElementById("actionArea").textContent = "ã‚·ãƒ¼ã‚¯ã—ã¾ã—ãŸã€‚";
 updateBattleView();
}

function prepareChallenge(index) {
 const card = battle.player.field[index];
 if (!card) return;
 if (card.rest || card.frozen) return;

 pendingAttackIndex = index;
 document.getElementById("actionArea").textContent =
   "æ”»æ’ƒã™ã‚‹ç›¸æ‰‹ã®ãƒ¬ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚";
}

function challengeTarget(cpuIndex) {
 const p = battle.player;
 const c = battle.cpu;
 const attacker = p.field[pendingAttackIndex];
 const target   = c.field[cpuIndex];
 if (!attacker || !target) return;

 if (!target.rest) {
   alert("ãƒ¬ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚­ãƒ£ãƒ©ã—ã‹æ”»æ’ƒã§ãã¾ã›ã‚“ã€‚");
   return;
 }

 if (target.evade && !attacker.evade) {
   alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯å›é¿ã‚’æŒã¤ã‚­ãƒ£ãƒ©ã«ã—ã‹ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã•ã‚Œã¾ã›ã‚“ã€‚");
   return;
 }

 const attackerPower = getAttackPower(attacker, true);
 const targetPower   = getAttackPower(target, false);

 target.hp   -= attackerPower;
 attacker.hp -= targetPower;
 attacker.rest = true;

 addLog(`ã€Œ${attacker.name}ã€ãŒã€Œ${target.name}ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`);

 if (target.hp <= 0) {
   c.field.splice(cpuIndex,1);
   onCardDestroyed(c, target);
   addLog(`ã€Œ${target.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
 }
 if (attacker.hp <= 0) {
   p.field.splice(pendingAttackIndex,1);
   onCardDestroyed(p, attacker);
   addLog(`ã€Œ${attacker.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
 }

 pendingAttackIndex = null;
 document.getElementById("actionArea").textContent =
   "ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚";
 updateBattleView();
}

/* ========== ã‚½ãƒ³ã‚°ï¼ˆã‚­ãƒ£ãƒ©ã§æ­Œã†ï¼‰ ========== */
function findSongInHand(maxSongPower) {
 const hand = battle.player.hand;
 for (let i=0;i<hand.length;i++) {
   if (hand[i].type === "song" && hand[i].cost <= maxSongPower) return i;
 }
 return -1;
}

function songAsk(charIndex, songIndex) {
 const p = battle.player;
 const char = p.field[charIndex];
 const spell = p.hand[songIndex];
 let html = `
   <div>ã€Œ${spell.name}ã€ã‚’ ${char.name} ãŒæ­Œã„ã¾ã™ã‹ï¼Ÿ</div>
   <button class="btn small" onclick="songCast(${charIndex},${songIndex},true)">ã‚­ãƒ£ãƒ©ã§æ­Œã†ï¼ˆã‚³ã‚¹ãƒˆ0ï¼‰</button>
   <button class="btn small" onclick="songCast(${charIndex},${songIndex},false)">é€šå¸¸ä½¿ç”¨ï¼ˆã‚³ã‚¹ãƒˆæ”¯æ‰•ã„ï¼‰</button>
 `;
 document.getElementById("actionArea").innerHTML = html;
 showCardDetail(spell);
}

function songCast(charIndex, songIndex, freeCast) {
 const p = battle.player;
 const spell = p.hand[songIndex];

 if (!freeCast) {
   if (p.inkAvail < spell.cost) {
     alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
     return;
   }
   p.inkAvail -= spell.cost;
 } else {
   if (p.field[charIndex]) {
     p.field[charIndex].rest = true;
   }
 }

 p.hand.splice(songIndex,1);
 addLog(`ã€Œ${spell.name}ã€ã‚’ä½¿ç”¨ã—ã€ç ´å£Šã•ã‚ŒãŸã€‚`);

 if (spell.effect === "boardwipe") {
   battle.player.field.forEach(card => onCardDestroyed(battle.player, card));
   battle.cpu.field.forEach(card => onCardDestroyed(battle.cpu, card));
   battle.player.field = [];
   battle.cpu.field = [];
   addLog("çµ‚ç„‰ã®å¤§ç«ãŒç™ºå‹•ï¼å ´ã®ã‚­ãƒ£ãƒ©ã¯ã™ã¹ã¦ç ´å£Šã•ã‚ŒãŸï¼");
 } else if (spell.effect === "songToInk1") {
   if (battle.cpu.field.length === 0) {
     addLog("å¯¾è±¡ã®ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ã€Œã‚ã‚Šã®ã¾ã¾ã§ã€ã¯ä¸ç™ºã€‚");
   } else {
     selectCharacterForSongToInk("cpu");
   }
 } else if (spell.effect === "hiyariDiscard") {
   doHiyariEffect(battle.player);
 } else if (spell.effect === "tiramisuDraw3") {
   doTiramisuEffect(battle.player);
 } else if (spell.effect === "ahnwResetHands") {
   doAhnwEffect();
 } else if (spell.effect === "slash3Damage") {
   startSlashSelect("player");
 } else if (spell.effect === "stabAoE2") {
   doStabAllEffect(battle.player);
 }

 document.getElementById("actionArea").textContent = "ã‚½ãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚";
 updateBattleView();
}

/* ========== ã‚¿ãƒ¼ãƒ³çµ‚äº† & CPUã‚¿ãƒ¼ãƒ³ ========== */
function endTurn() {
 if (!battle) return;
 if (battle.turn !== "player") return;

 const p = battle.player;
 const c = battle.cpu;
 for (let i=0;i<p.field.length;i++) {
   const card = p.field[i];
   if (card.mustAttack && !card.rest && !card.frozen &&
       hasValidChallengeTarget(card, p, c)) {
     alert("ã€Œã‚¿ã‚¤ã‚¿ãƒ³ã€ã¯æ”»æ’ƒå¯èƒ½ãªå ´åˆã€å¿…ãšãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚");
     return;
   }
 }

 battle.turn = "cpu";
 addLog("è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³çµ‚äº†ã€‚CPUã®ã‚¿ãƒ¼ãƒ³ã€‚");
 cpuTurn();
}

function cpuTurn() {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;

 battle.turnCount++;
 battle.turn = "cpu";

 c.field.forEach(card => {
   card.rest = false;
   if (card.frozen) card.frozen = false;
 });

 c.inkUsedThisTurn = 0;
 c.inkAvail = c.inkTotal;

 if (c.deck.length) {
   c.hand.push(c.deck.pop());
   addLog("CPUã¯1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚");
 } else {
   addLog("CPUã¯å±±æœ­ãŒãªãã€ãƒ‰ãƒ­ãƒ¼ã§ããªã„ã€‚");
 }

 const maxInk = getMaxInkPerTurn(c);
 while (c.inkUsedThisTurn < maxInk) {
   let placed = false;
   for (let i=0;i<c.hand.length;i++) {
     const card = c.hand[i];
     if (card.inkable) {
       c.hand.splice(i,1);
       c.inkTotal++;
       c.inkAvail++;
       c.inkUsedThisTurn++;
       addLog("CPUã¯ã‚¤ãƒ³ã‚¯ã‚’1æšç½®ã„ãŸã€‚");
       placed = true;
       break;
     }
   }
   if (!placed) break;
 }

 let bestIndex = -1;
 let bestCost  = -1;
 c.hand.forEach((card, idx) => {
   if (card.type !== "character") return;
   if (card.cost <= c.inkAvail && card.cost > bestCost) {
     bestCost = card.cost;
     bestIndex = idx;
   }
 });
 if (bestIndex >= 0) {
   const card = c.hand[bestIndex];
   c.inkAvail -= card.cost;
   card.summonTurn = battle.turnCount;
   card.rest = false;
   c.hand.splice(bestIndex,1);
   c.field.push(card);
   addLog(`CPUã¯ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);

   if (card.effect === "destroyOnSummon") {
     if (p.field.length > 0) {
       let tIndex = 0;
       for (let i=1;i<p.field.length;i++) {
         if (p.field[i].atk > p.field[tIndex].atk) tIndex = i;
       }
       const target = p.field[tIndex];
       p.field.splice(tIndex,1);
       onCardDestroyed(p, target);
       addLog(`CPUã®ã€Œãƒã‚¸ãƒ§ãƒ‰ãƒ©ã€ã®åŠ¹æœã§ã€Œ${target.name}ã€ãŒé€€å ´ã—ãŸã€‚`);
     }
   } else if (card.effect === "toInkOnSummon") {
     if (p.field.length > 0) {
       let tIndex = 0;
       for (let i=1;i<p.field.length;i++) {
         if (p.field[i].atk > p.field[tIndex].atk) tIndex = i;
       }
       sendCharacterToInk(p, tIndex);
     }
   } else if (card.effect === "pretzelHealDraw") {
     doPretzelEffect(c);
   } else if (card.effect === "arienaiSearchSong") {
     doArienaiEffect(c);
   } else if (card.effect === "giyuBounce") {
     doGiyuEffect(c);
   } else if (card.effect === "majoDraw1") {
     doMajoEffect(c);
   }
 }

 cpuActionPhase();
 startPlayerTurn(false);
}

/* ========== CPUã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚·ãƒ¼ã‚¯ or ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼‰ ========== */
function cpuActionPhase() {
 const p = battle.player;
 const c = battle.cpu;

 updateLinLore();

 for (let i=0; i<c.field.length; i++) {
   const attacker = c.field[i];
   if (attacker.rest || attacker.frozen) continue;
   if (attacker.summonTurn === battle.turnCount) continue;

   let targets = p.field.filter(t => t.rest);
   if (!attacker.evade) {
     const evadeTargets = targets.filter(t => t.evade);
     if (evadeTargets.length) targets = evadeTargets;
   }
   const hasTargets = targets.length > 0;
   const canSeek = attacker.lore > 0;

   const attackerPower = getAttackPower(attacker, true);

   if (cpuStrength === "strong") {
     let chosenTarget = null;

     if (hasTargets) {
       let killable = targets.filter(t => t.hp <= attackerPower);
       if (killable.length) {
         killable.sort((a,b)=>a.hp-b.hp || (b.lore - a.lore));
         chosenTarget = killable[0];
       } else {
         let safe = targets.filter(t => attacker.hp > getAttackPower(t, false));
         if (safe.length) {
           safe.sort((a,b)=>b.lore - a.lore);
           chosenTarget = safe[0];
         } else {
           targets.sort((a,b)=>b.lore - a.lore);
           chosenTarget = targets[0];
         }
       }
     }

     if (chosenTarget) {
       const cpuIndex = p.field.indexOf(chosenTarget);
       if (cpuIndex >= 0) {
         const targetPower = getAttackPower(chosenTarget, false);
         chosenTarget.hp -= attackerPower;
         attacker.hp     -= targetPower;
         attacker.rest = true;

         addLog(`CPUã®ã€Œ${attacker.name}ã€ãŒã€Œ${chosenTarget.name}ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`);

         if (chosenTarget.hp <= 0) {
           p.field.splice(cpuIndex,1);
           onCardDestroyed(p, chosenTarget);
           addLog(`ã€Œ${chosenTarget.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
         }
         if (attacker.hp <= 0) {
           c.field.splice(i,1);
           onCardDestroyed(c, attacker);
           addLog(`CPUã®ã€Œ${attacker.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
           i--;
         }
         continue;
       }
     }

     if (canSeek) {
       c.lore += attacker.lore;
       attacker.rest = true;
       addLog(`CPUã®ã€Œ${attacker.name}ã€ãŒã‚·ãƒ¼ã‚¯ã—ã¦ãƒ­ã‚¢ã‚’${attacker.lore}å¾—ãŸã€‚`);
     }
   } else {
     if (hasTargets) {
       const r = Math.random();
       if (r < 0.7) {
         const target = targets[Math.floor(Math.random()*targets.length)];
         const cpuIndex = p.field.indexOf(target);
         if (cpuIndex >= 0) {
           const targetPower = getAttackPower(target, false);
           target.hp   -= attackerPower;
           attacker.hp -= targetPower;
           attacker.rest = true;
           addLog(`CPUã®ã€Œ${attacker.name}ã€ãŒã€Œ${target.name}ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`);
           if (target.hp <= 0) {
             p.field.splice(cpuIndex,1);
             onCardDestroyed(p, target);
             addLog(`ã€Œ${target.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
           }
           if (attacker.hp <= 0) {
             c.field.splice(i,1);
             onCardDestroyed(c, attacker);
             addLog(`CPUã®ã€Œ${attacker.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
             i--;
           }
           continue;
         }
       } else if (canSeek) {
         c.lore += attacker.lore;
         attacker.rest = true;
         addLog(`CPUã®ã€Œ${attacker.name}ã€ãŒã‚·ãƒ¼ã‚¯ã—ã¦ãƒ­ã‚¢ã‚’${attacker.lore}å¾—ãŸã€‚`);
       }
     } else if (canSeek) {
       c.lore += attacker.lore;
       attacker.rest = true;
       addLog(`CPUã®ã€Œ${attacker.name}ã€ãŒã‚·ãƒ¼ã‚¯ã—ã¦ãƒ­ã‚¢ã‚’${attacker.lore}å¾—ãŸã€‚`);
     }
   }
 }

 updateBattleView();
}

/* ========== æ–°ã‚«ãƒ¼ãƒ‰ç”¨ è¿½åŠ åŠ¹æœå‡¦ç† ========== */

// èƒŒç­‹ãŒãƒ’ãƒ¤ãƒªï¼šç›¸æ‰‹ã¯æ‰‹æœ­ã‹ã‚‰1æšæ¨ã¦ã‚‹ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰
function doHiyariEffect(owner) {
 if (!battle) return;
 const target = (owner === battle.player) ? battle.cpu : battle.player;
 if (!target.hand.length) {
   addLog("ã€ŒèƒŒç­‹ãŒãƒ’ãƒ¤ãƒªã€ã®åŠ¹æœï¼šç›¸æ‰‹ã®æ‰‹æœ­ãŒãªã„ãŸã‚ä¸ç™ºã€‚");
   return;
 }
 const idx = Math.floor(Math.random()*target.hand.length);
 const discarded = target.hand.splice(idx,1)[0];
 addLog(`ã€ŒèƒŒç­‹ãŒãƒ’ãƒ¤ãƒªã€ã®åŠ¹æœã§ç›¸æ‰‹ã¯ã€Œ${discarded.name}ã€ã‚’æ¨ã¦ãŸã€‚`);
}

// ãƒ†ã‚£ãƒ©ãƒŸã‚¹ã®ãŸãã‚‰ã¿ï¼š3ãƒ‰ãƒ­ãƒ¼
function doTiramisuEffect(owner) {
 if (!battle) return;
 let drawn = 0;
 for (let i=0;i<3;i++) {
   if (drawOne(owner)) drawn++;
 }
 addLog(`ã€Œãƒ†ã‚£ãƒ©ãƒŸã‚¹ã®ãŸãã‚‰ã¿ã€ã®åŠ¹æœã§${drawn}æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
}

// ãƒã‚¸ãƒ§ï¼šå¬å–šæ™‚1ãƒ‰ãƒ­ãƒ¼
function doMajoEffect(owner) {
 if (!battle) return;
 if (drawOne(owner)) {
   addLog(`ã€Œãƒã‚¸ãƒ§ã€ã®åŠ¹æœã§1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
 } else {
   addLog("ã€Œãƒã‚¸ãƒ§ã€ã®åŠ¹æœï¼šå±±æœ­ãŒãªããƒ‰ãƒ­ãƒ¼ã§ããªã‹ã£ãŸã€‚");
 }
}

// AHNWï¼šãŠäº’ã„ã®æ‰‹æœ­ã‚’æ¨ã¦ã¦7ãƒ‰ãƒ­ãƒ¼
function doAhnwEffect() {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;

 const pCount = p.hand.length;
 const cCount = c.hand.length;
 p.hand = [];
 c.hand = [];
 addLog(`ã€ŒAHNWã€ã®åŠ¹æœã§ãŠäº’ã„ã®æ‰‹æœ­ã‚’ã™ã¹ã¦æ¨ã¦ãŸã€‚ï¼ˆè‡ªåˆ†${pCount}æšï¼ç›¸æ‰‹${cCount}æšï¼‰`);

 for (let i=0;i<7;i++) {
   drawOne(p);
   drawOne(c);
 }
 addLog("ã€ŒAHNWã€ã®åŠ¹æœã§ãŠäº’ã„7æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚");
}

// ã‚¸ãƒ¼ãƒ¦ãƒ¼ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’ç›¸æ‰‹ã®æ‰‹æœ­ã«æˆ»ã™
function doGiyuEffect(owner) {
 if (!battle) return;
 const opponent = (owner === battle.player) ? battle.cpu : battle.player;

 if (opponent.field.length === 0) {
   addLog("ã€Œã‚¸ãƒ¼ãƒ¦ãƒ¼ã€ã®åŠ¹æœï¼šæˆ»ã™ç›¸æ‰‹ã‚­ãƒ£ãƒ©ãŒã„ãªã„ã€‚");
   return;
 }

 // CPUå´ã®ã‚¸ãƒ¼ãƒ¦ãƒ¼ã¯è‡ªå‹•ã§ä¸€ç•ªã‚³ã‚¹ãƒˆï¼ˆâ†’æ”»æ’ƒåŠ›ï¼‰ãŒé«˜ã„ã‚­ãƒ£ãƒ©ã‚’æˆ»ã™
 if (owner === battle.cpu) {
   let idx = 0;
   for (let i=1;i<opponent.field.length;i++) {
     const a = opponent.field[i];
     const b = opponent.field[idx];
     if (a.cost > b.cost || (a.cost === b.cost && a.atk > b.atk)) {
       idx = i;
     }
   }
   const target = opponent.field.splice(idx,1)[0];
   opponent.hand.push(target);
   addLog(`CPUã®ã€Œã‚¸ãƒ¼ãƒ¦ãƒ¼ã€ã®åŠ¹æœã§ã€Œ${target.name}ã€ãŒæ‰‹æœ­ã«æˆ»ã•ã‚ŒãŸã€‚`);
   updateBattleView();
   return;
 }

 // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ï¼šãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§é¸æŠ
 giyuOwnerSide = (owner === battle.player) ? "player" : "cpu";

 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 let html = `<div style="font-weight:bold; margin-bottom:6px;">ã€Œã‚¸ãƒ¼ãƒ¦ãƒ¼ã€ã®åŠ¹æœï¼šæˆ»ã™ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’1ä½“é¸ã‚“ã§ãã ã•ã„</div>`;
 opponent.field.forEach((card, idx) => {
   html += `<button class="btn small" style="width:100%; margin-bottom:4px;"
             onclick="giyuBounceChosen(${idx})">${card.name}</button>`;
 });
 html += `<button class="btn small" style="width:100%; margin-top:4px;"
           onclick="giyuCancel()">æˆ»ã•ãªã„ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰</button>`;

 content.innerHTML = html;
 overlay.style.display = "block";
}

function giyuBounceChosen(index) {
 if (!battle) return;
 const owner = (giyuOwnerSide === "player") ? battle.player : battle.cpu;
 const opponent = (owner === battle.player) ? battle.cpu : battle.player;
 if (!opponent.field[index]) return;
 const target = opponent.field.splice(index,1)[0];
 opponent.hand.push(target);
 addLog(`ã€Œã‚¸ãƒ¼ãƒ¦ãƒ¼ã€ã®åŠ¹æœã§ã€Œ${target.name}ã€ã‚’ç›¸æ‰‹ã®æ‰‹æœ­ã«æˆ»ã—ãŸã€‚`);
 giyuOwnerSide = null;
 closeCardDetail();
 updateBattleView();
}

function giyuCancel() {
 addLog("ã€Œã‚¸ãƒ¼ãƒ¦ãƒ¼ã€ã®åŠ¹æœã‚’ä½¿ç”¨ã—ãªã‹ã£ãŸã€‚");
 giyuOwnerSide = null;
 closeCardDetail();
 updateBattleView();
}

// ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼ï¼šå¥½ããªã‚­ãƒ£ãƒ©1ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—é¸æŠï¼‰
function startSlashSelect(ownerSide) {
 if (!battle) return;
 const overlay = document.getElementById("cardDetailOverlay");
 const content = document.getElementById("cardDetailContent");
 if (!overlay || !content) return;

 let html = `<div style="font-weight:bold; margin-bottom:6px;">ã€Œã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼ã€ã®å¯¾è±¡ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆ3ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰</div>`;

 if (battle.player.field.length) {
   html += `<div style="margin-bottom:4px; font-size:12px;">è‡ªåˆ†ã®ã‚­ãƒ£ãƒ©</div>`;
   battle.player.field.forEach((card, idx) => {
     html += `<button class="btn small" style="width:100%; margin-bottom:2px;"
               onclick="slashChosen('player',${idx})">${card.name}</button>`;
   });
 }
 if (battle.cpu.field.length) {
   html += `<div style="margin:6px 0 4px; font-size:12px;">ç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©</div>`;
   battle.cpu.field.forEach((card, idx) => {
     html += `<button class="btn small" style="width:100%; margin-bottom:2px;"
               onclick="slashChosen('cpu',${idx})">${card.name}</button>`;
   });
 }

 html += `<button class="btn small" style="width:100%; margin-top:4px;"
           onclick="closeCardDetail()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>`;

 content.innerHTML = html;
 overlay.style.display = "block";
}

function slashChosen(side, index) {
 if (!battle) return;
 const owner = (side === "player") ? battle.player : battle.cpu;
 const card = owner.field[index];
 if (!card) return;

 card.hp -= 3;
 addLog(`ã€Œã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼ã€ã®åŠ¹æœã§ã€Œ${card.name}ã€ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);

 if (card.hp <= 0) {
   owner.field.splice(index,1);
   onCardDestroyed(owner, card);
   addLog(`ã€Œ${card.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
 }

 closeCardDetail();
 updateBattleView();
}

// å‰£ã§åˆºã›ï¼šç›¸æ‰‹ã®å„ã‚­ãƒ£ãƒ©ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸
function doStabAllEffect(owner) {
 if (!battle) return;
 const opponent = (owner === battle.player) ? battle.cpu : battle.player;

 if (!opponent.field.length) {
   addLog("ã€Œå‰£ã§åˆºã›ã€ã®åŠ¹æœï¼šç›¸æ‰‹ã®å ´ã«ã‚­ãƒ£ãƒ©ãŒã„ãªã„ã€‚");
   return;
 }

 for (let i = opponent.field.length - 1; i >= 0; i--) {
   const card = opponent.field[i];
   card.hp -= 2;
   addLog(`ã€Œå‰£ã§åˆºã›ã€ã®åŠ¹æœã§ã€Œ${card.name}ã€ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
   if (card.hp <= 0) {
     opponent.field.splice(i,1);
     onCardDestroyed(opponent, card);
     addLog(`ã€Œ${card.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
   }
 }
}

/* ========== å‹æ•—åˆ¤å®š ========== */
function checkWin() {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;
 if (p.lore >= 20) {
   alert("å‹åˆ©ï¼ãƒ­ã‚¢20é”æˆï¼");
   battle = null;
   showScreen("menu");
 } else if (c.lore >= 20) {
   alert("æ•—åŒ—â€¦ CPUãŒãƒ­ã‚¢20ã‚’é”æˆ");
   battle = null;
   showScreen("menu");
 }
}

/* ========== ãƒ­ã‚° ========== */
function clearLog() {
 const el = document.getElementById("log");
 if (el) el.innerHTML = "";
}
function addLog(text) {
 const el = document.getElementById("log");
 if (!el) return;
 const div = document.createElement("div");
 div.textContent = text;
 el.appendChild(div);
 el.scrollTop = el.scrollHeight;
}

/* ========== ãƒãƒˆãƒ«é–‹å§‹ / çµ‚äº† ========== */
function startBattle() {
 // CPUãƒ‡ãƒƒã‚­ç”¨ã®è‰²ãƒã‚§ãƒƒã‚¯ï¼ˆ2è‰²å¿…é ˆï¼‰
 if (cpuColors.length !== 2) {
   alert("CPUãƒ‡ãƒƒã‚­ã«ä½¿ã†è‰²ã‚’2ã¤é¸ã‚“ã§ãã ã•ã„ã€‚");
   return;
 }

 let playerDeckCards = [];

 if (playerDeckMode.startsWith("deck")) {
   const idx = parseInt(playerDeckMode.slice(4), 10) - 1;
   const deck = savedDecks[idx] || [];
   deck.forEach(id => {
     const base = cards.find(c => c.id === id);
     if (base) playerDeckCards.push(makeCardInstance(base));
   });
 }

 if (playerDeckCards.length === 0) {
   // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèµ¤ãƒ‡ãƒƒã‚­ï¼ˆæ—¢å­˜ä»•æ§˜ã®ã¾ã¾ï¼‰
   for (let i=0;i<52;i++) playerDeckCards.push(makeCardInstance(cards[0]));
   playerDeckCards.push(makeCardInstance(cards[6]));
   playerDeckCards.push(makeCardInstance(cards[6]));
   playerDeckCards.push(makeCardInstance(cards[7]));
   playerDeckCards.push(makeCardInstance(cards[8]));
   playerDeckCards.push(makeCardInstance(cards[11]));
 }

 // ==== CPUãƒ‡ãƒƒã‚­ï¼šé¸ã°ã‚ŒãŸ2è‰²ã‹ã‚‰å„30æšãšã¤ ====
 let cpuDeckCards = [];
 cpuColors.forEach(color => {
   // ãã®è‰²ã®Nãƒ¬ã‚¢ã‚’å„ªå…ˆï¼ˆãªã‘ã‚Œã°ãã®è‰²ã®å…¨ã‚«ãƒ¼ãƒ‰ï¼‰
   let pool = cards.filter(c => c.color === color && c.rarity === "N");
   if (!pool.length) {
     pool = cards.filter(c => c.color === color);
   }
   if (!pool.length) {
     // ä¿é™ºï¼šè‰²ãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°å…¨Nã‹ã‚‰
     pool = cards.filter(c => c.rarity === "N");
   }

   for (let i=0;i<30;i++) {
     const base = pool[i % pool.length];
     cpuDeckCards.push(makeCardInstance(base));
   }
 });

 shuffle(playerDeckCards);
 shuffle(cpuDeckCards);

 battle = {
   turn: "player",
   turnCount: 1,
   player: {
     deck: playerDeckCards,
     hand: [],
     field: [],
     lore: 0,
     inkTotal: 0,
     inkAvail: 0,
     inkUsedThisTurn: 0
   },
   cpu: {
     deck: cpuDeckCards,
     hand: [],
     field: [],
     lore: 0,
     inkTotal: 0,
     inkAvail: 0,
     inkUsedThisTurn: 0
   }
 };

 for (let i=0;i<7;i++) {
   if (battle.player.deck.length) battle.player.hand.push(battle.player.deck.pop());
   if (battle.cpu.deck.length)    battle.cpu.hand.push(battle.cpu.deck.pop());
 }

 clearLog();
 addLog("ãƒãƒˆãƒ«é–‹å§‹ï¼");
 showScreen("battle");

 startPlayerTurn(true);
}

function endBattleToMenu() {
 if (confirm("ãƒãƒˆãƒ«ã‚’çµ‚äº†ã—ã¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ")) {
   battle = null;
   showScreen("menu");
 }
}

/* ========== åˆæœŸåŒ– ========== */
window.addEventListener("load", () => {
 loadData();
 showScreen("menu");
});
</script>

</body>
</html>
