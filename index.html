<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Dream-seeker TCG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Firebase SDKï¼ˆãƒ«ãƒ¼ãƒ æˆ¦ç”¨ï¼‰ -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #181818;
      color: #f5f5f5;
    }

    h1, h2 { text-align: center; margin: 12px 0; }

    .screen {
      display: none;
      padding: 10px;
      max-width: 520px;
      margin: 0 auto;
    }
    .screen.active { display: block; }

    .btn {
      width: 100%;
      padding: 10px;
      margin: 6px 0;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      background: #444;
      color: #f5f5f5;
    }
    .btn.primary { background: #2ecc71; color: #000; }
    .btn.danger  { background: #e74c3c; }
    .btn.small {
      width: auto;
      padding: 4px 8px;
      font-size: 12px;
      margin: 2px 4px 0 0;
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .card-box {
      border: 1px solid #555;
      border-radius: 8px;
      padding: 6px;
      margin: 4px 0;
      font-size: 12px;
      background: #202020;
      cursor: pointer;
    }
    .card-name  { font-weight: bold; }
    .card-stats { font-size: 11px; opacity: 0.9; margin-top: 2px; }

    .red    { border-color: #e74c3c; }
    .purple { border-color: #9b59b6; }
    .blue   { border-color: #3498db; }
    .yellow { border-color: #f1c40f; }
    .white  { border-color: #ecf0f1; }
    .green  { border-color: #2ecc71; }

    .log {
      background: #111;
      border-radius: 8px;
      padding: 6px;
      font-size: 11px;
      height: 120px;
      overflow-y: auto;
      border: 1px solid #333;
      margin-top: 6px;
    }

    .section-title {
      font-size: 13px;
      margin: 10px 0 4px;
      font-weight: bold;
    }

    .stone-bar {
      font-size: 13px;
      padding: 4px 6px;
      border-radius: 8px;
      background: #222;
      display: inline-block;
      margin-bottom: 8px;
    }

    .row { display: flex; gap: 6px; }
    .row > .btn { flex: 1; }

    .toggle-selected {
      background: #f39c12 !important;
      color: #000 !important;
    }

    /* ===== ãƒãƒˆãƒ«ç”»é¢ç”¨ ===== */

    .battle-screen {
      padding: 16px;
    }

    .enemy-title {
      text-align: center;
      font-size: 20px;
      margin-bottom: 8px;
    }

    .enemy-status {
      display: flex;
      justify-content: space-around;
      margin-bottom: 8px;
      font-size: 13px;
    }

    #cpuField,
    #playerField,
    #playerHand {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      overflow-x: auto;
      padding: 8px 0;
      min-height: 160px;
      -webkit-overflow-scrolling: touch;
    }

    .divider {
      border-top: 3px dashed #ffffff;
      margin: 12px 0;
    }

    .bottom-ui {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .status-box,
    .effect-box {
      width: 48%;
      min-height: 120px;
      border: 3px solid #ffffff;
      box-sizing: border-box;
      padding: 8px;
      font-size: 14px;
    }

    .status-box-title,
    .effect-box-title {
      font-weight: bold;
      margin-bottom: 4px;
    }

    .turn-info {
      margin-top: 4px;
      font-weight: bold;
    }

    .status-buttons {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .status-buttons button {
      font-size: 12px;
      padding: 4px 8px;
    }

    /* ã‚«ãƒ¼ãƒ‰è¦‹ãŸç›®ï¼ˆæ–°ã‚«ãƒ¼ãƒ‰å‹ï¼‰ */
    .card {
      flex: 0 0 auto;
      width: 96px;
      height: 160px;
      border-radius: 10px;
      border: 3px solid #555;
      background: #b30000;
      color: #ffffff;
      font-size: 10px;
      box-sizing: border-box;
      padding: 4px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
      position: relative;
      overflow: hidden;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 8px rgba(255,255,255,0.3);
    }

    .card.rest {
      opacity: 0.6;
      transform: rotate(8deg);
    }

    .card.red {
      border-color: #e74c3c;
      background: #8b1a1a;
    }
    .card.purple {
      border-color: #9b59b6;
      background: #4b2b63;
    }
    .card.blue {
      border-color: #3498db;
      background: #1f3f5f;
    }
    .card.yellow {
      border-color: #f1c40f;
      background: #866d07;
    }
    .card.white {
      border-color: #ecf0f1;
      background: #aaaaaa;
      color: #000;
    }
    .card.green {
      border-color: #2ecc71;
      background: #145437;
    }

    /* ç™½ã‚«ãƒ¼ãƒ‰ã ã‘ãƒ˜ãƒƒãƒ€ãƒ¼ï¼†ãƒ•ãƒƒã‚¿ãƒ¼ã‚’ç™½åœ°ï¼‹é»’æ–‡å­—ã«ã—ã¦åå‰ã¨ã‚³ã‚¹ãƒˆã‚’è¦‹ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹ */
    .card.white .card-header,
    .card.white .card-footer {
      background: #ffffff;
      color: #000000;
    }
    .card.white .card-cost {
      color: #000000;
    }

    /* ===== Eãƒ¬ã‚¢ï¼ˆã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒ†ãƒƒãƒ‰ï¼‰è±ªè¯æ é¢¨ãƒ‡ã‚¶ã‚¤ãƒ³ ===== */
    .card.enchanted {
      box-shadow:
        0 0 10px rgba(255,255,255,0.8),
        0 0 18px rgba(255,215,0,0.7);
      border-width: 3px;
      border-color: #ffd700;
    }
    .card.enchanted::before {
      content: "";
      position: absolute;
      inset: 0;
      background: conic-gradient(
        from 45deg,
        rgba(255,255,255,0.15),
        rgba(255,215,0,0.25),
        rgba(255,255,255,0.0),
        rgba(0,255,255,0.15),
        rgba(255,255,255,0.15)
      );
      mix-blend-mode: screen;
      pointer-events: none;
    }
    .card.enchanted.red {
      box-shadow:
        0 0 10px rgba(255,120,120,0.9),
        0 0 20px rgba(255,80,80,0.7);
    }
    .card.enchanted.purple {
      box-shadow:
        0 0 10px rgba(200,120,255,0.9),
        0 0 20px rgba(160,80,240,0.7);
    }
    .card.enchanted.blue {
      box-shadow:
        0 0 10px rgba(120,180,255,0.9),
        0 0 20px rgba(80,140,255,0.7);
    }
    .card.enchanted.yellow {
      box-shadow:
        0 0 10px rgba(255,230,120,0.9),
        0 0 20px rgba(255,210,80,0.7);
    }
    .card.enchanted.white {
      box-shadow:
        0 0 10px rgba(240,240,255,0.9),
        0 0 20px rgba(210,230,255,0.7);
    }
    .card.enchanted.green {
      box-shadow:
        0 0 10px rgba(140,255,180,0.9),
        0 0 20px rgba(80,220,140,0.7);
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #000000;
      border-radius: 4px;
      padding: 2px 3px;
      margin-bottom: 3px;
      font-weight: bold;
      position: relative;
      z-index: 1;
    }

    .card-cost {
      min-width: 16px;
      text-align: center;
    }

    .card-name-header {
      flex: 1;
      text-align: center;
      font-size: 9px;
    }

    .card-inkable {
      min-width: 16px;
      text-align: center;
    }

    .card-illustration {
      flex: 1;
      background: #ffffff;
      border-radius: 4px;
      margin-bottom: 3px;
      overflow: hidden;
      position: relative;
      z-index: 1;
    }

    .card-illustration img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .card-stats-row {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      padding: 0 2px;
      margin-bottom: 3px;
      position: relative;
      z-index: 1;
    }

    .card-footer {
      background: #000000;
      border-radius: 4px;
      padding: 2px 3px;
      font-size: 9px;
      position: relative;
      z-index: 1;
    }

    .card-footer-buttons {
      display: flex;
      gap: 2px;
      margin-top: 2px;
      position: relative;
      z-index: 1;
    }

    /* ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
    #cardDetailOverlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
    }
    #cardDetailInner {
      background: #222;
      max-width: 320px;
      margin: 40px auto;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid #ffffff;
      font-size: 13px;
    }
  </style>
</head>
<body>

<!-- ===== ãƒ›ãƒ¼ãƒ  ===== -->
<div id="menuScreen" class="screen active">
  <h1>Dream-seeker TCG</h1>
  <div class="stone-bar">
    ğŸ’ ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="stoneCount">0</span>
  </div>
  <button class="btn primary" onclick="openCpuConfig()">ãƒãƒˆãƒ«</button>
  <button class="btn" onclick="openRoomScreen()">ãƒ«ãƒ¼ãƒ æˆ¦ï¼ˆÎ²ï¼‰</button>
  <button class="btn" onclick="showShop()">ã‚·ãƒ§ãƒƒãƒ—</button>
  <button class="btn" onclick="showPack()">ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</button>
  <button class="btn" onclick="openDeckBuilder()">ãƒ‡ãƒƒã‚­ç·¨é›†</button>
  <button class="btn" onclick="openCollection()">ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</button>
</div>

<!-- ===== CPUè¨­å®š ===== -->
<div id="cpuScreen" class="screen">
  <h2>CPUè¨­å®š</h2>

  <div class="section-title">CPUã®å¼·ã•</div>
  <div class="row">
    <button id="btnCpuNormal" class="btn" onclick="setCpuStrength('normal')">æ™®é€š</button>
    <button id="btnCpuStrong" class="btn" onclick="setCpuStrength('strong')">å¼·ã„ï¼ˆè¶…CPUï¼‰</button>
  </div>

  <div class="section-title">CPUãƒ‡ãƒƒã‚­è‰²ï¼ˆ2è‰²é¸ã‚“ã§ã­ï¼‰</div>
  <div class="row">
    <button id="cpuRed"    class="btn" onclick="setCpuColor('red')">èµ¤</button>
    <button id="cpuPurple" class="btn" onclick="setCpuColor('purple')">ç´«</button>
  </div>
  <div class="row">
    <button id="cpuBlue"   class="btn" onclick="setCpuColor('blue')">é’</button>
    <button id="cpuYellow" class="btn" onclick="setCpuColor('yellow')">é»„</button>
  </div>
  <div class="row">
    <button id="cpuWhite"  class="btn" onclick="setCpuColor('white')">ç™½</button>
    <button id="cpuGreen"  class="btn" onclick="setCpuColor('green')">ç·‘</button>
  </div>

  <div class="section-title">è‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­</div>
  <button id="btnPlayerDefault" class="btn" onclick="selectPlayerDeck('default')">
    ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèµ¤ãƒ‡ãƒƒã‚­
  </button>
  <button id="btnDeck1" class="btn" onclick="selectPlayerDeck('deck1')">
    ãƒ‡ãƒƒã‚­1ï¼ˆæœªä¿å­˜ï¼‰
  </button>
  <button id="btnDeck2" class="btn" onclick="selectPlayerDeck('deck2')">
    ãƒ‡ãƒƒã‚­2ï¼ˆæœªä¿å­˜ï¼‰
  </button>
  <button id="btnDeck3" class="btn" onclick="selectPlayerDeck('deck3')">
    ãƒ‡ãƒƒã‚­3ï¼ˆæœªä¿å­˜ï¼‰
  </button>

  <button class="btn primary" onclick="startBattle()">ãƒãƒˆãƒ«é–‹å§‹</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒãƒˆãƒ« ===== -->
<div id="battleScreen" class="screen">
  <div class="battle-screen">

    <!-- ç›¸æ‰‹ã‚¨ãƒªã‚¢ -->
    <div class="enemy-area">
      <div class="enemy-title">ç›¸æ‰‹</div>
      <div class="enemy-status">
        <span>æ‰‹æœ­ï¼š<span id="cpuHandCount">0</span>æš</span>
        <span>ãƒ­ã‚¢ï¼š<span id="cLore">0</span>å€‹</span>
        <span>æ®‹ã‚Šå±±æœ­ï¼š<span id="cDeck">0</span>æš</span>
      </div>
      <div id="cpuField"></div>
    </div>

    <div class="divider"></div>

    <!-- è‡ªåˆ†ã‚¨ãƒªã‚¢ -->
    <div class="player-area">

      <div id="playerField"></div>

      <div id="playerHand"></div>

      <div class="bottom-ui">
        <div class="status-box">
          <div class="status-box-title">è‡ªåˆ†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
          <div>ãƒ­ã‚¢ï¼š<span id="playerLore">0</span></div>
          <div>ã‚¤ãƒ³ã‚¯ï¼š<span id="playerInkCurrent">0</span> / <span id="playerInkMax">0</span></div>
          <div>æ®‹ã‚Šå±±æœ­ï¼š<span id="playerDeck">0</span></div>
          <div id="turnInfo" class="turn-info">è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³</div>

          <div class="status-buttons">
            <!-- ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«è‡ªå‹•ãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã®ã§ãƒ‰ãƒ­ãƒ¼ãƒœã‚¿ãƒ³ã¯å‰Šé™¤ -->
            <button class="btn small" onclick="endTurn()">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
            <button class="btn small danger" onclick="endBattleToMenu()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
          </div>
        </div>

        <div class="effect-box">
          <div class="effect-box-title">è¡Œå‹• / æƒ…å ±</div>
          <div id="actionArea">ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚</div>
        </div>
      </div>

      <div class="section-title">ãƒ­ã‚°</div>
      <div id="log" class="log"></div>

    </div>
  </div>
</div>

<!-- ===== ã‚·ãƒ§ãƒƒãƒ— ===== -->
<div id="shopScreen" class="screen">
  <h2>ã‚·ãƒ§ãƒƒãƒ—</h2>
  <p>â€» ä»Šã¯ãƒ†ã‚¹ãƒˆç”¨ã€‚çŸ³ã‚’å¢—ã‚„ã—æ”¾é¡Œã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚</p>
  <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="shopStoneCount">0</span></p>
  <button class="btn" onclick="debugAddStones()">çŸ³ã‚’100å€‹å¢—ã‚„ã™ï¼ˆãƒ†ã‚¹ãƒˆï¼‰</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‘ãƒƒã‚¯ ===== -->
<div id="packScreen" class="screen">
  <h2>ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</h2>
  <p>ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³5å€‹ã§1ãƒ‘ãƒƒã‚¯ï¼ˆ5æšå…¥ã‚Šï¼‰</p>
  <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="packStoneCount">0</span></p>
  <button class="btn primary" onclick="openPack()">ãƒ‘ãƒƒã‚¯ã‚’é–‹ã‘ã‚‹</button>
  <div class="section-title">ä»Šå›ã®çµæœ</div>
  <div id="packResult"></div>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‡ãƒƒã‚­ç·¨é›† ===== -->
<div id="deckScreen" class="screen">
  <h2>ãƒ‡ãƒƒã‚­ç·¨é›†</h2>
  <p style="font-size:12px; opacity:0.8;">
    æ‰€æŒã‚«ãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒƒã‚­ã«å…¥ã‚Œã‚‹æšæ•°ã‚’æ±ºã‚ã¦ãã ã•ã„ã€‚ä¿å­˜ã—ãŸãƒ‡ãƒƒã‚­ã¯ãƒãƒˆãƒ«ã§ã€Œè‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­ã€ã§é¸ã¹ã¾ã™ã€‚<br>
    â€» ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ï¼åŒåã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ï¼ˆåŸºæœ¬6ç¨®ã¯ä½•æšã§ã‚‚å¯ï¼‰ï¼æœ€çµ‚çš„ã«60æšä»¥ä¸Š
  </p>

  <div style="margin-bottom:8px;">
    <button class="btn small" onclick="switchDeck(0)">ãƒ‡ãƒƒã‚­1</button>
    <button class="btn small" onclick="switchDeck(1)">ãƒ‡ãƒƒã‚­2</button>
    <button class="btn small" onclick="switchDeck(2)">ãƒ‡ãƒƒã‚­3</button>
    <div style="font-size:12px; opacity:0.9; margin-top:4px;">
      ç¾åœ¨ç·¨é›†ã—ã¦ã„ã‚‹ã®ã¯ï¼šãƒ‡ãƒƒã‚­<span id="currentDeckLabel">1</span>
    </div>
  </div>

  <div id="deckCardList"></div>
  <button class="btn primary" onclick="saveDeck()">ã“ã®å†…å®¹ã§ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« ===== -->
<div id="collectionScreen" class="screen">
  <h2>ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</h2>
  <div id="collectionList"></div>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ«ãƒ¼ãƒ æˆ¦ãƒ­ãƒ“ãƒ¼ ===== -->
<div id="roomScreen" class="screen">
  <h2>ãƒ«ãƒ¼ãƒ æˆ¦ï¼ˆÎ²ï¼‰</h2>
  <p style="font-size:12px;opacity:0.8;">
    Firebaseã‚’ä½¿ã£ãŸç°¡æ˜“ãƒ«ãƒ¼ãƒ ãƒ­ãƒ“ãƒ¼ã§ã™ã€‚<br>
    ä»Šã¯ã€Œãƒ«ãƒ¼ãƒ IDå…±æœ‰ï¼‹æº–å‚™OKã€ã¾ã§ã®æ©Ÿèƒ½ã§ã€<br>
    ãƒãƒˆãƒ«ã®ç›¤é¢åŒæœŸã¯ã“ã‚Œã‹ã‚‰æ‹¡å¼µã—ã¦ã„ã‘ã‚‹ã‚ˆã†ã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚<br>
    Dream-seekeræœ¬ä½“ã®ãƒ«ãƒ¼ãƒ«ã¯ä¸€åˆ‡å¤‰æ›´ã—ã¦ã„ã¾ã›ã‚“ã€‚
  </p>

  <div class="section-title">ãƒ«ãƒ¼ãƒ ä½œæˆ</div>
  <div style="font-size:13px; margin-bottom:4px;">
    ä¸‹ã®ãƒœã‚¿ãƒ³ã§4æ¡ã®ãƒ«ãƒ¼ãƒ IDã‚’ä½œæˆã—ã¦ã€å‹é”ã«æ•™ãˆã¦ãã ã•ã„ã€‚
  </div>
  <button class="btn" onclick="createRoom()">ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</button>
  <div style="margin-top:6px;">
    ã‚ãªãŸã®ãƒ«ãƒ¼ãƒ ID:
    <span id="roomIdDisplay" style="font-weight:bold;">-</span>
  </div>

  <div class="section-title">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </div>
  <input
    id="joinRoomInput"
    type="text"
    placeholder="4æ¡ã®ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›"
    style="width:100%;padding:6px;margin-bottom:4px;border-radius:6px;border:1px solid #555;background:#111;color:#fff;"
  />
  <button class="btn" onclick="joinRoom()">ã“ã®IDã§å‚åŠ </button>

  <div class="section-title">ãƒ«ãƒ¼ãƒ çŠ¶æ…‹</div>
  <div id="roomInfoText" style="font-size:13px; margin-bottom:8px;">
    ã¾ã ã©ã®ãƒ«ãƒ¼ãƒ ã«ã‚‚å…¥ã£ã¦ã„ã¾ã›ã‚“ã€‚
  </div>
  <div style="font-size:12px;opacity:0.8;margin-bottom:4px;">
    â€»ä»Šã¯ã€Œæº–å‚™OKã€ã®çŠ¶æ…‹ã ã‘ã‚’åŒæœŸã—ã¾ã™ã€‚<br>
    ä¸¡æ–¹ãŒæº–å‚™OKã«ãªã£ãŸã‚‰ã€å„è‡ªãƒãƒˆãƒ«ç”»é¢ã«é€²ã‚“ã§ãã ã•ã„ï¼ˆãƒ«ãƒ¼ãƒ«ã¯ä»Šã¾ã§ã©ãŠã‚Šã®CPUãƒãƒˆãƒ«/ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒˆãƒ«ã§ã™ï¼‰ã€‚
  </div>

  <button class="btn small" onclick="setRoomReady(true)">æº–å‚™OK</button>
  <button class="btn small" onclick="setRoomReady(false)">æº–å‚™è§£é™¤</button>
  <button class="btn small danger" onclick="leaveRoom()">ãƒ«ãƒ¼ãƒ ã‹ã‚‰æŠœã‘ã‚‹</button>

  <button class="btn danger" style="margin-top:10px;" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ï¼å„ç¨®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å…±ç”¨ ===== -->
<div id="cardDetailOverlay">
  <div id="cardDetailInner">
    <div id="cardDetailContent"></div>
    <button class="btn" onclick="closeCardDetail()">æˆ»ã‚‹ / é–‰ã˜ã‚‹</button>
  </div>
</div>

<script>
/* ========== ç‰¹æ®ŠID ========== */
const ID_RATABAA   = 14;
const ID_LIN       = 13;
const ID_TITAN     = 9;
const ID_PRETZEL   = 16;
const ID_CHAMELEON = 24;
const ID_ERRATA_PRINCE = 31;

/* Eãƒ¬ã‚¢ï¼ˆã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒ†ãƒƒãƒ‰ï¼‰ã®ãƒ¬ãƒ¼ãƒˆï¼ˆ1ã‚«ãƒ¼ãƒˆãƒ³ï¼288ãƒ‘ãƒƒã‚¯ã€1ãƒ‘ãƒƒã‚¯5æšâ†’1440æšã«1æšãã‚‰ã„ï¼‰ */
const ENCHANTED_RATE = 1 / (288 * 5);

/* ========== ç”»é¢åˆ‡ã‚Šæ›¿ãˆ ========== */
function showScreen(name) {
  const ids = [
    "menuScreen","cpuScreen","battleScreen","shopScreen",
    "packScreen","deckScreen","collectionScreen","roomScreen"
  ];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.remove("active");
  });
  const map = {
    menu: "menuScreen",
    cpu: "cpuScreen",
    battle: "battleScreen",
    shop: "shopScreen",
    pack: "packScreen",
    deck: "deckScreen",
    collection: "collectionScreen",
    room: "roomScreen"
  };
  const target = map[name];
  if (target) {
    document.getElementById(target).classList.add("active");
  }
}

/* ========== ã‚«ãƒ¼ãƒ‰å®šç¾© ========== */
const cards = [
  // åŸºæœ¬6ç¨®
  {id:0, name:"ã‚«ãƒ¼",   color:"red",    type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:1, name:"ãƒ«ãƒ‘ãƒ—", color:"purple", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:2, name:"ãƒ«ãƒ–ãƒ–", color:"blue",   type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:3, name:"ãƒ­ã‚¤ã‚¨", color:"yellow", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:4, name:"ãƒ­ãƒ¼ã‚·", color:"white",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:5, name:"ãƒ‰ãƒªãƒŸ", color:"green",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},

  // æ—¢å­˜SR/L
  {id:6, name:"çµ‚ç„‰ã®å¤§ç«",          color:"red",    type:"song",      cost:7, atk:0, hp:0, lore:0, rarity:"SR", inkable:false, effect:"boardwipe"},
  {id:7, name:"æ°·çµã®å¥³ç‹ã‚±ãƒ«ã‚µ",    color:"purple", type:"character", cost:8, atk:4, hp:6, lore:3, rarity:"L",  inkable:false, effect:"freeze2", evolveCost:6},
  {id:8, name:"ä¼èª¬ã®å‹‡è€…ã‚¤ãƒ•ãƒªãƒ¼ãƒˆ", color:"red",   type:"character", cost:8, atk:5, hp:5, lore:4, rarity:"L",  inkable:true,  evade:true},

  // ç·‘
  {id:9,  name:"ã‚¿ã‚¤ã‚¿ãƒ³",        color:"red",    type:"character", cost:5, atk:6, hp:5, lore:0, rarity:"SR",
   inkable:true, mustAttack:true, rush:true},  // â˜…çªé€²ã¤ã
  {id:10, name:"ãƒã‚¸ãƒ§ãƒ‰ãƒ©",      color:"red",    type:"character", cost:9, atk:7, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"destroyOnSummon"},
  {id:11, name:"ãã‚ãã‚ãƒ€ãƒƒã‚¯",  color:"red",    type:"character", cost:2, atk:2, hp:3, lore:1, rarity:"N",  inkable:true},

  // é’
  {id:12, name:"ã‚´ãƒ¼ã‚º",       color:"blue",   type:"character", cost:7, atk:3, hp:6, lore:2, rarity:"L",  inkable:false, effect:"toInkOnSummon"},
  {id:13, name:"ãƒªãƒ³",         color:"blue",   type:"character", cost:4, atk:2, hp:4, lore:1, rarity:"L",  inkable:true},
  {id:14, name:"ã‚‰ãŸã°ã‚",     color:"blue",   type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N",  inkable:true},
  {id:15, name:"ã‚ã‚Šã®ã¾ã¾ã§", color:"blue",   type:"song",      cost:5, atk:0, hp:0, lore:0, rarity:"SR", inkable:true,  effect:"songToInk1"},

  // é»„
  {id:16, name:"ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«",   color:"yellow", type:"character", cost:4, atk:1, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"pretzelHealDraw"},
  {id:17, name:"ãƒŸã‚¹ã‚¿ãƒ¼ãƒã‚¸",   color:"yellow", type:"character", cost:3, atk:2, hp:5, lore:1, rarity:"N",  inkable:true},
  {id:18, name:"ãƒ•ãƒ³ãƒãƒ¼",       color:"yellow", type:"character", cost:4, atk:3, hp:5, lore:1, rarity:"N",  inkable:true},
  {id:19, name:"ã‚¢ãƒªã‚¨ãƒŠã‚¤",     color:"yellow", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"SR", inkable:true,  effect:"arienaiSearchSong", songPower:5},

  /* ===== ã“ã“ã‹ã‚‰æ–°ã‚«ãƒ¼ãƒ‰ ===== */

  // èµ¤ï¼ˆæ–°ï¼‰
  {id:20, name:"ã‚¸ãƒ¼ãƒ¦ãƒ¼",     color:"green",    type:"character", cost:6, atk:3, hp:4, lore:2, rarity:"SR", inkable:false, effect:"bounceOnSummon"},
  {id:21, name:"ã‚¨ãƒ³ãƒãƒ³ã‚¹",   color:"green",    type:"character", cost:4, atk:3, hp:3, lore:3, rarity:"N",  inkable:true},
  {id:22, name:"èƒŒç­‹ãŒãƒ’ãƒ¤ãƒª", color:"green",    type:"song",      cost:2, atk:0, hp:0, lore:0, rarity:"N",  inkable:true,  effect:"discard1"},

  // ç´«ï¼ˆæ–°ï¼‰
  {id:23, name:"ã»ã†ã",               color:"purple", type:"character", cost:2, atk:2, hp:2, lore:1, rarity:"N", inkable:true},
  {id:24, name:"ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³",           color:"purple", type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N", inkable:true},
  {id:25, name:"ãƒ†ã‚£ãƒ©ãƒŸã‚¹ã®ãŸãã‚‰ã¿", color:"purple", type:"song",      cost:3, atk:0, hp:0, lore:0, rarity:"R", inkable:true, effect:"draw3"},
  {id:26, name:"ãƒã‚¸ãƒ§",               color:"purple", type:"character", cost:3, atk:2, hp:2, lore:1, rarity:"N", inkable:true, effect:"drawOnSummon1"},
  {id:27, name:"ã‚±ãƒ«ã‚µ",               color:"purple", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"N", inkable:true},

  // ç™½ï¼ˆæ–°ï¼‰
  {id:28, name:"AHNW",        color:"white", type:"song",      cost:5, atk:0, hp:0, lore:0, rarity:"SR", inkable:false, effect:"handReset7"},
  {id:29, name:"ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼", color:"white", type:"song",      cost:3, atk:0, hp:0, lore:0, rarity:"R",  inkable:true,  effect:"damage3"},
  {id:30, name:"å‰£ã§åˆºã›",    color:"white", type:"song",      cost:5, atk:0, hp:0, lore:0, rarity:"R",  inkable:false, effect:"aoe2"},
  {id:31, name:"ã‚¨ãƒ©ãƒƒã‚¿ç‹å­", color:"white", type:"character", cost:2, atk:1, hp:3, lore:1, rarity:"N", inkable:true,  effect:"frenzy2"}
];

/* ========== ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ ========== */
let stones = 0;
let collection = {};
let enchantedCollection = {};
let savedDecks = [[], [], []];
let currentDeckIndex = 0;

/* ========== ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ç³» ========== */
function loadData() {
  const s = localStorage.getItem("ds_stones");
  stones = s ? parseInt(s,10) : 0;

  const c = localStorage.getItem("ds_collection");
  collection = c ? JSON.parse(c) : {};

  const ec = localStorage.getItem("ds_collection_enchanted");
  enchantedCollection = ec ? JSON.parse(ec) : {};

  const d3 = localStorage.getItem("ds_playerDecks");
  if (d3) {
    try {
      const parsed = JSON.parse(d3);
      if (Array.isArray(parsed) && parsed.length === 3) {
        savedDecks = parsed;
      }
    } catch(e) {}
  }

  updateStoneDisplays();
  updatePlayerDeckButtons();
}

function saveStones() {
  localStorage.setItem("ds_stones", String(stones));
  updateStoneDisplays();
}
function saveCollection() {
  localStorage.setItem("ds_collection", JSON.stringify(collection));
}
function saveEnchantedCollection() {
  localStorage.setItem("ds_collection_enchanted", JSON.stringify(enchantedCollection));
}
function savePlayerDecks() {
  localStorage.setItem("ds_playerDecks", JSON.stringify(savedDecks));
}

function updateStoneDisplays() {
  const v1 = document.getElementById("stoneCount");
  const v2 = document.getElementById("shopStoneCount");
  const v3 = document.getElementById("packStoneCount");
  if (v1) v1.textContent = stones;
  if (v2) v2.textContent = stones;
  if (v3) v3.textContent = stones;
}

/* ========== Firebase åˆæœŸåŒ– & ãƒ«ãƒ¼ãƒ æˆ¦ãƒ­ã‚¸ãƒƒã‚¯ ========== */
/* â˜… è‡ªåˆ†ã®Firebaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®è¨­å®šã«æ›¸ãæ›ãˆã¦ã­ â˜… */
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_PROJECT.firebaseapp.com",
  databaseURL: "https://YOUR_PROJECT.firebaseio.com",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_PROJECT.appspot.com",
  messagingSenderId: "YOUR_SENDER_ID",
  appId: "YOUR_APP_ID"
};

let firebaseDb = null;
let currentRoomId = null;
let currentRoomRole = null;  // "host" or "guest"
let roomRef = null;
let roomListener = null;

function initFirebase() {
  try {
    if (!firebase.apps || firebase.apps.length === 0) {
      firebase.initializeApp(firebaseConfig);
    }
    firebaseDb = firebase.database();
  } catch (e) {
    console.error("FirebaseåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", e);
  }
}

function openRoomScreen() {
  showScreen("room");
  updateRoomInfoText();
}

function randomRoomId() {
  // 4æ¡ã®æ•°å­—
  return String(Math.floor(1000 + Math.random() * 9000));
}

function createRoom() {
  if (!firebaseDb) {
    alert("FirebaseãŒã¾ã è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\nfirebaseConfig ã‚’è‡ªåˆ†ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã«å¤‰æ›´ã—ã¦ã­ã€‚");
    return;
  }
  const roomId = randomRoomId();
  const ref = firebaseDb.ref("rooms/" + roomId);
  ref.set({
    createdAt: Date.now(),
    hostReady: false,
    guestReady: false
  }).then(() => {
    attachRoomListener(roomId);
    currentRoomId = roomId;
    currentRoomRole = "host";
    roomRef = ref;
    const disp = document.getElementById("roomIdDisplay");
    if (disp) disp.textContent = roomId;
    updateRoomInfoText();
  }).catch(err => {
    console.error(err);
    alert("ãƒ«ãƒ¼ãƒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
  });
}

function joinRoom() {
  if (!firebaseDb) {
    alert("FirebaseãŒã¾ã è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\nfirebaseConfig ã‚’è‡ªåˆ†ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å€¤ã«å¤‰æ›´ã—ã¦ã­ã€‚");
    return;
  }
  const input = document.getElementById("joinRoomInput");
  if (!input) return;
  const roomId = (input.value || "").trim();
  if (!roomId) {
    alert("ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
    return;
  }
  const ref = firebaseDb.ref("rooms/" + roomId);
  ref.get().then(snap => {
    if (!snap.exists()) {
      alert("ãã®ãƒ«ãƒ¼ãƒ IDã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚");
      return;
    }
    attachRoomListener(roomId);
    currentRoomId = roomId;
    currentRoomRole = "guest";
    roomRef = ref;
    const disp = document.getElementById("roomIdDisplay");
    if (disp) disp.textContent = roomId;
    updateRoomInfoText();
  }).catch(err => {
    console.error(err);
    alert("ãƒ«ãƒ¼ãƒ å‚åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
  });
}

function attachRoomListener(roomId) {
  if (!firebaseDb) return;
  // æ—¢å­˜ãƒªã‚¹ãƒŠãƒ¼è§£é™¤
  if (roomRef && roomListener) {
    roomRef.off("value", roomListener);
  }
  roomRef = firebaseDb.ref("rooms/" + roomId);
  roomListener = roomRef.on("value", snap => {
    const infoEl = document.getElementById("roomInfoText");
    if (!infoEl) return;
    const val = snap.val();
    if (!val) {
      infoEl.textContent = "ã“ã®ãƒ«ãƒ¼ãƒ ã¯å­˜åœ¨ã—ã¾ã›ã‚“ï¼ˆå‰Šé™¤ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰ã€‚";
      return;
    }
    let html = "";
    html += "ãƒ«ãƒ¼ãƒ ID: " + roomId + "<br>";
    html += "ãƒ›ã‚¹ãƒˆæº–å‚™: " + (val.hostReady ? "OK" : "æœª") + "<br>";
    html += "ã‚²ã‚¹ãƒˆæº–å‚™: " + (val.guestReady ? "OK" : "æœª") + "<br>";
    if (val.hostReady && val.guestReady) {
      html += "<br>ä¸¡è€…æº–å‚™OKï¼<br>ãã‚Œãã‚Œè‡ªåˆ†ã®ç”»é¢ã§ãƒãƒˆãƒ«ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚";
    } else {
      html += "<br>â€»ä¸¡æ–¹ãŒæº–å‚™OKã«ãªã‚‹ã¨é–‹å§‹å¯èƒ½ã§ã™ã€‚";
    }
    infoEl.innerHTML = html;
  });
}

function updateRoomInfoText() {
  const infoEl = document.getElementById("roomInfoText");
  if (!infoEl) return;
  if (!currentRoomId) {
    infoEl.textContent = "ã¾ã ã©ã®ãƒ«ãƒ¼ãƒ ã«ã‚‚å…¥ã£ã¦ã„ã¾ã›ã‚“ã€‚";
    return;
  }
  let text = "ãƒ«ãƒ¼ãƒ ID: " + currentRoomId + "\n";
  text += "ã‚ãªãŸã¯ " + (currentRoomRole === "host" ? "ãƒ›ã‚¹ãƒˆ" : "ã‚²ã‚¹ãƒˆ") + " ã§ã™ã€‚\n";
  text += "Firebaseã®åŒæœŸçµæœã¯å°‘ã—å¾…ã¤ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚";
  infoEl.textContent = text;
}

function setRoomReady(flag) {
  if (!roomRef || !currentRoomRole) {
    alert("ã¾ãšãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ or å‚åŠ ã—ã¦ãã ã•ã„ã€‚");
    return;
  }
  const key = currentRoomRole === "host" ? "hostReady" : "guestReady";
  roomRef.update({ [key]: !!flag }).catch(err => {
    console.error(err);
    alert("æº–å‚™çŠ¶æ…‹ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
  });
}

function leaveRoom() {
  if (roomRef && roomListener) {
    roomRef.off("value", roomListener);
  }
  // ãƒ›ã‚¹ãƒˆãŒæŠœã‘ã‚‹ãªã‚‰ãƒ«ãƒ¼ãƒ å‰Šé™¤
  if (roomRef && currentRoomRole === "host") {
    roomRef.remove().catch(e => console.error(e));
  }
  currentRoomId = null;
  currentRoomRole = null;
  roomRef = null;
  roomListener = null;

  const disp = document.getElementById("roomIdDisplay");
  if (disp) disp.textContent = "-";
  const infoEl = document.getElementById("roomInfoText");
  if (infoEl) infoEl.textContent = "ã¾ã ã©ã®ãƒ«ãƒ¼ãƒ ã«ã‚‚å…¥ã£ã¦ã„ã¾ã›ã‚“ã€‚";
}

/* ========== ã‚·ãƒ§ãƒƒãƒ— ========== */
function showShop() {
  updateStoneDisplays();
  showScreen("shop");
}
function debugAddStones() {
  stones += 100;
  saveStones();
}

/* ========== ã‚¬ãƒãƒ£ ========== */
function showPack() {
  updateStoneDisplays();
  document.getElementById("packResult").innerHTML = "";
  showScreen("pack");
}

/* ãƒãƒˆãƒ«ã¨åŒã˜ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ä½¿ã£ã¦è¡¨ç¤ºã™ã‚‹ãŸã‚ã®å…±é€šæç”» */
function renderSingleCardDivFromBaseCard(baseCard, isEnchanted = false) {
  const cardInst = makeCardInstance(baseCard, isEnchanted);
  const wrap = document.createElement("div");
  wrap.style.display = "inline-block";
  wrap.style.margin = "4px";
  wrap.innerHTML = renderCardHtml(cardInst);
  const cardEl = wrap.firstElementChild;
  cardEl.onclick = () => showCardDetail(cardInst);
  return wrap;
}

function openPack() {
  const COST = 5;
  if (stones < COST) {
    alert("ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼ˆ5å€‹å¿…è¦ï¼‰");
    return;
  }
  stones -= COST;
  saveStones();

  const pulled = [];

  for (let i=0;i<5;i++) {
    let isEnchanted = false;
    let baseCard = null;

    // ã¾ãšEãƒ¬ã‚¢æŠ½é¸
    if (Math.random() < ENCHANTED_RATE) {
      const lCandidates = cards.filter(c => c.rarity === "L");
      if (lCandidates.length > 0) {
        baseCard = lCandidates[Math.floor(Math.random()*lCandidates.length)];
        isEnchanted = true;
      }
    }

    // EãŒå‡ºãªã‹ã£ãŸå ´åˆã¯é€šå¸¸ãƒ¬ã‚¢ãƒªãƒ†ã‚£æŠ½é¸
    if (!baseCard) {
      const r = Math.random();
      let rarity;
      if (r < 0.78) rarity = "N";
      else if (r < 0.90) rarity = "R";
      else if (r < 0.98) rarity = "SR";
      else rarity = "L";

      let candidates = cards.filter(c => c.rarity === rarity);
      if (candidates.length === 0) {
        const order = ["L","SR","R","N"];
        for (const rr of order) {
          const list = cards.filter(c => c.rarity === rr);
          if (list.length) { candidates = list; break; }
        }
        if (!candidates.length) candidates = cards.slice();
      }
      baseCard = candidates[Math.floor(Math.random()*candidates.length)];
    }

    pulled.push({ card: baseCard, isEnchanted });

    // é€šå¸¸ç‰ˆ
    if (!collection[baseCard.id]) collection[baseCard.id] = 0;
    collection[baseCard.id]++;

    // Eç‰ˆ
    if (isEnchanted) {
      if (!enchantedCollection[baseCard.id]) enchantedCollection[baseCard.id] = 0;
      enchantedCollection[baseCard.id]++;
    }
  }
  saveCollection();
  saveEnchantedCollection();

  const pr = document.getElementById("packResult");
  pr.innerHTML = "";
  pulled.forEach(obj => {
    const c = obj.card;
    const cardDiv = renderSingleCardDivFromBaseCard(c, obj.isEnchanted);
    pr.appendChild(cardDiv);
  });
}

/* ========== ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— ========== */
function getCardEffectText(card) {
  switch(card.id) {
    case 6:
      return "ã‚½ãƒ³ã‚°ï¼ˆ7ï¼‰ï¼šå ´ã®ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ©ã‚’ç ´å£Šã™ã‚‹ã€‚ã‚­ãƒ£ãƒ©ãŒæ­Œã†å ´åˆã€ã‚³ã‚¹ãƒˆã‚’æ”¯æ‰•ã‚ãšã«ä½¿ç”¨ã§ãã‚‹ã€‚ä½¿ç”¨å¾Œã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case 7:
      return "å¤‰èº«6ï¼šè‡ªåˆ†ã®ã€Œã‚±ãƒ«ã‚µã€ã‹ã‚‰å¤‰èº«ã§ãã‚‹ã€‚\nå¬å–šæ™‚ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ã‚’æœ€å¤§2ä½“ã¾ã§å‡çµã™ã‚‹ã€‚å‡çµä¸­ã®ã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ããªã„ã€‚";
    case 8:
      return "å›é¿ï¼šå›é¿ã‚’æŒã¤ã‚­ãƒ£ãƒ©ã«ã—ã‹ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã•ã‚Œãªã„ã€‚";
    case 9:
      return "ãƒ­ã‚¢0ï¼ˆã‚·ãƒ¼ã‚¯ã—ã¦ã‚‚ãƒ­ã‚¢ã¯å¾—ã‚‰ã‚Œãªã„ï¼‰ã€‚\nçªé€²ï¼šã“ã®ã‚¿ãƒ¼ãƒ³å¬å–šã—ãŸã‚¿ãƒ¼ãƒ³ã§ã‚‚ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã§ãã‚‹ã€‚\nã“ã®ã‚­ãƒ£ãƒ©ã¯æ”»æ’ƒå¯èƒ½ã§æœ‰åŠ¹ãªãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆãŒã„ã‚‹å ´åˆã€å¿…ãšãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚";
    case 10:
      return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®å ´ã®å¥½ããªã‚­ãƒ£ãƒ©1ä½“ã‚’é€€å ´ã•ã›ã‚‹ã€‚";
    case 11:
      return "ç‰¹ã«ãªã—ã€‚";
    case 12:
      return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®å ´ã®å¥½ããªã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚³ã‚¹ãƒˆã‚¾ãƒ¼ãƒ³ã«é€ã‚‹ã€‚";
    case 13:
      return "â‘ ã“ã®ã‚­ãƒ£ãƒ©ãŒå ´ã«ã„ã‚‹é–“ã€è‡ªåˆ†ã¯1ã‚¿ãƒ¼ãƒ³ã«ç½®ã‘ã‚‹ã‚¤ãƒ³ã‚¯ãŒ1æšå¢—ãˆã‚‹ã€‚\nâ‘¡è‡ªåˆ†ã®ã‚³ã‚¹ãƒˆãŒ10æšä»¥ä¸Šã‚ã‚‹é–“ã€ã“ã®ã‚­ãƒ£ãƒ©ã®ãƒ­ã‚¢ã¯5ã«ãªã‚‹ã€‚";
    case 14:
      return "ãƒ­ã‚¢1ã€‚\nã“ã®ã‚«ãƒ¼ãƒ‰ãŒç ´å£Šã•ã‚ŒãŸã¨ãã€å¢“åœ°ã«è¡Œã‹ãšã‚³ã‚¹ãƒˆã‚¾ãƒ¼ãƒ³ã«ç½®ã‹ã‚Œã‚‹ã€‚";
    case 15:
      return "ã‚½ãƒ³ã‚°ï¼ˆ5ï¼‰ï¼šç›¸æ‰‹ã®å ´ã®å¥½ããªã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚³ã‚¹ãƒˆã‚¾ãƒ¼ãƒ³ã«é€ã‚‹ã€‚ä½¿ç”¨å¾Œã€ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case 16:
      return "å¬å–šæ™‚ï¼šè‡ªåˆ†ã®å ´ã®ã‚­ãƒ£ãƒ©ã‹ã‚‰åˆè¨ˆ3ãƒ€ãƒ¡ãƒ¼ã‚¸ã¾ã§å¥½ããªã‚ˆã†ã«å›å¾©ã—ã€ãã®å›å¾©ã—ãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã®æ•°ã ã‘è¿½åŠ ã§ãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
    case 19:
      return "æ­Œå£°5ï¼šã“ã®ã‚­ãƒ£ãƒ©ã¯ã‚½ãƒ³ã‚°ã‚’æ­Œã†ã¨ãã€ã‚³ã‚¹ãƒˆ5ã®ã‚½ãƒ³ã‚°ã‚’æ­Œãˆã‚‹ã‚­ãƒ£ãƒ©ã¨ã—ã¦æ‰±ã†ã€‚\nå¬å–šæ™‚ï¼šè‡ªåˆ†ã®ãƒ‡ãƒƒã‚­ã®ä¸Šã‹ã‚‰4æšè¦‹ã¦ã€ãã®ä¸­ã‹ã‚‰ã‚½ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã‚’1æšã¾ã§æ‰‹æœ­ã«åŠ ãˆã‚‹ã€‚æ®‹ã‚Šã¯å¥½ããªé †ç•ªã§ãƒ‡ãƒƒã‚­ã®ä¸‹ã«ç½®ãã€‚";

    case 20:
      return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®å ´ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼1ä½“ã‚’é¸ã³ã€ãã®ã‚­ãƒ£ãƒ©ã‚’ç›¸æ‰‹ã®æ‰‹æœ­ã«æˆ»ã—ã¦ã‚‚ã‚ˆã„ã€‚";
    case 22:
      return "ã‚½ãƒ³ã‚°ï¼ˆ2ï¼‰ï¼šç›¸æ‰‹ã¯è‡ªåˆ†ã®æ‰‹æœ­ã‹ã‚‰1æšã‚’é¸ã³ã€æ¨ã¦ã‚‹ã€‚";
    case 24:
      return "è‡ªåˆ†ã®å ´ã«ä»–ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã„ã‚‹ã‚ã„ã ã€ã“ã®ã‚­ãƒ£ãƒ©ã¯ã€Œå›é¿ã€ã‚’å¾—ã‚‹ã€‚";
    case 25:
      return "ã‚½ãƒ³ã‚°ï¼ˆ3ï¼‰ï¼šã‚«ãƒ¼ãƒ‰ã‚’3æšãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
    case 26:
      return "å¬å–šæ™‚ï¼šã‚«ãƒ¼ãƒ‰ã‚’1æšãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
    case 28:
      return "ã‚½ãƒ³ã‚°ï¼ˆ5ï¼‰ï¼šãŠäº’ã„ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ‰‹æœ­ã‚’ã™ã¹ã¦æ¨ã¦ã€7æšãƒ‰ãƒ­ãƒ¼ã™ã‚‹ã€‚";
    case 29:
      return "ãƒã‚¸ãƒƒã‚¯ï¼ˆ3ï¼‰ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼1ä½“ã‚’é¸ã³ã€ãã®ã‚­ãƒ£ãƒ©ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
    case 30:
      return "ã‚½ãƒ³ã‚°ï¼ˆ5ï¼‰ï¼šç›¸æ‰‹ã®å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚";
    case 31:
      return "ç°çŒ›2ï¼šã“ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒãƒãƒ£ãƒ¬ãƒ³ã‚¸ã™ã‚‹ã¨ãã€æ”»æ’ƒåŠ›ãŒï¼‹2ã•ã‚Œã‚‹ã€‚";
    default:
      return "ç‰¹ã«ãªã—ã€‚";
  }
}

function showCardDetail(card) {
  const overlay = document.getElementById("cardDetailOverlay");
  const content = document.getElementById("cardDetailContent");
  if (!overlay || !content) return;

  const effectText = getCardEffectText(card);
  const rarityDisp = card.isEnchanted ? "Eï¼ˆã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒ†ãƒƒãƒ‰ï¼‰" : card.rarity;

  const statsPart = (card.type === "character")
    ? `<div style="margin-bottom:4px;">ATK:${card.atk} / HP:${card.hp}/${card.maxHp} / ãƒ­ã‚¢:${card.lore}</div>`
    : `<div style="margin-bottom:4px;">ã‚½ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰</div>`;

  content.innerHTML = `
    <div style="font-weight:bold; margin-bottom:4px;">${card.name}</div>
    <div style="font-size:12px; margin-bottom:4px;">
      è‰²:${card.color} ï¼ ç¨®é¡:${card.type} ï¼ ã‚³ã‚¹ãƒˆ:${card.cost} ï¼ ãƒ¬ã‚¢:${rarityDisp}
    </div>
    ${statsPart}
    <div style="font-size:12px; white-space:pre-wrap;">${effectText}</div>
  `;
  overlay.style.display = "block";
}

function showCardDetailById(id) {
  const base = cards.find(c => c.id === id);
  if (!base) return;
  const inst = makeCardInstance(base, false);
  showCardDetail(inst);
}

/* ã‚¢ãƒªã‚¨ãƒŠã‚¤ï¼ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã®ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§ã‚‚ overlay ã‚’ä½¿ã†ã®ã§
   ã€Œæˆ»ã‚‹ã€ãŒæŠ¼ã•ã‚ŒãŸå ´åˆã¯ã€åŠ¹æœã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹æŒ™å‹•ã«ã—ã¦ãŠã */
function closeCardDetail() {
  const overlay = document.getElementById("cardDetailOverlay");
  if (overlay) overlay.style.display = "none";

  if (typeof arienaiState !== "undefined" && arienaiState) {
    addLog("ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€ã®åŠ¹æœã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã€‚");
    arienaiState = null;
  }
  if (typeof pretzelState !== "undefined" && pretzelState) {
    addLog("ã€Œãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«ã€ã®åŠ¹æœã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã€‚");
    pretzelState = null;
  }
}

/* ========== ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ ========== */
function openCollection() {
  const list = document.getElementById("collectionList");
  list.innerHTML = "";

  cards.forEach(c => {
    const cnt = collection[c.id] || 0;
    const eCnt = enchantedCollection[c.id] || 0;

    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";
    row.style.marginBottom = "4px";

    const cardDiv = renderSingleCardDivFromBaseCard(c, false);
    row.appendChild(cardDiv);

    const info = document.createElement("div");
    info.style.fontSize = "12px";
    info.innerHTML = `
      <div>${c.name}</div>
      <div>è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity}</div>
      <div>æ‰€æŒæšæ•°: é€šå¸¸Ã—${cnt} ${eCnt > 0 ? "ï¼ E:Ã—" + eCnt : ""}</div>
    `;
    row.appendChild(info);

    list.appendChild(row);
  });

  showScreen("collection");
}

/* ========== ãƒ‡ãƒƒã‚­ç·¨é›† ========== */
let deckCountsNormal = {};
let deckCountsEnchanted = {};

function openDeckBuilder(index) {
  if (typeof index === "number") {
    currentDeckIndex = index;
  }
  rebuildDeckEditor();
  showScreen("deck");
}

function switchDeck(idx) {
  currentDeckIndex = idx;
  rebuildDeckEditor();
}

function rebuildDeckEditor() {
  deckCountsNormal = {};
  deckCountsEnchanted = {};

  const currentDeck = savedDecks[currentDeckIndex] || [];

  currentDeck.forEach(entry => {
    if (typeof entry === "number") {
      deckCountsNormal[entry] = (deckCountsNormal[entry] || 0) + 1;
      return;
    }
    if (entry && typeof entry === "object") {
      const id = entry.id;
      if (!entry.hasOwnProperty("isEnchanted") || !entry.isEnchanted) {
        deckCountsNormal[id] = (deckCountsNormal[id] || 0) + 1;
      } else {
        deckCountsEnchanted[id] = (deckCountsEnchanted[id] || 0) + 1;
      }
    }
  });

  const label = document.getElementById("currentDeckLabel");
  if (label) label.textContent = currentDeckIndex + 1;

  const area = document.getElementById("deckCardList");
  let html = "";
  cards.forEach(c => {
    const haveNormal = collection[c.id] || 0;
    const haveE      = enchantedCollection[c.id] || 0;
    const inDeckN = deckCountsNormal[c.id] || 0;
    const inDeckE = deckCountsEnchanted[c.id] || 0;

    html += `
      <div class="card-box ${c.color}" onclick="showCardDetailById(${c.id})">
        <div class="card-name">${c.name}</div>
        <div class="card-stats">
          è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type} / ã‚³ã‚¹ãƒˆ:${c.cost}
        </div>
        <div class="card-stats">
          æ‰€æŒ: é€šå¸¸Ã—${haveNormal} ï¼ EÃ—${haveE}
        </div>
        <div class="card-stats">
          ãƒ‡ãƒƒã‚­: é€šå¸¸Ã—<span id="deck-n-${c.id}">${inDeckN}</span>
           ï¼ EÃ—<span id="deck-e-${c.id}">${inDeckE}</span>
        </div>
        <button class="btn small"
          onclick="event.stopPropagation(); changeDeckCount(${c.id}, -1, false)">ï¼é€šå¸¸</button>
        <button class="btn small"
          onclick="event.stopPropagation(); changeDeckCount(${c.id}, +1, false)">ï¼‹é€šå¸¸</button>
        <button class="btn small"
          onclick="event.stopPropagation(); changeDeckCount(${c.id}, -1, true)">ï¼E</button>
        <button class="btn small"
          onclick="event.stopPropagation(); changeDeckCount(${c.id}, +1, true)">ï¼‹E</button>
      </div>`;
  });
  area.innerHTML = html;
}

function isBasicCard(cardId) {
  return cardId >= 0 && cardId <= 5;
}

function getDeckColorsFromTwoCounts() {
  const colors = new Set();
  function addFrom(counts) {
    Object.entries(counts).forEach(([idStr, cnt]) => {
      if (cnt > 0) {
        const base = cards.find(c => c.id === parseInt(idStr,10));
        if (base) colors.add(base.color);
      }
    });
  }
  addFrom(deckCountsNormal);
  addFrom(deckCountsEnchanted);
  return colors;
}

function changeDeckCount(cardId, diff, isEnchanted) {
  const card = cards.find(c => c.id === cardId);
  if (!card) return;

  const basic = isBasicCard(cardId);
  const counts = isEnchanted ? deckCountsEnchanted : deckCountsNormal;
  let cur = counts[cardId] || 0;
  const before = cur;
  cur += diff;
  if (cur < 0) cur = 0;

  const haveLimit = isEnchanted
    ? (enchantedCollection[cardId] || 0)
    : (collection[cardId] || 0);

  if (cur > haveLimit) {
    alert("æ‰€æŒã—ã¦ã„ã‚‹æšæ•°ã‚’è¶…ãˆã¦ãƒ‡ãƒƒã‚­ã«å…¥ã‚Œã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚");
    cur = haveLimit;
  }
  counts[cardId] = cur;

  // è‰²ãƒã‚§ãƒƒã‚¯ï¼ˆ2è‰²ã¾ã§ï¼‰
  const colors = getDeckColorsFromTwoCounts();
  if (colors.size > 2) {
    counts[cardId] = before;
    alert("ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ã§ã™ã€‚3è‰²ç›®ã®ã‚«ãƒ¼ãƒ‰ã¯å…¥ã‚Œã‚‰ã‚Œã¾ã›ã‚“ã€‚");
    cur = before;
  }

  // åŒå4æšåˆ¶é™ï¼ˆåŸºæœ¬6ç¨®ä»¥å¤–ï¼‰ã€‚é€šå¸¸ï¼‹Eã®åˆè¨ˆã§4æšã¾ã§
  const totalSame =
    (deckCountsNormal[cardId] || 0) + (deckCountsEnchanted[cardId] || 0);
  if (!basic && totalSame > 4) {
    counts[cardId] = before;
    if (diff > 0) {
      alert("åŒã˜åå‰ã®ã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ã§ã™ã€‚ï¼ˆé€šå¸¸ã¨Eã®åˆè¨ˆï¼‰");
    }
  }

  const spanN = document.getElementById("deck-n-" + cardId);
  const spanE = document.getElementById("deck-e-" + cardId);
  if (spanN) spanN.textContent = deckCountsNormal[cardId] || 0;
  if (spanE) spanE.textContent = deckCountsEnchanted[cardId] || 0;
}

function saveDeck() {
  const newDeck = [];

  Object.entries(deckCountsNormal).forEach(([idStr, cnt]) => {
    const id = parseInt(idStr, 10);
    for (let i = 0; i < cnt; i++) {
      newDeck.push({ id, isEnchanted: false });
    }
  });

  Object.entries(deckCountsEnchanted).forEach(([idStr, cnt]) => {
    const id = parseInt(idStr, 10);
    for (let i = 0; i < cnt; i++) {
      newDeck.push({ id, isEnchanted: true });
    }
  });

  if (newDeck.length < 60) {
    alert("ãƒ‡ãƒƒã‚­ã¯60æšä»¥ä¸Šã«ã—ã¦ãã ã•ã„ã€‚ï¼ˆç¾åœ¨ " + newDeck.length + "æšï¼‰");
    return;
  }

  savedDecks[currentDeckIndex] = newDeck;
  savePlayerDecks();
  alert("ãƒ‡ãƒƒã‚­" + (currentDeckIndex+1) + "ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ï¼ˆ" + newDeck.length + "æšï¼‰");
  updatePlayerDeckButtons();
}

/* ========== CPUè¨­å®š ========== */
let cpuStrength = "normal";
let cpuSelectedColors = [];
let playerDeckMode = "default";

function openCpuConfig() {
  updateCpuButtons();
  updatePlayerDeckButtons();
  showScreen("cpu");
}

function setCpuStrength(s) {
  cpuStrength = s;
  updateCpuButtons();
}
function setCpuColor(color) {
  const idx = cpuSelectedColors.indexOf(color);
  if (idx >= 0) {
    cpuSelectedColors.splice(idx, 1);
  } else {
    if (cpuSelectedColors.length >= 2) {
      alert("CPUãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ã§ã™ã€‚");
      return;
    }
    cpuSelectedColors.push(color);
  }
  updateCpuButtons();
}
function updateCpuButtons() {
  document.getElementById("btnCpuNormal").classList.toggle("toggle-selected", cpuStrength==="normal");
  document.getElementById("btnCpuStrong").classList.toggle("toggle-selected", cpuStrength==="strong");
  const colors = ["red","purple","blue","yellow","white","green"];
  colors.forEach(c => {
    const btnId = "cpu" + c.charAt(0).toUpperCase() + c.slice(1);
    const btn = document.getElementById(btnId);
    if (!btn) return;
    btn.classList.toggle("toggle-selected", cpuSelectedColors.includes(c));
  });
}

function hasCustomDeck(index) {
  const deck = savedDecks[index];
  return Array.isArray(deck) && deck.length > 0;
}

function updatePlayerDeckButtons() {
  const btnDef = document.getElementById("btnPlayerDefault");
  const btn1 = document.getElementById("btnDeck1");
  const btn2 = document.getElementById("btnDeck2");
  const btn3 = document.getElementById("btnDeck3");

  if (!btnDef) return;

  btnDef.classList.toggle("toggle-selected", playerDeckMode==="default");
  btn1.classList.toggle("toggle-selected", playerDeckMode==="deck1");
  btn2.classList.toggle("toggle-selected", playerDeckMode==="deck2");
  btn3.classList.toggle("toggle-selected", playerDeckMode==="deck3");

  const btns = [btn1, btn2, btn3];
  for (let i=0;i<3;i++) {
    if (!hasCustomDeck(i)) {
      btns[i].disabled = true;
      btns[i].textContent = "ãƒ‡ãƒƒã‚­" + (i+1) + "ï¼ˆæœªä¿å­˜ï¼‰";
    } else {
      btns[i].disabled = false;
      btns[i].textContent = "ãƒ‡ãƒƒã‚­" + (i+1);
    }
  }
}

function selectPlayerDeck(mode) {
  if (mode.startsWith("deck")) {
    const idx = parseInt(mode.slice(4), 10) - 1;
    if (!hasCustomDeck(idx)) {
      alert("ã¾ãšãƒ‡ãƒƒã‚­ç·¨é›†ã§ãƒ‡ãƒƒã‚­" + (idx+1) + "ã‚’ä¿å­˜ã—ã¦ãã ã•ã„ã€‚");
      return;
    }
  }
  playerDeckMode = mode;
  updatePlayerDeckButtons();
}

/* ========== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ========== */
function shuffle(arr) {
  for (let i=arr.length-1;i>0;i--) {
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
}

/* ========== ã‚«ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆ ========== */
function makeCardInstance(base, isEnchanted = false) {
  return {
    id: base.id,
    name: base.name,
    color: base.color,
    type: base.type,
    cost: base.cost,
    atk: base.atk || 0,
    hp: base.hp || 0,
    maxHp: base.hp || 0,
    lore: base.lore || 0,
    rarity: base.rarity,
    inkable: base.inkable ?? true,
    effect: base.effect || null,
    evolveCost: base.evolveCost || null,
    evade: base.evade || false,
    mustAttack: base.mustAttack || false,
    songPower: base.songPower || base.cost || 0,
    rush: base.rush || false,          // â˜… ã‚¿ã‚¤ã‚¿ãƒ³ç”¨ï¼šçªé€²
    isEnchanted: !!isEnchanted,        // â˜… Eç‰ˆã‹ã©ã†ã‹
    rest: false,
    frozen: false,
    summonTurn: 0
  };
}

/* savedDecks ã‹ã‚‰ãƒãƒˆãƒ«ç”¨ãƒ‡ãƒƒã‚­ã‚’ä½œã‚‹ï¼ˆé€šå¸¸/Eã‚’å¼•ãç¶™ãï¼‰ */
function buildDeckInstancesFromSaved(saved) {
  const result = [];
  (saved || []).forEach(entry => {
    if (typeof entry === "number") {
      const base = cards.find(c => c.id === entry);
      if (base) result.push(makeCardInstance(base, false));
    } else if (entry && typeof entry === "object") {
      const base = cards.find(c => c.id === entry.id);
      if (base) result.push(makeCardInstance(base, !!entry.isEnchanted));
    }
  });
  shuffle(result);
  return result;
}

/* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèµ¤ãƒ‡ãƒƒã‚­ï¼ˆã¨ã‚Šã‚ãˆãš60æšã«ãªã‚‹ã‚ˆã†ã«ã—ã¦ãŠãï¼‰ */
function makeDefaultDeck() {
  const ids = [];
  // åŸºæœ¬èµ¤1ã‚³ã‚¹
  for (let i = 0; i < 12; i++) ids.push(0);   // ã‚«ãƒ¼
  // ãã‚ãã‚ãƒ€ãƒƒã‚¯
  for (let i = 0; i < 8; i++) ids.push(11);
  // ã‚¿ã‚¤ã‚¿ãƒ³
  for (let i = 0; i < 4; i++) ids.push(9);
  // ã‚¸ãƒ¼ãƒ¦ãƒ¼
  for (let i = 0; i < 4; i++) ids.push(20);
  // ã‚¨ãƒ³ãƒãƒ³ã‚¹
  for (let i = 0; i < 4; i++) ids.push(21);
  // èƒŒç­‹ãŒãƒ’ãƒ¤ãƒª
  for (let i = 0; i < 4; i++) ids.push(22);
  // çµ‚ç„‰ã®å¤§ç«
  for (let i = 0; i < 4; i++) ids.push(6);
  // ä¼èª¬ã®å‹‡è€…ã‚¤ãƒ•ãƒªãƒ¼ãƒˆ
  for (let i = 0; i < 4; i++) ids.push(8);

  // è¶³ã‚Šãªã‘ã‚Œã°é©å½“ã«ã‚«ãƒ¼ã‚’è¶³ã™
  while (ids.length < 60) ids.push(0);
  return ids;
}

/* ========== ãƒãƒˆãƒ«çŠ¶æ…‹ ========== */
let battle = null;
let arienaiState = null;
let pretzelState = null;

/* ========== ã‚«ãƒ¼ãƒ‰æç”» ========== */
function renderCardHtml(card) {
  const classes = ["card", card.color];
  if (card.rest) classes.push("rest");
  if (card.isEnchanted) classes.push("enchanted");

  const rarityBadge = card.isEnchanted ? "E" : card.rarity;
  const atkHp = card.type === "character"
    ? `ATK:${card.atk} / HP:${card.hp}/${card.maxHp}`
    : "ã‚½ãƒ³ã‚°";

  const lorePart = card.type === "character"
    ? `ãƒ­ã‚¢:${card.lore}`
    : "";

  const inkSymbol = card.inkable ? "â—" : "Ã—";

  return `
    <div class="${classes.join(" ")}">
      <div class="card-header">
        <div class="card-cost">${card.cost}</div>
        <div class="card-name-header">${card.name}</div>
        <div class="card-inkable">${inkSymbol}</div>
      </div>
      <div class="card-illustration">
        <!-- ã‚¤ãƒ©ã‚¹ãƒˆæ ï¼šã‚ã¨ã§ç”»åƒã‚’å·®ã—è¾¼ã‚ã‚‹ã‚ˆã†ã«ç©ºã§æ®‹ã™ -->
      </div>
      <div class="card-stats-row">
        <span>${atkHp}</span>
        <span>${lorePart}</span>
      </div>
      <div class="card-footer">
        <div>è‰²:${card.color} ï¼ ãƒ¬ã‚¢:${rarityBadge}</div>
      </div>
    </div>
  `;
}

/* ========== ãƒãƒˆãƒ«é–‹å§‹é–¢é€£ ========== */
function buildCpuDeck(selectedColors) {
  // è‰²æœªé¸æŠãªã‚‰ä¸€å¿œèµ¤ï¼‹ç´«ã«ã—ã¦ãŠã
  if (!selectedColors || selectedColors.length === 0) {
    selectedColors = ["red", "purple"];
  }
  if (selectedColors.length === 1) {
    // 1è‰²ã ã‘ãªã‚‰åŒã˜è‰²ã‚’2å›
    selectedColors = [selectedColors[0], selectedColors[0]];
  }

  const pool = cards.filter(c => selectedColors.includes(c.color));
  const deckEntries = [];
  // é©å½“ã«60æšä½œã‚‹
  while (deckEntries.length < 60) {
    const base = pool[Math.floor(Math.random() * pool.length)];
    if (!base) break;
    deckEntries.push({ id: base.id, isEnchanted: false });
  }
  shuffle(deckEntries);
  return buildDeckInstancesFromSaved(deckEntries);
}

/* ãƒãƒˆãƒ«é–‹å§‹ */
function startBattle() {
  if (cpuSelectedColors.length === 0) {
    if (!confirm("CPUã®è‰²ãŒé¸ã°ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã¨ã‚Šã‚ãˆãšèµ¤ï¼‹ç´«ã§å§‹ã‚ã¾ã™ã‹ï¼Ÿ")) {
      return;
    }
    cpuSelectedColors = ["red", "purple"];
    updateCpuButtons();
  }

  let playerDeckDef;
  if (playerDeckMode === "default") {
    const ids = makeDefaultDeck();
    playerDeckDef = ids.map(id => ({ id, isEnchanted: false }));
  } else if (playerDeckMode === "deck1") {
    playerDeckDef = savedDecks[0] || [];
  } else if (playerDeckMode === "deck2") {
    playerDeckDef = savedDecks[1] || [];
  } else if (playerDeckMode === "deck3") {
    playerDeckDef = savedDecks[2] || [];
  } else {
    playerDeckDef = [];
  }

  const playerDeck = buildDeckInstancesFromSaved(playerDeckDef);
  if (playerDeck.length < 60) {
    alert("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒƒã‚­ãŒ60æšæœªæº€ã§ã™ã€‚ãƒ‡ãƒƒã‚­ç·¨é›†ã‹ã‚‰ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  const cpuDeck = buildCpuDeck(cpuSelectedColors);

  battle = {
    turnCount: 1,
    currentPlayer: "player",
    player: {
      deck: playerDeck,
      hand: [],
      field: [],
      inkCurrent: 0,
      inkMax: 0,
      lore: 0
    },
    cpu: {
      deck: cpuDeck,
      hand: [],
      field: [],
      inkCurrent: 0,
      inkMax: 0,
      lore: 0
    }
  };

  const logEl = document.getElementById("log");
  if (logEl) logEl.innerHTML = "";

  // åˆæœŸæ‰‹æœ­ 5æšãšã¤
  for (let i = 0; i < 5; i++) {
    drawCardFor("player");
    drawCardFor("cpu");
  }

  showScreen("battle");
  addLog("ãƒãƒˆãƒ«é–‹å§‹ï¼");
  startPlayerTurn(true);
}

/* ========== å…±é€šãƒãƒˆãƒ«ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ========== */
function sideLabel(side) {
  return side === "player" ? "è‡ªåˆ†" : "ç›¸æ‰‹";
}

function drawCardFor(side) {
  if (!battle) return;
  const s = battle[side];
  if (!s) return;
  if (s.deck.length === 0) {
    addLog(sideLabel(side) + "ã®ãƒ‡ãƒƒã‚­ãŒåˆ‡ã‚ŒãŸï¼");
    return;
  }
  const card = s.deck.shift();
  s.hand.push(card);
}

function addLog(text) {
  const logEl = document.getElementById("log");
  if (!logEl) return;
  const div = document.createElement("div");
  div.textContent = text;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}

function canCharacterAct(card) {
  if (!card) return false;
  if (card.rest) return false;
  if (card.frozen) return false;
  return true;
}

function canCharacterAttack(card) {
  if (!canCharacterAct(card)) return false;
  // å¬å–šã‚¿ãƒ¼ãƒ³ã¯æ”»æ’ƒä¸å¯ï¼ˆçªé€²æŒã¡ã¯OKï¼‰
  if (!card.rush && battle && card.summonTurn === battle.turnCount) {
    return false;
  }
  return true;
}

/* å‹æ•—åˆ¤å®šï¼ˆãƒ­ã‚¢20ã§å‹ã¡ã«ã—ã¦ãŠãï¼‰ */
function checkWin() {
  if (!battle) return false;
  if (battle.player.lore >= 20) {
    alert("ãƒ­ã‚¢20åˆ°é”ï¼ã‚ãªãŸã®å‹ã¡ï¼");
    endBattleToMenu();
    return true;
  }
  if (battle.cpu.lore >= 20) {
    alert("ç›¸æ‰‹ãŒãƒ­ã‚¢20ã«åˆ°é”â€¦è² ã‘ã¦ã—ã¾ã£ãŸã€‚");
    endBattleToMenu();
    return true;
  }
  return false;
}

/* ========== ã‚¿ãƒ¼ãƒ³å‡¦ç† ========== */
function startPlayerTurn(isFirst) {
  if (!battle) return;
  if (!isFirst) {
    battle.turnCount++;
  } else {
    battle.turnCount = 1;
  }
  battle.currentPlayer = "player";

  // ã‚¤ãƒ³ã‚¯å¢—åŠ ï¼ˆæœ€å¤§10ï¼‰
  battle.player.inkMax = Math.min(battle.player.inkMax + 1, 10);
  battle.player.inkCurrent = battle.player.inkMax;

  // ç«‹ãŸã›ã‚‹ï¼†å‡çµè§£é™¤
  battle.player.field.forEach(c => {
    c.rest = false;
    if (c.frozen) c.frozen = false;
  });

  // â˜… ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ãƒ‰ãƒ­ãƒ¼ï¼ˆå¿…ãš1æšã ã‘ï¼‰
  drawCardFor("player");
  addLog("è‡ªåˆ†ã¯ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã®ãƒ‰ãƒ­ãƒ¼ã§1æšå¼•ã„ãŸã€‚");

  addLog("=== è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ " + battle.turnCount + " ===");
  updateBattleUI();
}

function startCpuTurn() {
  if (!battle) return;
  battle.currentPlayer = "cpu";

  battle.cpu.inkMax = Math.min(battle.cpu.inkMax + 1, 10);
  battle.cpu.inkCurrent = battle.cpu.inkMax;
  battle.cpu.field.forEach(c => {
    c.rest = false;
    if (c.frozen) c.frozen = false;
  });

  // â˜… CPUã‚‚ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«1ãƒ‰ãƒ­ãƒ¼ã ã‘
  drawCardFor("cpu");
  addLog("ç›¸æ‰‹ã¯ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã®ãƒ‰ãƒ­ãƒ¼ã§1æšå¼•ã„ãŸã€‚");

  addLog("=== ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ " + battle.turnCount + " ===");

  // CPUè¡Œå‹•
  cpuDoTurn();
}

/* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šã‚¿ãƒ¼ãƒ³çµ‚äº† */
function endTurn() {
  if (!battle) return;
  if (battle.currentPlayer !== "player") return;

  addLog("è‡ªåˆ†ã¯ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ãŸã€‚");
  updateBattleUI();
  startCpuTurn();
}

/* ãƒãƒˆãƒ«ã‹ã‚‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸æˆ»ã‚‹ */
function endBattleToMenu() {
  battle = null;
  arienaiState = null;
  pretzelState = null;
  showScreen("menu");
}

/* ========== å¬å–šæ™‚åŠ¹æœï¼ˆã‚±ãƒ«ã‚µå«ã‚€ï¼‰ ========== */
function handleOnSummonEffects(side, card) {
  if (!battle || !card || !card.effect) return;

  switch (card.effect) {
    case "freeze2":
      onSummonFreeze2(side, card);
      break;
    default:
      break;
  }
}

/* æ°·çµã®å¥³ç‹ã‚±ãƒ«ã‚µï¼šç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’æœ€å¤§2ä½“ã¾ã§å‡çµ */
function onSummonFreeze2(side, card) {
  const me = battle[side];
  const enemy = side === "player" ? battle.cpu : battle.player;
  if (!enemy || enemy.field.length === 0) {
    addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœï¼šç›¸æ‰‹ã®å ´ã«ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ã€å‡çµã§ããªã‹ã£ãŸã€‚`);
    return;
  }

  if (side === "player") {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯è‡ªåˆ†ã§å¯¾è±¡ã‚’é¸ã¶ï¼ˆæœ€å¤§2ä½“ï¼‰
    let msg = `ã€Œ${card.name}ã€å¬å–šæ™‚åŠ¹æœï¼šå‡çµã™ã‚‹ç›¸æ‰‹ã‚’æœ€å¤§2ä½“ã¾ã§é¸ã‚“ã§ãã ã•ã„ã€‚\n`;
    enemy.field.forEach((c, i) => {
      msg += `${i}: ${c.name} (ATK:${c.atk} / HP:${c.hp})\n`;
    });
    msg += "\nä¾‹: 0 / 0,2 / 1 3ï¼ˆç©ºæ¬„ã§ã‚¹ã‚­ãƒƒãƒ—ï¼‰";

    const input = prompt(msg, "");
    if (!input) {
      addLog("å‡çµã™ã‚‹ã‚­ãƒ£ãƒ©ã¯é¸ã°ãªã‹ã£ãŸã€‚");
      return;
    }

    const raw = input.split(/[\s,]+/).filter(Boolean);
    const idxs = [];
    raw.forEach(t => {
      const n = parseInt(t, 10);
      if (!isNaN(n) && n >= 0 && n < enemy.field.length && !idxs.includes(n)) {
        idxs.push(n);
      }
    });

    const chosen = idxs.slice(0, 2);
    if (chosen.length === 0) {
      addLog("å‡çµã™ã‚‹ã‚­ãƒ£ãƒ©ã¯é¸ã°ãªã‹ã£ãŸã€‚");
      return;
    }

    chosen.forEach(i => {
      const target = enemy.field[i];
      if (target) {
        target.frozen = true;
        addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœï¼šç›¸æ‰‹ã®ã€Œ${target.name}ã€ã‚’å‡çµã—ãŸã€‚`);
      }
    });
  } else {
    // CPUå´ï¼šATKãŒé«˜ã„é †ã«æœ€å¤§2ä½“
    const sorted = enemy.field.slice().sort((a, b) => b.atk - a.atk);
    const targets = sorted.slice(0, 2);
    targets.forEach(t => {
      t.frozen = true;
      addLog(`ç›¸æ‰‹ã®ã€Œ${card.name}ã€ã®åŠ¹æœã§ã€è‡ªåˆ†ã®ã€Œ${t.name}ã€ãŒå‡çµã—ãŸã€‚`);
    });
  }

  updateBattleUI();
}

/* ========== CPUã®è¡Œå‹• ========== */
function cpuDoTurn() {
  if (!battle) return;

  const cpu = battle.cpu;
  const me = battle.player;

  // 1. å¯èƒ½ãªé™ã‚Šã‚­ãƒ£ãƒ©ã‚’å¬å–š
  let summonedSomething = true;
  while (summonedSomething) {
    summonedSomething = false;
    for (let i = 0; i < cpu.hand.length; i++) {
      const card = cpu.hand[i];
      if (card.type === "character" && card.cost <= cpu.inkCurrent) {
        cpu.inkCurrent -= card.cost;
        cpu.hand.splice(i, 1);
        card.rest = false;
        card.summonTurn = battle.turnCount;
        cpu.field.push(card);
        addLog("ç›¸æ‰‹ã¯ã€Œ" + card.name + "ã€ã‚’å¬å–šã—ãŸã€‚");
        handleOnSummonEffects("cpu", card);
        summonedSomething = true;
        break;
      }
    }
  }

  updateBattleUI();

  // 2. ãƒãƒ£ãƒ¬ãƒ³ã‚¸ or ã‚·ãƒ¼ã‚¯
  cpu.field.forEach((card, idx) => {
    if (!canCharacterAttack(card)) return;

    if (me.field.length > 0 && card.atk > 0) {
      const targetIdx = Math.floor(Math.random() * me.field.length);
      const target = me.field[targetIdx];
      resolveCombat("cpu", idx, targetIdx);
    } else if (card.lore > 0 && !card.rest) {
      // ç›¸æ‰‹ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãªã‚‰ãƒ­ã‚¢ç¨¼ã
      card.rest = true;
      cpu.lore += card.lore;
      addLog("ç›¸æ‰‹ã®ã€Œ" + card.name + "ã€ãŒã‚·ãƒ¼ã‚¯ã—ã€ç›¸æ‰‹ã®ãƒ­ã‚¢ãŒ" + card.lore + "å¢—ãˆãŸã€‚ï¼ˆè¨ˆ" + cpu.lore + "ï¼‰");
    }
  });

  updateBattleUI();
  if (checkWin()) return;

  // ã‚¿ãƒ¼ãƒ³çµ‚äº† â†’ è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã¸
  addLog("ç›¸æ‰‹ã¯ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ãŸã€‚");
  startPlayerTurn(false);
}

/* ========== æˆ¦é—˜å‡¦ç† ========== */
function resolveCombat(attackerSide, attackerIndex, defenderIndex) {
  if (!battle) return;
  const atkSide = battle[attackerSide];
  const defSide = attackerSide === "player" ? battle.cpu : battle.player;

  const attacker = atkSide.field[attackerIndex];
  const defender = defSide.field[defenderIndex];
  if (!attacker || !defender) return;

  if (!canCharacterAttack(attacker)) {
    if (attackerSide === "player") {
      alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯ã¾ã ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã§ãã¾ã›ã‚“ã€‚");
    }
    return;
  }

  addLog(
    sideLabel(attackerSide) + "ã®ã€Œ" + attacker.name + "ã€ãŒ" +
    sideLabel(attackerSide === "player" ? "cpu" : "player") +
    "ã®ã€Œ" + defender.name + "ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼"
  );

  defender.hp -= attacker.atk;
  attacker.hp -= defender.atk;

  attacker.rest = true;

  if (defender.hp <= 0) {
    addLog("ã€Œ" + defender.name + "ã€ã¯é€€å ´ã—ãŸã€‚");
    defSide.field.splice(defenderIndex, 1);
  }
  if (attacker.hp <= 0) {
    addLog("ã€Œ" + attacker.name + "ã€ã¯é€€å ´ã—ãŸã€‚");
    atkSide.field.splice(attackerIndex, 1);
  }
}

/* ========== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ã‚¯ãƒªãƒƒã‚¯å‡¦ç† ========== */
function onPlayerHandCardClick(index) {
  if (!battle) return;
  if (battle.currentPlayer !== "player") return;

  const card = battle.player.hand[index];
  if (!card) return;

  const actionArea = document.getElementById("actionArea");
  let html = `<div>æ‰‹æœ­ï¼šã€Œ${card.name}ã€ã‚’é¸æŠä¸­</div>`;

  if (card.type === "character") {
    html += `<button class="btn small" onclick="playPlayerCharacter(${index})">
      å¬å–šï¼ˆã‚³ã‚¹ãƒˆ${card.cost}ï¼‰
    </button>`;
  } else if (card.type === "song") {
    html += `<button class="btn small" onclick="playPlayerSong(${index})">
      ã‚½ãƒ³ã‚°ã‚’ä½¿ç”¨ï¼ˆã‚³ã‚¹ãƒˆ${card.cost}ï¼‰
    </button>`;
  }

  html += `<button class="btn small" onclick="showCardDetailFromBattle('player','hand',${index})">
    ã‚«ãƒ¼ãƒ‰è©³ç´°
  </button>`;

  actionArea.innerHTML = html;
}

function onPlayerFieldCardClick(index) {
  if (!battle) return;
  const card = battle.player.field[index];
  if (!card) return;

  const actionArea = document.getElementById("actionArea");
  let html = `<div>å ´ï¼šã€Œ${card.name}ã€ã‚’é¸æŠä¸­</div>`;

  if (battle.currentPlayer === "player") {
    if (canCharacterAct(card)) {
      if (card.lore > 0) {
        html += `<button class="btn small" onclick="doSeek(${index})">
          ã‚·ãƒ¼ã‚¯ï¼ˆãƒ­ã‚¢+${card.lore}ï¼‰
        </button>`;
      }
      if (battle.cpu.field.length > 0 && card.atk > 0) {
        html += `<button class="btn small" onclick="doChallenge(${index})">
          ãƒãƒ£ãƒ¬ãƒ³ã‚¸
        </button>`;
      }
    } else {
      html += `<div style="font-size:11px;opacity:0.8;">ã“ã®ã‚­ãƒ£ãƒ©ã¯ç¾åœ¨è¡Œå‹•ã§ãã¾ã›ã‚“ã€‚</div>`;
    }
  }

  html += `<button class="btn small" onclick="showCardDetailFromBattle('player','field',${index})">
    ã‚«ãƒ¼ãƒ‰è©³ç´°
  </button>`;

  actionArea.innerHTML = html;
}

/* ã‚·ãƒ¼ã‚¯ï¼ˆãƒ­ã‚¢ç²å¾—ï¼‰ */
function doSeek(fieldIndex) {
  if (!battle) return;
  if (battle.currentPlayer !== "player") return;
  const card = battle.player.field[fieldIndex];
  if (!card || !canCharacterAct(card)) return;

  card.rest = true;
  battle.player.lore += card.lore;
  addLog(`è‡ªåˆ†ã®ã€Œ${card.name}ã€ãŒã‚·ãƒ¼ã‚¯ã—ã€ãƒ­ã‚¢ãŒ${card.lore}å¢—ãˆãŸã€‚ï¼ˆè¨ˆ${battle.player.lore}ï¼‰`);
  updateBattleUI();
  checkWin();
}

/* ãƒãƒ£ãƒ¬ãƒ³ã‚¸ */
function doChallenge(fieldIndex) {
  if (!battle) return;
  if (battle.currentPlayer !== "player") return;
  const card = battle.player.field[fieldIndex];
  if (!card) return;

  if (!canCharacterAttack(card)) {
    alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯ã¾ã ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã§ãã¾ã›ã‚“ï¼ˆçªé€²æŒã¡ã€Œã‚¿ã‚¤ã‚¿ãƒ³ã€ãªã‚‰å‡ºãŸã‚¿ãƒ¼ãƒ³ã§ã‚‚OKï¼‰");
    return;
  }
  if (battle.cpu.field.length === 0) {
    alert("ç›¸æ‰‹ã®å ´ã«ã‚­ãƒ£ãƒ©ãŒã„ã¾ã›ã‚“ã€‚");
    return;
  }
  const targetIndex = Math.floor(Math.random() * battle.cpu.field.length);
  resolveCombat("player", fieldIndex, targetIndex);
  updateBattleUI();
  checkWin();
}

/* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šã‚­ãƒ£ãƒ©å¬å–š */
function playPlayerCharacter(handIndex) {
  if (!battle) return;
  if (battle.currentPlayer !== "player") return;
  const hand = battle.player.hand;
  const card = hand[handIndex];
  if (!card || card.type !== "character") return;

  if (battle.player.inkCurrent < card.cost) {
    alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
    return;
  }

  battle.player.inkCurrent -= card.cost;
  hand.splice(handIndex, 1);
  card.rest = false;
  card.frozen = false;
  card.summonTurn = battle.turnCount;
  battle.player.field.push(card);

  addLog(`è‡ªåˆ†ã¯ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);

  // å¬å–šæ™‚åŠ¹æœï¼ˆã‚±ãƒ«ã‚µç­‰ï¼‰
  handleOnSummonEffects("player", card);

  updateBattleUI();
}

/* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šã‚½ãƒ³ã‚°ä½¿ç”¨ï¼ˆç°¡ç•¥ç‰ˆï¼šä»Šã¯ãƒ­ã‚°ã ã‘ï¼‰ */
function playPlayerSong(handIndex) {
  if (!battle) return;
  if (battle.currentPlayer !== "player") return;
  const hand = battle.player.hand;
  const card = hand[handIndex];
  if (!card || card.type !== "song") return;

  if (battle.player.inkCurrent < card.cost) {
    alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
    return;
  }

  battle.player.inkCurrent -= card.cost;
  hand.splice(handIndex, 1);

  addLog(`è‡ªåˆ†ã¯ã‚½ãƒ³ã‚°ã€Œ${card.name}ã€ã‚’ä½¿ç”¨ã—ãŸã€‚ï¼ˆè©³ç´°ãªåŠ¹æœã¯ç°¡ç•¥å‡¦ç†ä¸­ï¼‰`);
  updateBattleUI();
}

/* ã‚«ãƒ¼ãƒ‰è©³ç´°ã‚’ãƒãƒˆãƒ«ä¸­ã‹ã‚‰é–‹ã */
function showCardDetailFromBattle(side, place, index) {
  if (!battle) return;
  let card = null;
  if (place === "hand") {
    card = battle[side].hand[index];
  } else if (place === "field") {
    card = battle[side].field[index];
  }
  if (!card) return;
  showCardDetail(card);
}

/* ========== ç”»é¢æ›´æ–° ========== */
function updateBattleUI() {
  if (!battle) return;

  // CPUå´
  const cpuHandCountEl = document.getElementById("cpuHandCount");
  const cLoreEl = document.getElementById("cLore");
  const cDeckEl = document.getElementById("cDeck");
  if (cpuHandCountEl) cpuHandCountEl.textContent = battle.cpu.hand.length;
  if (cLoreEl) cLoreEl.textContent = battle.cpu.lore;
  if (cDeckEl) cDeckEl.textContent = battle.cpu.deck.length;

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
  const pLoreEl = document.getElementById("playerLore");
  const pInkCurEl = document.getElementById("playerInkCurrent");
  const pInkMaxEl = document.getElementById("playerInkMax");
  const pDeckEl = document.getElementById("playerDeck");
  const turnInfoEl = document.getElementById("turnInfo");

  if (pLoreEl) pLoreEl.textContent = battle.player.lore;
  if (pInkCurEl) pInkCurEl.textContent = battle.player.inkCurrent;
  if (pInkMaxEl) pInkMaxEl.textContent = battle.player.inkMax;
  if (pDeckEl) pDeckEl.textContent = battle.player.deck.length;
  if (turnInfoEl) {
    turnInfoEl.textContent =
      battle.currentPlayer === "player" ? "è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³" : "ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³";
  }

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ»æ‰‹æœ­æç”»
  const cpuFieldEl = document.getElementById("cpuField");
  const playerFieldEl = document.getElementById("playerField");
  const playerHandEl = document.getElementById("playerHand");

  if (cpuFieldEl) {
    cpuFieldEl.innerHTML = "";
    battle.cpu.field.forEach(card => {
      const wrap = document.createElement("div");
      wrap.innerHTML = renderCardHtml(card);
      cpuFieldEl.appendChild(wrap.firstElementChild);
    });
  }

  if (playerFieldEl) {
    playerFieldEl.innerHTML = "";
    battle.player.field.forEach((card, idx) => {
      const wrap = document.createElement("div");
      wrap.innerHTML = renderCardHtml(card);
      const el = wrap.firstElementChild;
      el.onclick = () => onPlayerFieldCardClick(idx);
      playerFieldEl.appendChild(el);
    });
  }

  if (playerHandEl) {
    playerHandEl.innerHTML = "";
    battle.player.hand.forEach((card, idx) => {
      const wrap = document.createElement("div");
      wrap.innerHTML = renderCardHtml(card);
      const el = wrap.firstElementChild;
      el.onclick = () => onPlayerHandCardClick(idx);
      playerHandEl.appendChild(el);
    });
  }
}

/* ========== åˆæœŸåŒ– ========== */
window.addEventListener("load", () => {
  loadData();      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚»ãƒ¼ãƒ–èª­ã¿è¾¼ã¿
  initFirebase();  // FirebaseåˆæœŸåŒ–ï¼ˆãƒ«ãƒ¼ãƒ æˆ¦ç”¨ï¼‰
});
</script>
</body>
</html>
