<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Dream-seeker TCG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #181818;
      color: #f5f5f5;
    }

    h1, h2 { text-align: center; margin: 12px 0; }

    .screen {
      display: none;
      padding: 10px;
      max-width: 520px;
      margin: 0 auto;
    }
    .screen.active { display: block; }

    .btn {
      width: 100%;
      padding: 10px;
      margin: 6px 0;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      background: #444;
      color: #f5f5f5;
    }
    .btn.primary { background: #2ecc71; color: #000; }
    .btn.danger  { background: #e74c3c; }
    .btn.small {
      width: auto;
      padding: 4px 8px;
      font-size: 12px;
      margin: 2px 4px 0 0;
    }

    .card-box {
      border: 1px solid #555;
      border-radius: 8px;
      padding: 6px;
      margin: 4px 0;
      font-size: 12px;
      background: #202020;
      cursor: pointer;
    }
    .card-name  { font-weight: bold; }
    .card-stats { font-size: 11px; opacity: 0.9; margin-top: 2px; }

    .red    { border-color: #e74c3c; }
    .purple { border-color: #9b59b6; }
    .blue   { border-color: #3498db; }
    .yellow { border-color: #f1c40f; }
    .white  { border-color: #ecf0f1; }
    .green  { border-color: #2ecc71; }

    .log {
      background: #111;
      border-radius: 8px;
      padding: 6px;
      font-size: 11px;
      height: 140px;
      overflow-y: auto;
      border: 1px solid #333;
      margin-top: 6px;
    }

    .section-title {
      font-size: 13px;
      margin: 10px 0 4px;
      font-weight: bold;
    }

    .stone-bar {
      font-size: 13px;
      padding: 4px 6px;
      border-radius: 8px;
      background: #222;
      display: inline-block;
      margin-bottom: 8px;
    }

    .row { display: flex; gap: 6px; }
    .row > .btn { flex: 1; }

    .toggle-selected {
      background: #f39c12 !important;
      color: #000 !important;
    }

    /* ===== ãƒãƒˆãƒ«ç”»é¢ç”¨ ===== */
    .battle-screen { padding: 16px; }

    .enemy-title { text-align: center; font-size: 20px; margin-bottom: 8px; }

    .enemy-status {
      display: flex;
      justify-content: space-around;
      margin-bottom: 8px;
      font-size: 13px;
      flex-wrap: wrap;
      gap: 6px;
    }

    #cpuField, #playerField, #playerHand {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      overflow-x: auto;
      padding: 8px 0;
      min-height: 160px;
      -webkit-overflow-scrolling: touch;
    }

    .divider {
      border-top: 3px dashed #ffffff;
      margin: 12px 0;
    }

    .bottom-ui {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .status-box, .effect-box {
      width: 48%;
      min-height: 120px;
      border: 3px solid #ffffff;
      box-sizing: border-box;
      padding: 8px;
      font-size: 14px;
    }

    .status-box-title, .effect-box-title { font-weight: bold; margin-bottom: 4px; }
    .turn-info { margin-top: 4px; font-weight: bold; }

    .status-buttons { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 4px; }
    .status-buttons button { font-size: 12px; padding: 4px 8px; }

    /* ã‚«ãƒ¼ãƒ‰è¦‹ãŸç›®ï¼ˆæ–°ã‚«ãƒ¼ãƒ‰å‹ï¼‰ */
    .card {
      flex: 0 0 auto;
      width: 96px;
      height: 160px;
      border-radius: 10px;
      border: 3px solid #555;
      background: #b30000;
      color: #ffffff;
      font-size: 10px;
      box-sizing: border-box;
      padding: 4px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
      position: relative;
      overflow: hidden;
    }
    .card:hover { transform: translateY(-2px); box-shadow: 0 0 8px rgba(255,255,255,0.3); }
    .card.rest { opacity: 0.6; transform: rotate(8deg); }

    .card.red    { border-color: #e74c3c; background: #8b1a1a; }
    .card.purple { border-color: #9b59b6; background: #4b2b63; }
    .card.blue   { border-color: #3498db; background: #1f3f5f; }
    .card.yellow { border-color: #f1c40f; background: #866d07; }
    .card.white  { border-color: #ecf0f1; background: #aaaaaa; color: #000; }
    .card.green  { border-color: #2ecc71; background: #145437; }

    .card.white .card-header, .card.white .card-footer { background: #ffffff; color: #000000; }
    .card.white .card-cost { color: #000000; }

    .card.enchanted {
      box-shadow: 0 0 10px rgba(255,255,255,0.8), 0 0 18px rgba(255,215,0,0.7);
      border-width: 3px;
      border-color: #ffd700;
    }
    .card.enchanted::before {
      content: "";
      position: absolute;
      inset: 0;
      background: conic-gradient(from 45deg,
        rgba(255,255,255,0.15),
        rgba(255,215,0,0.25),
        rgba(255,255,255,0.0),
        rgba(0,255,255,0.15),
        rgba(255,255,255,0.15)
      );
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #000000;
      border-radius: 4px;
      padding: 2px 3px;
      margin-bottom: 3px;
      font-weight: bold;
      position: relative;
      z-index: 1;
      gap: 4px;
    }
    .card-cost { min-width: 16px; text-align: center; }
    .card-name-header { flex: 1; text-align: center; font-size: 9px; line-height: 1.1; }
    .card-inkable { min-width: 16px; text-align: center; }

    .card-illustration {
      flex: 1;
      background: #ffffff;
      border-radius: 4px;
      margin-bottom: 3px;
      overflow: hidden;
      position: relative;
      z-index: 1;
    }

    .card-stats-row {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      padding: 0 2px;
      margin-bottom: 3px;
      position: relative;
      z-index: 1;
    }

    .card-footer {
      background: #000000;
      border-radius: 4px;
      padding: 2px 3px;
      font-size: 9px;
      position: relative;
      z-index: 1;
    }

    /* ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
    #cardDetailOverlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
    }
    #cardDetailInner {
      background: #222;
      max-width: 340px;
      margin: 40px auto;
      padding: 12px;
      border-radius: 10px;
      border: 1px solid #ffffff;
      font-size: 13px;
    }
  </style>
</head>
<body>

<!-- ===== ãƒ›ãƒ¼ãƒ  ===== -->
<div id="menuScreen" class="screen active">
  <h1>Dream-seeker TCG</h1>
  <div class="stone-bar">
    ğŸ’ ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="stoneCount">0</span>
  </div>
  <button class="btn primary" onclick="openCpuConfig()">ãƒãƒˆãƒ«</button>
  <button class="btn" onclick="showShop()">ã‚·ãƒ§ãƒƒãƒ—</button>
  <button class="btn" onclick="showPack()">ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</button>
  <button class="btn" onclick="openDeckBuilder()">ãƒ‡ãƒƒã‚­ç·¨é›†</button>
  <button class="btn" onclick="openCollection()">ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</button>
</div>

<!-- ===== CPUè¨­å®š ===== -->
<div id="cpuScreen" class="screen">
  <h2>CPUè¨­å®š</h2>

  <div class="section-title">CPUã®å¼·ã•</div>
  <div class="row">
    <button id="btnCpuNormal" class="btn" onclick="setCpuStrength('normal')">æ™®é€š</button>
    <button id="btnCpuStrong" class="btn" onclick="setCpuStrength('strong')">å¼·ã„</button>
  </div>
  <div class="row">
    <button id="btnCpuGod" class="btn" onclick="setCpuStrength('god')">é¬¼ï¼ˆæœ€å¼·ï¼‰</button>
  </div>

  <div class="section-title">CPUãƒ‡ãƒƒã‚­è‰²ï¼ˆ2è‰²é¸ã‚“ã§ã­ï¼‰</div>
  <div class="row">
    <button id="cpuRed"    class="btn" onclick="setCpuColor('red')">èµ¤</button>
    <button id="cpuPurple" class="btn" onclick="setCpuColor('purple')">ç´«</button>
  </div>
  <div class="row">
    <button id="cpuBlue"   class="btn" onclick="setCpuColor('blue')">é’</button>
    <button id="cpuYellow" class="btn" onclick="setCpuColor('yellow')">é»„</button>
  </div>
  <div class="row">
    <button id="cpuWhite"  class="btn" onclick="setCpuColor('white')">ç™½</button>
    <button id="cpuGreen"  class="btn" onclick="setCpuColor('green')">ç·‘</button>
  </div>

  <div class="section-title">è‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­</div>
  <button id="btnPlayerDefault" class="btn" onclick="selectPlayerDeck('default')">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèµ¤ãƒ‡ãƒƒã‚­</button>
  <button id="btnDeck1" class="btn" onclick="selectPlayerDeck('deck1')">ãƒ‡ãƒƒã‚­1ï¼ˆæœªä¿å­˜ï¼‰</button>
  <button id="btnDeck2" class="btn" onclick="selectPlayerDeck('deck2')">ãƒ‡ãƒƒã‚­2ï¼ˆæœªä¿å­˜ï¼‰</button>
  <button id="btnDeck3" class="btn" onclick="selectPlayerDeck('deck3')">ãƒ‡ãƒƒã‚­3ï¼ˆæœªä¿å­˜ï¼‰</button>

  <button class="btn primary" onclick="startBattle()">ãƒãƒˆãƒ«é–‹å§‹</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒãƒˆãƒ« ===== -->
<div id="battleScreen" class="screen">
  <div class="battle-screen">

    <!-- ç›¸æ‰‹ã‚¨ãƒªã‚¢ -->
    <div class="enemy-area">
      <div class="enemy-title">ç›¸æ‰‹</div>
      <div class="enemy-status">
        <span>æ‰‹æœ­ï¼š<span id="cpuHandCount">0</span>æš</span>
        <span>ãƒ­ã‚¢ï¼š<span id="cLore">0</span></span>
        <span>ã‚¤ãƒ³ã‚¯ï¼š<span id="cpuInkCurrent">0</span> / <span id="cpuInkMax">0</span></span>
        <span>æ®‹ã‚Šå±±æœ­ï¼š<span id="cDeck">0</span>æš</span>
      </div>
      <div id="cpuField"></div>
    </div>

    <div class="divider"></div>

    <!-- è‡ªåˆ†ã‚¨ãƒªã‚¢ -->
    <div class="player-area">

      <div id="playerField"></div>
      <div id="playerHand"></div>

      <div class="bottom-ui">
        <div class="status-box">
          <div class="status-box-title">è‡ªåˆ†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
          <div>ãƒ­ã‚¢ï¼š<span id="playerLore">0</span></div>
          <div>ã‚¤ãƒ³ã‚¯ï¼š<span id="playerInkCurrent">0</span> / <span id="playerInkMax">0</span></div>
          <div>æ®‹ã‚Šå±±æœ­ï¼š<span id="playerDeck">0</span></div>
          <div id="turnInfo" class="turn-info">è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³</div>

          <div class="status-buttons">
            <button class="btn small" onclick="endTurn()">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
            <button class="btn small danger" onclick="endBattleToMenu()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
          </div>
          <div style="font-size:11px;opacity:0.85;margin-top:6px;">
            â€»ãƒ‰ãƒ­ãƒ¼ã¯ã‚¿ãƒ¼ãƒ³é–‹å§‹ã«è‡ªå‹•ï¼ˆå…ˆè¡Œ1Tã¯ç„¡ã—ï¼‰ã€‚<br>
            â€»ã‚¤ãƒ³ã‚¯ã¯æ‰‹æœ­ã‹ã‚‰ã€Œã‚¤ãƒ³ã‚¯åŒ–ã€ã§å¢—ã‚„ã™ï¼ˆåŸºæœ¬1æš/ã‚¿ãƒ¼ãƒ³ã€ãƒªãƒ³ãŒã„ã‚‹ã¨+1ï¼‰ã€‚
          </div>
        </div>

        <div class="effect-box">
          <div class="effect-box-title">è¡Œå‹• / æƒ…å ±</div>
          <div id="actionArea">ã‚«ãƒ¼ãƒ‰ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨è¡Œå‹•ã‚’é¸ã¹ã¾ã™ã€‚</div>
        </div>
      </div>

      <div class="section-title">ãƒ­ã‚°</div>
      <div id="log" class="log"></div>

    </div>
  </div>
</div>

<!-- ===== ã‚·ãƒ§ãƒƒãƒ— ===== -->
<div id="shopScreen" class="screen">
  <h2>ã‚·ãƒ§ãƒƒãƒ—</h2>
  <p>â€» ä»Šã¯ãƒ†ã‚¹ãƒˆç”¨ã€‚çŸ³ã‚’å¢—ã‚„ã—æ”¾é¡Œã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚</p>
  <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="shopStoneCount">0</span></p>
  <button class="btn" onclick="debugAddStones()">çŸ³ã‚’100å€‹å¢—ã‚„ã™ï¼ˆãƒ†ã‚¹ãƒˆï¼‰</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‘ãƒƒã‚¯ ===== -->
<div id="packScreen" class="screen">
  <h2>ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</h2>
  <p>ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³5å€‹ã§1ãƒ‘ãƒƒã‚¯ï¼ˆ5æšå…¥ã‚Šï¼‰</p>
  <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="packStoneCount">0</span></p>
  <button class="btn primary" onclick="openPack()">ãƒ‘ãƒƒã‚¯ã‚’é–‹ã‘ã‚‹</button>
  <div class="section-title">ä»Šå›ã®çµæœ</div>
  <div id="packResult"></div>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‡ãƒƒã‚­ç·¨é›† ===== -->
<div id="deckScreen" class="screen">
  <h2>ãƒ‡ãƒƒã‚­ç·¨é›†</h2>
  <p style="font-size:12px; opacity:0.8;">
    æ‰€æŒã‚«ãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒƒã‚­ã«å…¥ã‚Œã‚‹æšæ•°ã‚’æ±ºã‚ã¦ãã ã•ã„ã€‚ä¿å­˜ã—ãŸãƒ‡ãƒƒã‚­ã¯ãƒãƒˆãƒ«ã§é¸ã¹ã¾ã™ã€‚<br>
    â€» ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ï¼åŒåã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ï¼ˆåŸºæœ¬6ç¨®ã¯ä½•æšã§ã‚‚å¯ï¼‰ï¼æœ€çµ‚çš„ã«60æšä»¥ä¸Š
  </p>

  <div style="margin-bottom:8px;">
    <button class="btn small" onclick="switchDeck(0)">ãƒ‡ãƒƒã‚­1</button>
    <button class="btn small" onclick="switchDeck(1)">ãƒ‡ãƒƒã‚­2</button>
    <button class="btn small" onclick="switchDeck(2)">ãƒ‡ãƒƒã‚­3</button>
    <div style="font-size:12px; opacity:0.9; margin-top:4px;">
      ç¾åœ¨ç·¨é›†ã—ã¦ã„ã‚‹ã®ã¯ï¼šãƒ‡ãƒƒã‚­<span id="currentDeckLabel">1</span>
    </div>
  </div>

  <div id="deckCardList"></div>
  <button class="btn primary" onclick="saveDeck()">ã“ã®å†…å®¹ã§ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« ===== -->
<div id="collectionScreen" class="screen">
  <h2>ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</h2>
  <div id="collectionList"></div>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— ===== -->
<div id="cardDetailOverlay">
  <div id="cardDetailInner">
    <div id="cardDetailContent"></div>
    <button class="btn" onclick="closeCardDetail()">æˆ»ã‚‹ / é–‰ã˜ã‚‹</button>
  </div>
</div>

<script>
/* ========== ç‰¹æ®ŠID ========== */
const ID_LIN = 13;

/* Eãƒ¬ã‚¢ï¼ˆã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒ†ãƒƒãƒ‰ï¼‰ã®ãƒ¬ãƒ¼ãƒˆï¼ˆ1ã‚«ãƒ¼ãƒˆãƒ³ï¼288ãƒ‘ãƒƒã‚¯ã€1ãƒ‘ãƒƒã‚¯5æšâ†’1440æšã«1æšãã‚‰ã„ï¼‰ */
const ENCHANTED_RATE = 1 / (288 * 5);

/* ========== ç”»é¢åˆ‡ã‚Šæ›¿ãˆ ========== */
function showScreen(name) {
  const ids = ["menuScreen","cpuScreen","battleScreen","shopScreen","packScreen","deckScreen","collectionScreen"];
  ids.forEach(id => document.getElementById(id)?.classList.remove("active"));
  const map = { menu:"menuScreen", cpu:"cpuScreen", battle:"battleScreen", shop:"shopScreen", pack:"packScreen", deck:"deckScreen", collection:"collectionScreen" };
  document.getElementById(map[name])?.classList.add("active");
}

/* ========== ã‚«ãƒ¼ãƒ‰å®šç¾© ========== */
const cards = [
  // åŸºæœ¬6ç¨®
  {id:0, name:"ã‚«ãƒ¼",   color:"red",    type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:1, name:"ãƒ«ãƒ‘ãƒ—", color:"purple", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:2, name:"ãƒ«ãƒ–ãƒ–", color:"blue",   type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:3, name:"ãƒ­ã‚¤ã‚¨", color:"yellow", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:4, name:"ãƒ­ãƒ¼ã‚·", color:"white",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:5, name:"ãƒ‰ãƒªãƒŸ", color:"green",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},

  // æ—¢å­˜SR/L
  {id:6, name:"çµ‚ç„‰ã®å¤§ç«",          color:"red",    type:"song",      cost:7, rarity:"SR", inkable:false, effect:"boardwipe"},
  {id:7, name:"æ°·çµã®å¥³ç‹ã‚±ãƒ«ã‚µ",    color:"purple", type:"character", cost:8, atk:4, hp:6, lore:3, rarity:"L",  inkable:false, effect:"freeze2", evolveCost:6},
  {id:8, name:"ä¼èª¬ã®å‹‡è€…ã‚¤ãƒ•ãƒªãƒ¼ãƒˆ", color:"red",   type:"character", cost:8, atk:5, hp:5, lore:4, rarity:"L",  inkable:true,  evade:true},

  // èµ¤
  {id:9,  name:"ã‚¿ã‚¤ã‚¿ãƒ³",        color:"red",    type:"character", cost:5, atk:6, hp:5, lore:0, rarity:"SR", inkable:true, mustAttack:true, rush:true},
  {id:10, name:"ãƒã‚¸ãƒ§ãƒ‰ãƒ©",      color:"red",    type:"character", cost:9, atk:7, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"destroyOnSummon"},
  {id:11, name:"ãã‚ãã‚ãƒ€ãƒƒã‚¯",  color:"red",    type:"character", cost:2, atk:2, hp:3, lore:1, rarity:"N",  inkable:true},

  // é’
  {id:12, name:"ã‚´ãƒ¼ã‚º",       color:"blue",   type:"character", cost:7, atk:3, hp:6, lore:2, rarity:"L",  inkable:false, effect:"toInkOnSummon"},
  {id:13, name:"ãƒªãƒ³",         color:"blue",   type:"character", cost:4, atk:2, hp:4, lore:1, rarity:"L",  inkable:true},
  {id:14, name:"ã‚‰ãŸã°ã‚",     color:"blue",   type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N",  inkable:true},
  {id:15, name:"ã‚ã‚Šã®ã¾ã¾ã§", color:"blue",   type:"song",      cost:5, rarity:"SR", inkable:true,  effect:"songToInk1"},

  // é»„
  {id:16, name:"ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«",   color:"yellow", type:"character", cost:4, atk:1, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"pretzelHealDraw"},
  {id:17, name:"ãƒŸã‚¹ã‚¿ãƒ¼ãƒã‚¸",   color:"yellow", type:"character", cost:3, atk:2, hp:5, lore:1, rarity:"N",  inkable:true},
  {id:18, name:"ãƒ•ãƒ³ãƒãƒ¼",       color:"yellow", type:"character", cost:4, atk:3, hp:5, lore:1, rarity:"N",  inkable:true},
  {id:19, name:"ã‚¢ãƒªã‚¨ãƒŠã‚¤",     color:"yellow", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"SR", inkable:true,  effect:"arienaiSearchSong", songPower:5},

  // ç·‘
  {id:20, name:"ã‚¸ãƒ¼ãƒ¦ãƒ¼",     color:"green",    type:"character", cost:6, atk:3, hp:4, lore:2, rarity:"SR", inkable:false, effect:"bounceOnSummon"},
  {id:21, name:"ã‚¨ãƒ³ãƒãƒ³ã‚¹",   color:"green",    type:"character", cost:4, atk:3, hp:3, lore:3, rarity:"N",  inkable:true},
  {id:22, name:"èƒŒç­‹ãŒãƒ’ãƒ¤ãƒª", color:"green",    type:"song",      cost:2, rarity:"N",  inkable:true,  effect:"discard1"},

  // ç´«
  {id:23, name:"ã»ã†ã",               color:"purple", type:"character", cost:2, atk:2, hp:2, lore:1, rarity:"N", inkable:true},
  {id:24, name:"ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³",           color:"purple", type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N", inkable:true},
  {id:25, name:"ãƒ†ã‚£ãƒ©ãƒŸã‚¹ã®ãŸãã‚‰ã¿", color:"purple", type:"song",      cost:3, rarity:"R", inkable:true, effect:"draw3"},
  {id:26, name:"ãƒã‚¸ãƒ§",               color:"purple", type:"character", cost:3, atk:2, hp:2, lore:1, rarity:"N", inkable:true, effect:"drawOnSummon1"},
  {id:27, name:"ã‚±ãƒ«ã‚µ",               color:"purple", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"N", inkable:true},

  // ç™½
  {id:28, name:"AHNW",        color:"white", type:"song",      cost:5, rarity:"SR", inkable:false, effect:"handReset7"},
  {id:29, name:"ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼", color:"white", type:"song",      cost:3, rarity:"R",  inkable:true,  effect:"damage3"},
  {id:30, name:"å‰£ã§åˆºã›",    color:"white", type:"song",      cost:5, rarity:"R",  inkable:false, effect:"aoe2"},
  {id:31, name:"ã‚¨ãƒ©ãƒƒã‚¿ç‹å­", color:"white", type:"character", cost:2, atk:1, hp:3, lore:1, rarity:"N", inkable:true,  effect:"frenzy2"}
];

/* ========== ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ ========== */
let stones = 0;
let collection = {};
let enchantedCollection = {};
let savedDecks = [[], [], []];
let currentDeckIndex = 0;
  /* ========== ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ç³» ========== */
function loadData() {
  stones = parseInt(localStorage.getItem("ds_stones") || "0", 10);
  collection = JSON.parse(localStorage.getItem("ds_collection") || "{}");
  enchantedCollection = JSON.parse(localStorage.getItem("ds_collection_enchanted") || "{}");

  const d3 = localStorage.getItem("ds_playerDecks");
  if (d3) {
    try {
      const parsed = JSON.parse(d3);
      if (Array.isArray(parsed) && parsed.length === 3) savedDecks = parsed;
    } catch(e){}
  }

  updateStoneDisplays();
  updatePlayerDeckButtons();
}
function saveStones(){ localStorage.setItem("ds_stones", String(stones)); updateStoneDisplays(); }
function saveCollection(){ localStorage.setItem("ds_collection", JSON.stringify(collection)); }
function saveEnchantedCollection(){ localStorage.setItem("ds_collection_enchanted", JSON.stringify(enchantedCollection)); }
function savePlayerDecks(){ localStorage.setItem("ds_playerDecks", JSON.stringify(savedDecks)); }

function updateStoneDisplays() {
  document.getElementById("stoneCount")?.textContent = stones;
  document.getElementById("shopStoneCount")?.textContent = stones;
  document.getElementById("packStoneCount")?.textContent = stones;
}

/* ========== ã‚·ãƒ§ãƒƒãƒ— ========== */
function showShop(){ updateStoneDisplays(); showScreen("shop"); }
function debugAddStones(){ stones += 100; saveStones(); }

/* ========== ã‚¬ãƒãƒ£ ========== */
function showPack(){ updateStoneDisplays(); document.getElementById("packResult").innerHTML=""; showScreen("pack"); }

/* ã‚«ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆï¼ˆE/é€šå¸¸å…±é€šï¼‰ */
function makeCardInstance(base, isEnchanted=false){
  return {
    id: base.id,
    name: base.name,
    color: base.color,
    type: base.type,
    cost: base.cost,
    atk: base.atk || 0,
    hp: base.hp || 0,
    maxHp: base.hp || 0,
    lore: base.lore || 0,
    rarity: base.rarity,
    inkable: base.inkable ?? true,
    effect: base.effect || null,
    evolveCost: base.evolveCost || null,
    evade: base.evade || false,
    mustAttack: base.mustAttack || false,
    songPower: base.songPower || base.cost || 0,
    rush: base.rush || false,
    isEnchanted: !!isEnchanted,
    rest: false,
    frozen: false,
    summonTurn: 0
  };
}

/* ãƒãƒˆãƒ«ã¨åŒã˜ã‚«ãƒ¼ãƒ‰ãƒ‡ã‚¶ã‚¤ãƒ³ã§è¡¨ç¤ºï¼ˆãƒ‘ãƒƒã‚¯/ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ç”¨ï¼‰ */
function renderCardHtml(card){
  const classes = ["card", card.color];
  if(card.rest) classes.push("rest");
  if(card.isEnchanted) classes.push("enchanted");

  const rarityBadge = card.isEnchanted ? "E" : card.rarity;
  const atkHp = card.type === "character" ? `ATK:${card.atk} / HP:${card.hp}/${card.maxHp}` : "ã‚½ãƒ³ã‚°";
  const lorePart = card.type === "character" ? `ãƒ­ã‚¢:${card.lore}` : "";
  const inkSymbol = card.inkable ? "â—" : "Ã—";

  return `
    <div class="${classes.join(" ")}">
      <div class="card-header">
        <div class="card-cost">${card.cost}</div>
        <div class="card-name-header">${card.name}</div>
        <div class="card-inkable">${inkSymbol}</div>
      </div>
      <div class="card-illustration"></div>
      <div class="card-stats-row">
        <span>${atkHp}</span>
        <span>${lorePart}</span>
      </div>
      <div class="card-footer">
        <div>è‰²:${card.color} ï¼ ãƒ¬ã‚¢:${rarityBadge}</div>
      </div>
    </div>
  `;
}

function renderSingleCardDivFromBaseCard(baseCard, isEnchanted=false){
  const inst = makeCardInstance(baseCard, isEnchanted);
  const wrap = document.createElement("div");
  wrap.style.display="inline-block";
  wrap.style.margin="4px";
  wrap.innerHTML = renderCardHtml(inst);
  wrap.firstElementChild.onclick = ()=>showCardDetail(inst);
  return wrap;
}

function openPack(){
  const COST=5;
  if(stones < COST){ alert("ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼ˆ5å€‹å¿…è¦ï¼‰"); return; }
  stones -= COST; saveStones();

  const pulled=[];
  for(let i=0;i<5;i++){
    let isEnchanted=false;
    let baseCard=null;

    if(Math.random() < ENCHANTED_RATE){
      const l = cards.filter(c=>c.rarity==="L");
      if(l.length){ baseCard = l[Math.floor(Math.random()*l.length)]; isEnchanted=true; }
    }
    if(!baseCard){
      const r=Math.random();
      let rarity = (r<0.78)?"N":(r<0.90)?"R":(r<0.98)?"SR":"L";
      let candidates = cards.filter(c=>c.rarity===rarity);
      if(!candidates.length){
        for(const rr of ["L","SR","R","N"]){
          const list = cards.filter(c=>c.rarity===rr);
          if(list.length){ candidates=list; break; }
        }
      }
      baseCard = candidates[Math.floor(Math.random()*candidates.length)];
    }

    pulled.push({card:baseCard,isEnchanted});

    collection[baseCard.id] = (collection[baseCard.id]||0)+1;
    if(isEnchanted){
      enchantedCollection[baseCard.id] = (enchantedCollection[baseCard.id]||0)+1;
    }
  }
  saveCollection(); saveEnchantedCollection();

  const pr=document.getElementById("packResult");
  pr.innerHTML="";
  pulled.forEach(obj=> pr.appendChild(renderSingleCardDivFromBaseCard(obj.card, obj.isEnchanted)));
}

/* ========== ã‚«ãƒ¼ãƒ‰è©³ç´° ========== */
function getCardEffectText(card){
  switch(card.effect){
    case "boardwipe": return "å ´ã®ã‚­ãƒ£ãƒ©ã‚’å…¨ã¦é€€å ´ã•ã›ã‚‹ï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "draw3": return "ã‚«ãƒ¼ãƒ‰ã‚’3æšå¼•ãï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "discard1": return "ç›¸æ‰‹ã¯æ‰‹æœ­ã‚’1æšæ¨ã¦ã‚‹ï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "songToInk1": return "è‡ªåˆ†ã®å ´ã®ã‚­ãƒ£ãƒ©ã‚’1ä½“é¸ã³ã€é€€å ´ã•ã›ã¦ã‚¤ãƒ³ã‚¯ã«ç½®ãï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "handReset7": return "ãŠäº’ã„æ‰‹æœ­ã‚’å…¨ã¦æ¨ã¦ã€7æšå¼•ãï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "damage3": return "ç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "aoe2": return "ç›¸æ‰‹ã®å ´ã®ã‚­ãƒ£ãƒ©å…¨ä½“ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆã‚½ãƒ³ã‚°ï¼‰ã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯ç ´å£Šã•ã‚Œã‚‹ã€‚";
    case "pretzelHealDraw": return "ç™»å ´æ™‚ï¼šè‡ªåˆ†ã®å ´ã®ã‚­ãƒ£ãƒ©åˆè¨ˆ3ãƒ€ãƒ¡ãƒ¼ã‚¸ã¾ã§å›å¾©ã€‚å›å¾©ã—ãŸæ•°ã ã‘ãƒ‰ãƒ­ãƒ¼ï¼ˆ0ã€œ3ï¼‰ã€‚";
    case "arienaiSearchSong": return "ç™»å ´æ™‚ï¼šãƒ‡ãƒƒã‚­ã®ä¸Š4æšã‚’è¦‹ã¦ã€ã‚½ãƒ³ã‚°ã‚’1æšã¾ã§æ‰‹æœ­ã¸ã€‚æ®‹ã‚Šã¯ä¸‹ã¸ã€‚æ­Œå£°5ã€‚";
    case "drawOnSummon1": return "ç™»å ´æ™‚ï¼š1æšãƒ‰ãƒ­ãƒ¼ã€‚";
    case "bounceOnSummon": return "ç™»å ´æ™‚ï¼šç›¸æ‰‹ã®å ´ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’æ‰‹æœ­ã«æˆ»ã—ã¦ã‚ˆã„ã€‚";
    case "toInkOnSummon": return "ç™»å ´æ™‚ï¼šæ‰‹æœ­ã‹ã‚‰1æšã‚’ã‚¤ãƒ³ã‚¯ã«ç½®ã„ã¦ã‚ˆã„ï¼ˆåŠ¹æœã«ã‚ˆã‚‹ã‚¤ãƒ³ã‚¯åŒ–ãªã®ã§Ã—ã§ã‚‚OKï¼‰ã€‚";
    case "freeze2": return "ç™»å ´æ™‚ï¼šç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’æœ€å¤§2ä½“å‡çµï¼ˆæ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³é–‹å§‹ã¾ã§è¡Œå‹•ã§ããªã„ï¼‰ã€‚";
    case "destroyOnSummon": return "ç™»å ´æ™‚ï¼šç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã‚’é€€å ´ã•ã›ã‚‹ã€‚";
  }
  if(card.id===13) return "ã“ã®ã‚­ãƒ£ãƒ©ãŒå ´ã«ã„ã‚‹é–“ã€è‡ªåˆ†ã¯1ã‚¿ãƒ¼ãƒ³ã«ç½®ã‘ã‚‹ã‚¤ãƒ³ã‚¯ãŒ+1ã€‚";
  if(card.effect==="frenzy2") return "ç°çŒ›2ï¼šãƒãƒ£ãƒ¬ãƒ³ã‚¸æ™‚ATK+2ã€‚";
  return "ç‰¹ã«ãªã—ï¼ˆåŠ¹æœã¯ä»Šå¾Œæ‹¡å¼µï¼‰";
}

function showCardDetail(card){
  const overlay=document.getElementById("cardDetailOverlay");
  const content=document.getElementById("cardDetailContent");
  if(!overlay||!content) return;

  const rarityDisp = card.isEnchanted ? "Eï¼ˆã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒ†ãƒƒãƒ‰ï¼‰" : card.rarity;
  const effectText = getCardEffectText(card);

  const statsPart = (card.type==="character")
    ? `<div style="margin-bottom:4px;">ATK:${card.atk} / HP:${card.hp}/${card.maxHp} / ãƒ­ã‚¢:${card.lore}</div>`
    : `<div style="margin-bottom:4px;">ã‚½ãƒ³ã‚°ï¼ˆã‚³ã‚¹ãƒˆ:${card.cost}ï¼‰</div>`;

  content.innerHTML = `
    <div style="font-weight:bold; margin-bottom:4px;">${card.name}</div>
    <div style="font-size:12px; margin-bottom:4px;">
      è‰²:${card.color} ï¼ ç¨®é¡:${card.type} ï¼ ã‚³ã‚¹ãƒˆ:${card.cost} ï¼ ãƒ¬ã‚¢:${rarityDisp}
    </div>
    ${statsPart}
    <div style="font-size:12px; white-space:pre-wrap;">${effectText}</div>
  `;
  overlay.style.display="block";
}
function closeCardDetail(){ document.getElementById("cardDetailOverlay").style.display="none"; }
function showCardDetailById(id){
  const base=cards.find(c=>c.id===id);
  if(!base) return;
  showCardDetail(makeCardInstance(base,false));
}

/* ========== ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ ========== */
function openCollection(){
  const list=document.getElementById("collectionList");
  list.innerHTML="";
  cards.forEach(c=>{
    const cnt = collection[c.id]||0;
    const eCnt = enchantedCollection[c.id]||0;

    const row=document.createElement("div");
    row.style.display="flex";
    row.style.alignItems="center";
    row.style.gap="8px";
    row.style.marginBottom="4px";

    row.appendChild(renderSingleCardDivFromBaseCard(c,false));

    const info=document.createElement("div");
    info.style.fontSize="12px";
    info.innerHTML = `
      <div>${c.name}</div>
      <div>è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity}</div>
      <div>æ‰€æŒæšæ•°: é€šå¸¸Ã—${cnt} ${eCnt>0 ? "ï¼ EÃ—"+eCnt : ""}</div>
    `;
    row.appendChild(info);
    list.appendChild(row);
  });
  showScreen("collection");
}

/* ========== ãƒ‡ãƒƒã‚­ç·¨é›† ========== */
let deckCountsNormal = {};
let deckCountsEnchanted = {};
function openDeckBuilder(index){
  if(typeof index==="number") currentDeckIndex=index;
  rebuildDeckEditor();
  showScreen("deck");
}
function switchDeck(idx){ currentDeckIndex=idx; rebuildDeckEditor(); }

function rebuildDeckEditor(){
  deckCountsNormal={}; deckCountsEnchanted={};
  const current = savedDecks[currentDeckIndex] || [];
  current.forEach(entry=>{
    if(entry && typeof entry==="object"){
      const id=entry.id;
      if(entry.isEnchanted) deckCountsEnchanted[id]=(deckCountsEnchanted[id]||0)+1;
      else deckCountsNormal[id]=(deckCountsNormal[id]||0)+1;
    }
  });

  document.getElementById("currentDeckLabel").textContent = (currentDeckIndex+1);

  const area=document.getElementById("deckCardList");
  let html="";
  cards.forEach(c=>{
    const haveN=collection[c.id]||0;
    const haveE=enchantedCollection[c.id]||0;
    const inN=deckCountsNormal[c.id]||0;
    const inE=deckCountsEnchanted[c.id]||0;

    html += `
      <div class="card-box ${c.color}" onclick="showCardDetailById(${c.id})">
        <div class="card-name">${c.name}</div>
        <div class="card-stats">è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type} / ã‚³ã‚¹ãƒˆ:${c.cost}</div>
        <div class="card-stats">æ‰€æŒ: é€šå¸¸Ã—${haveN} ï¼ EÃ—${haveE}</div>
        <div class="card-stats">ãƒ‡ãƒƒã‚­: é€šå¸¸Ã—<span id="deck-n-${c.id}">${inN}</span> ï¼ EÃ—<span id="deck-e-${c.id}">${inE}</span></div>
        <button class="btn small" onclick="event.stopPropagation(); changeDeckCount(${c.id}, -1, false)">ï¼é€šå¸¸</button>
        <button class="btn small" onclick="event.stopPropagation(); changeDeckCount(${c.id}, +1, false)">ï¼‹é€šå¸¸</button>
        <button class="btn small" onclick="event.stopPropagation(); changeDeckCount(${c.id}, -1, true)">ï¼E</button>
        <button class="btn small" onclick="event.stopPropagation(); changeDeckCount(${c.id}, +1, true)">ï¼‹E</button>
      </div>`;
  });
  area.innerHTML=html;
}
function isBasicCard(id){ return id>=0 && id<=5; }

function getDeckColorsFromTwoCounts(){
  const colors=new Set();
  function addFrom(counts){
    Object.entries(counts).forEach(([idStr,cnt])=>{
      if(cnt>0){
        const base=cards.find(c=>c.id===parseInt(idStr,10));
        if(base) colors.add(base.color);
      }
    });
  }
  addFrom(deckCountsNormal); addFrom(deckCountsEnchanted);
  return colors;
}

function changeDeckCount(cardId, diff, isEnchanted){
  const counts = isEnchanted ? deckCountsEnchanted : deckCountsNormal;
  const before = counts[cardId] || 0;
  let cur = before + diff;
  if(cur<0) cur=0;

  const haveLimit = isEnchanted ? (enchantedCollection[cardId]||0) : (collection[cardId]||0);
  if(cur>haveLimit){ alert("æ‰€æŒæšæ•°ã‚’è¶…ãˆã¦å…¥ã‚Œã‚‰ã‚Œã¾ã›ã‚“"); cur=haveLimit; }
  counts[cardId]=cur;

  const colors = getDeckColorsFromTwoCounts();
  if(colors.size>2){
    counts[cardId]=before;
    alert("ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ã§ã™");
  }

  const totalSame = (deckCountsNormal[cardId]||0) + (deckCountsEnchanted[cardId]||0);
  if(!isBasicCard(cardId) && totalSame>4){
    counts[cardId]=before;
    if(diff>0) alert("åŒåã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ï¼ˆé€šå¸¸+Eåˆè¨ˆï¼‰");
  }

  document.getElementById("deck-n-"+cardId).textContent = deckCountsNormal[cardId]||0;
  document.getElementById("deck-e-"+cardId).textContent = deckCountsEnchanted[cardId]||0;
}

function saveDeck(){
  const newDeck=[];
  Object.entries(deckCountsNormal).forEach(([idStr,cnt])=>{
    const id=parseInt(idStr,10);
    for(let i=0;i<cnt;i++) newDeck.push({id,isEnchanted:false});
  });
  Object.entries(deckCountsEnchanted).forEach(([idStr,cnt])=>{
    const id=parseInt(idStr,10);
    for(let i=0;i<cnt;i++) newDeck.push({id,isEnchanted:true});
  });
  if(newDeck.length<60){ alert(`ãƒ‡ãƒƒã‚­ã¯60æšä»¥ä¸Šã«ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨${newDeck.length}æšï¼‰`); return; }
  savedDecks[currentDeckIndex]=newDeck;
  savePlayerDecks();
  alert(`ãƒ‡ãƒƒã‚­${currentDeckIndex+1}ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ï¼ˆ${newDeck.length}æšï¼‰`);
  updatePlayerDeckButtons();
}

/* ========== CPUè¨­å®š ========== */
let cpuStrength="normal";
let cpuSelectedColors=[];
let playerDeckMode="default";

function openCpuConfig(){ updateCpuButtons(); updatePlayerDeckButtons(); showScreen("cpu"); }
function setCpuStrength(s){ cpuStrength=s; updateCpuButtons(); }
function setCpuColor(color){
  const idx=cpuSelectedColors.indexOf(color);
  if(idx>=0) cpuSelectedColors.splice(idx,1);
  else{
    if(cpuSelectedColors.length>=2){ alert("CPUãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§"); return; }
    cpuSelectedColors.push(color);
  }
  updateCpuButtons();
}
function updateCpuButtons(){
  document.getElementById("btnCpuNormal").classList.toggle("toggle-selected", cpuStrength==="normal");
  document.getElementById("btnCpuStrong").classList.toggle("toggle-selected", cpuStrength==="strong");
  document.getElementById("btnCpuGod").classList.toggle("toggle-selected", cpuStrength==="god");

  ["red","purple","blue","yellow","white","green"].forEach(c=>{
    const btnId="cpu"+c.charAt(0).toUpperCase()+c.slice(1);
    document.getElementById(btnId)?.classList.toggle("toggle-selected", cpuSelectedColors.includes(c));
  });
}
function hasCustomDeck(index){ return Array.isArray(savedDecks[index]) && savedDecks[index].length>0; }
function updatePlayerDeckButtons(){
  const btnDef=document.getElementById("btnPlayerDefault");
  const btn1=document.getElementById("btnDeck1");
  const btn2=document.getElementById("btnDeck2");
  const btn3=document.getElementById("btnDeck3");

  btnDef.classList.toggle("toggle-selected", playerDeckMode==="default");
  btn1.classList.toggle("toggle-selected", playerDeckMode==="deck1");
  btn2.classList.toggle("toggle-selected", playerDeckMode==="deck2");
  btn3.classList.toggle("toggle-selected", playerDeckMode==="deck3");

  [btn1,btn2,btn3].forEach((b,i)=>{
    if(!hasCustomDeck(i)){ b.disabled=true; b.textContent=`ãƒ‡ãƒƒã‚­${i+1}ï¼ˆæœªä¿å­˜ï¼‰`; }
    else { b.disabled=false; b.textContent=`ãƒ‡ãƒƒã‚­${i+1}`; }
  });
}
function selectPlayerDeck(mode){
  if(mode.startsWith("deck")){
    const idx=parseInt(mode.slice(4),10)-1;
    if(!hasCustomDeck(idx)){ alert(`ã¾ãšãƒ‡ãƒƒã‚­${idx+1}ã‚’ä¿å­˜ã—ã¦ãã ã•ã„`); return; }
  }
  playerDeckMode=mode;
  updatePlayerDeckButtons();
}

/* ========== å…±é€šãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ========== */
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
function sideLabel(side){ return side==="player" ? "è‡ªåˆ†" : "ç›¸æ‰‹"; }

function buildDeckInstancesFromSaved(saved){
  const result=[];
  (saved||[]).forEach(entry=>{
    if(entry && typeof entry==="object"){
      const base=cards.find(c=>c.id===entry.id);
      if(base) result.push(makeCardInstance(base, !!entry.isEnchanted));
    }
  });
  shuffle(result);
  return result;
}

function makeDefaultDeck(){
  const ids=[];
  for(let i=0;i<12;i++) ids.push(0);
  for(let i=0;i<8;i++) ids.push(11);
  for(let i=0;i<4;i++) ids.push(9);
  for(let i=0;i<4;i++) ids.push(20);
  for(let i=0;i<4;i++) ids.push(21);
  for(let i=0;i<4;i++) ids.push(22);
  for(let i=0;i<4;i++) ids.push(6);
  for(let i=0;i<4;i++) ids.push(8);
  while(ids.length<60) ids.push(0);
  return ids;
}

function addLog(text){
  const logEl=document.getElementById("log");
  if(!logEl) return;
  const div=document.createElement("div");
  div.textContent=text;
  logEl.appendChild(div);
  logEl.scrollTop=logEl.scrollHeight;
}

/* ========== ãƒãƒˆãƒ«çŠ¶æ…‹ ========== */
let battle=null;

/* ===== å›ºå®šãƒ«ãƒ¼ãƒ« =====
- ã‚¤ãƒ³ã‚¯ã¯ã€Œæ‰‹æœ­ã‹ã‚‰ã‚¤ãƒ³ã‚¯åŒ–ã€ã§å¢—ãˆã‚‹ï¼ˆåŸºæœ¬1æš/ã‚¿ãƒ¼ãƒ³ï¼‰ã€‚ãƒªãƒ³ãŒå ´ã«ã„ã‚‹ã¨+1ã€‚
- ã‚¿ãƒ¼ãƒ³é–‹å§‹ãƒ‰ãƒ­ãƒ¼ï¼šå¿…ãš1æšã€‚ãŸã ã—å…ˆè¡Œã®1ã‚¿ãƒ¼ãƒ³ç›®ã¯0æšã€‚
- è¿½åŠ ãƒ‰ãƒ­ãƒ¼ã¯ã‚«ãƒ¼ãƒ‰åŠ¹æœã®ã¿ï¼ˆã“ã®åˆ¶é™ã‚’ç„¡è¦–ï¼‰
- ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã¯ã€Œç›¸æ‰‹ã®ãƒ¬ã‚¹ãƒˆã‚­ãƒ£ãƒ©ã€ã«ã—ã‹ã§ããªã„
- ã‚½ãƒ³ã‚°ï¼šã‚­ãƒ£ãƒ©ã§æ­Œãˆã°ã‚³ã‚¹ãƒˆè¸ã¿å€’ã—å¯ï¼ˆã‚³ã‚¹ãƒˆæ¡ä»¶ã¯â€œåŒç­‰ä»¥ä¸Šã®ã‚³ã‚¹ãƒˆâ€ï¼‰
====================== */

function newSideState(deck){
  return {
    deck,
    hand: [],
    field: [],
    inkZone: [],        // å®Ÿä½“ã®ã‚¤ãƒ³ã‚¯ã‚«ãƒ¼ãƒ‰
    inkCurrent: 0,
    inkMax: 0,
    lore: 0,
    turnDrawn: false,
    inkPlacedThisTurn: 0
  };
}

function rebuildInkNumbers(side){
  const s=battle[side];
  s.inkMax = s.inkZone.length;
  if(s.inkCurrent > s.inkMax) s.inkCurrent = s.inkMax;
}

function hasLinOnField(side){
  return battle?.[side]?.field?.some(c=>c.id===ID_LIN) || false;
}

function inkPlacementsAllowed(side){
  return 1 + (hasLinOnField(side) ? 1 : 0);
}

/* ========== ãƒ‰ãƒ­ãƒ¼ ========== */
function drawCardFor(side, reason="normal"){
  const s=battle?.[side];
  if(!s) return false;
  if(s.deck.length===0){ addLog(`${sideLabel(side)}ã®ãƒ‡ãƒƒã‚­ãŒåˆ‡ã‚ŒãŸï¼`); return false; }

  // é€šå¸¸ãƒ‰ãƒ­ãƒ¼åˆ¶é™ï¼ˆåŠ¹æœãƒ‰ãƒ­ãƒ¼ã¯ç„¡è¦–ï¼‰
  if(reason==="normal"){
    if(s.turnDrawn) return false;
    // å…ˆè¡Œ1Tã¯ãƒ‰ãƒ­ãƒ¼ãªã—
    if(battle.firstPlayer===side && battle.turnCount===1) return false;
    s.turnDrawn=true;
  }

  const card=s.deck.shift();
  s.hand.push(card);
  return true;
}

/* ========== è¡Œå‹•å¯èƒ½åˆ¤å®š ========== */
function canCharacterAct(card){
  if(!card) return false;
  if(card.rest) return false;
  if(card.frozen) return false;
  return true;
}
function canCharacterAttack(side, card){
  if(!canCharacterAct(card)) return false;
  // å¬å–šé…”ã„ï¼šå¬å–šã‚¿ãƒ¼ãƒ³ã¯æ”»æ’ƒä¸å¯ï¼ˆçªé€²ã¯OKï¼‰
  if(!card.rush && card.summonTurn === battle.turnCount) return false;
  return true;
}

/* ========== å‹æ•—ï¼ˆãƒ­ã‚¢20ï¼‰ ========== */
function checkWin(){
  if(!battle) return false;
  if(battle.player.lore>=20){ alert("ãƒ­ã‚¢20åˆ°é”ï¼ã‚ãªãŸã®å‹ã¡ï¼"); endBattleToMenu(); return true; }
  if(battle.cpu.lore>=20){ alert("ç›¸æ‰‹ãŒãƒ­ã‚¢20ã«åˆ°é”â€¦è² ã‘ã¦ã—ã¾ã£ãŸã€‚"); endBattleToMenu(); return true; }
  return false;
}

/* ========== ãƒãƒˆãƒ«é–‹å§‹ ========== */
function buildCpuDeck(selectedColors){
  if(!selectedColors || selectedColors.length===0) selectedColors=["red","purple"];
  if(selectedColors.length===1) selectedColors=[selectedColors[0],selectedColors[0]];
  const pool=cards.filter(c=>selectedColors.includes(c.color));
  const deckEntries=[];
  while(deckEntries.length<60){
    const base=pool[Math.floor(Math.random()*pool.length)];
    deckEntries.push({id:base.id,isEnchanted:false});
  }
  shuffle(deckEntries);
  return buildDeckInstancesFromSaved(deckEntries);
}

function startBattle(){
  if(cpuSelectedColors.length===0){
    if(!confirm("CPUã®è‰²ãŒæœªé¸æŠã§ã™ã€‚èµ¤ï¼‹ç´«ã§å§‹ã‚ã¾ã™ã‹ï¼Ÿ")) return;
    cpuSelectedColors=["red","purple"];
    updateCpuButtons();
  }

  let playerDeckDef;
  if(playerDeckMode==="default"){
    const ids=makeDefaultDeck();
    playerDeckDef=ids.map(id=>({id,isEnchanted:false}));
  }else if(playerDeckMode==="deck1") playerDeckDef=savedDecks[0]||[];
  else if(playerDeckMode==="deck2") playerDeckDef=savedDecks[1]||[];
  else if(playerDeckMode==="deck3") playerDeckDef=savedDecks[2]||[];
  else playerDeckDef=[];

  const playerDeck=buildDeckInstancesFromSaved(playerDeckDef);
  if(playerDeck.length<60){ alert("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒƒã‚­ãŒ60æšæœªæº€ã§ã™"); return; }

  const cpuDeck=buildCpuDeck(cpuSelectedColors);

  battle={
    turnCount: 1,
    currentPlayer: "player",
    firstPlayer: "player",     // å…ˆè¡Œï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å›ºå®šï¼ˆå¿…è¦ãªã‚‰å¾Œã§ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã§ãã‚‹ï¼‰
    cpuStrength,
    player: newSideState(playerDeck),
    cpu: newSideState(cpuDeck)
  };

  document.getElementById("log").innerHTML="";

  // åˆæœŸæ‰‹æœ­ï¼š7æšãšã¤
  for(let i=0;i<7;i++){ drawCardFor("player","effect"); drawCardFor("cpu","effect"); }

  // åˆæœŸã‚¤ãƒ³ã‚¯ï¼š0ï¼ˆæ‰‹æœ­ã‹ã‚‰ç½®ãï¼‰
  rebuildInkNumbers("player");
  rebuildInkNumbers("cpu");

  showScreen("battle");
  addLog("ãƒãƒˆãƒ«é–‹å§‹ï¼");
  startTurn("player");
}

function endBattleToMenu(){ battle=null; showScreen("menu"); }

/* ========== ã‚¿ãƒ¼ãƒ³é–‹å§‹ï¼ˆè‡ªå‹•ãƒ‰ãƒ­ãƒ¼/ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥/ç½®ã‘ã‚‹ã‚¤ãƒ³ã‚¯å›æ•°ãƒªã‚»ãƒƒãƒˆï¼‰ ========== */
function startTurn(side){
  battle.currentPlayer=side;

  // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ï¼šã‚¤ãƒ³ã‚¯å›å¾©ï¼ˆæœ€å¤§ï¼ã‚¤ãƒ³ã‚¯æšæ•°ã€ä¸Šé™ãªã—ï¼‰
  rebuildInkNumbers(side);
  battle[side].inkCurrent = battle[side].inkMax;

  // ãƒ¬ã‚¹ãƒˆè§£é™¤ï¼†å‡çµè§£é™¤ï¼ˆå‡çµã¯ã€Œæ¬¡ã®ç›¸æ‰‹ã‚¿ãƒ¼ãƒ³é–‹å§‹ã¾ã§ã€ãªã®ã§é–‹å§‹ã§è§£é™¤ï¼‰
  battle[side].field.forEach(c=>{
    c.rest=false;
    if(c.frozen) c.frozen=false;
  });

  battle[side].turnDrawn=false;
  battle[side].inkPlacedThisTurn=0;

  addLog(`=== ${sideLabel(side)}ã®ã‚¿ãƒ¼ãƒ³ ${battle.turnCount} ===`);

  // ã‚¿ãƒ¼ãƒ³é–‹å§‹ãƒ‰ãƒ­ãƒ¼ï¼ˆå…ˆè¡Œ1Tã¯0ï¼‰
  const drew = drawCardFor(side,"normal");
  if(drew) addLog(`${sideLabel(side)}ã¯ã‚¿ãƒ¼ãƒ³é–‹å§‹ã«1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
  else if(battle.firstPlayer===side && battle.turnCount===1) addLog(`${sideLabel(side)}ã¯å…ˆè¡Œ1ã‚¿ãƒ¼ãƒ³ç›®ã®ãŸã‚ãƒ‰ãƒ­ãƒ¼ã—ãªã„ã€‚`);

  updateBattleUI();

  if(side==="cpu"){
    cpuDoTurn();
  }
}

function endTurn(){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;

  addLog("è‡ªåˆ†ã¯ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ãŸã€‚");
  battle.turnCount += 1;
  startTurn("cpu");
}

/* ========== ã‚¤ãƒ³ã‚¯åŒ–ï¼ˆæ‰‹æœ­â†’ã‚¤ãƒ³ã‚¯ï¼‰ ========== */
function canInkCardFromHand(side, card){
  if(!card) return false;
  if(!card.inkable) return false; // âŒã‚«ãƒ¼ãƒ‰ï¼ˆinkable=falseï¼‰ã¯é€šå¸¸ã¯ç½®ã‘ãªã„
  const s=battle[side];
  return s.inkPlacedThisTurn < inkPlacementsAllowed(side);
}

function inkFromHand(side, handIndex, byEffect=false){
  const s=battle[side];
  const card=s.hand[handIndex];
  if(!card) return false;

  if(!byEffect){
    if(!canInkCardFromHand(side, card)){ alert("ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ã‚¤ãƒ³ã‚¯åŒ–ã§ããªã„ï¼å›æ•°ä¸Šé™"); return false; }
    s.inkPlacedThisTurn++;
  }else{
    // åŠ¹æœã«ã‚ˆã‚‹ã‚¤ãƒ³ã‚¯åŒ–ã¯inkable=falseã§ã‚‚OKï¼ˆå›ºå®šãƒ«ãƒ¼ãƒ«ï¼‰
  }

  s.hand.splice(handIndex,1);
  s.inkZone.push(card);
  rebuildInkNumbers(side);
  s.inkCurrent += 1; // ç½®ã„ãŸåˆ†ã¯ãã®ã‚¿ãƒ¼ãƒ³ä½¿ãˆã‚‹
  addLog(`${sideLabel(side)}ã¯æ‰‹æœ­ã®ã€Œ${card.name}ã€ã‚’ã‚¤ãƒ³ã‚¯åŒ–ã—ãŸã€‚ï¼ˆã‚¤ãƒ³ã‚¯ ${s.inkCurrent}/${s.inkMax}ï¼‰`);
  updateBattleUI();
  return true;
}

/* ========== æˆ¦é—˜ï¼ˆãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼‰ : ãƒ¬ã‚¹ãƒˆã—ã¦ã‚‹ç›¸æ‰‹ã ã‘ ======== */
function resolveCombat(attackerSide, attackerIndex, defenderIndex){
  const atkSide=battle[attackerSide];
  const defSide=(attackerSide==="player")?battle.cpu:battle.player;

  const attacker=atkSide.field[attackerIndex];
  const defender=defSide.field[defenderIndex];
  if(!attacker || !defender) return false;

  // ãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆã¯å¿…ãšãƒ¬ã‚¹ãƒˆ
  if(!defender.rest) return false;

  if(!canCharacterAttack(attackerSide, attacker)) return false;

  addLog(`${sideLabel(attackerSide)}ã®ã€Œ${attacker.name}ã€ãŒ${sideLabel(attackerSide==="player"?"cpu":"player")}ã®ã€Œ${defender.name}ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`);

  const attackerAtk = attacker.atk + ((attacker.effect==="frenzy2") ? 2 : 0);
  defender.hp -= attackerAtk;
  attacker.hp -= defender.atk;

  attacker.rest=true;

  if(defender.hp<=0){
    addLog(`ã€Œ${defender.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
    defSide.field.splice(defenderIndex,1);
  }
  if(attacker.hp<=0){
    addLog(`ã€Œ${attacker.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
    atkSide.field.splice(attackerIndex,1);
  }
  return true;
}

/* ========== ã‚·ãƒ¼ã‚¯ï¼ˆãƒ­ã‚¢ç²å¾—ï¼ã‚«ãƒ¼ãƒ‰ã®ãƒ­ã‚¢å€¤ï¼‰ ========== */
function doSeek(side, fieldIndex){
  const s=battle[side];
  const card=s.field[fieldIndex];
  if(!card || !canCharacterAct(card)) return false;

  card.rest=true;
  s.lore += card.lore;
  addLog(`${sideLabel(side)}ã®ã€Œ${card.name}ã€ãŒã‚·ãƒ¼ã‚¯ã—ã€ãƒ­ã‚¢ãŒ${card.lore}å¢—ãˆãŸã€‚ï¼ˆè¨ˆ${s.lore}ï¼‰`);
  updateBattleUI();
  checkWin();
  return true;
}

/* ========== ã‚½ãƒ³ã‚°ï¼šæ­Œãˆã‚‹ã‚­ãƒ£ãƒ©ä¸€è¦§ï¼ˆã‚³ã‚¹ãƒˆæ¡ä»¶ï¼‰ ========== */
function listSingersForSong(side, song){
  const s=battle[side];
  const res=[];
  s.field.forEach((c, idx)=>{
    if(!canCharacterAct(c)) return;
    const power = c.songPower ?? c.cost;
    if(power >= song.cost){
      res.push({card:c, idx});
    }
  });
  return res;
}

/* ========== ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠè£œåŠ© ========== */
function pickTargetFromField(side, msg, filterFn=null){
  const field=battle?.[side]?.field || [];
  const candidates=[];
  field.forEach((c,i)=>{
    if(!filterFn || filterFn(c,i)) candidates.push({c,i});
  });
  if(candidates.length===0) return null;

  let text = msg + "\n";
  candidates.forEach((obj,k)=>{
    const c=obj.c;
    text += `${k}: ${c.name} (ATK:${c.atk} HP:${c.hp}/${c.maxHp} ${c.rest?"REST":""})\n`;
  });
  const pick = prompt(text, "0");
  if(pick===null) return null;
  const k = parseInt(pick,10);
  if(Number.isNaN(k) || k<0 || k>=candidates.length){ alert("é¸æŠãŒä¸æ­£"); return null; }
  return candidates[k].i;
}

function dealDamageTo(side, idx, amount){
  const f=battle[side].field;
  const c=f[idx];
  if(!c) return;
  c.hp -= amount;
  addLog(`${sideLabel(side)}ã®ã€Œ${c.name}ã€ã«${amount}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆHP ${Math.max(0,c.hp)}/${c.maxHp}ï¼‰`);
  if(c.hp<=0){
    addLog(`ã€Œ${c.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
    f.splice(idx,1);
  }
}

/* ========== ã‚½ãƒ³ã‚°åŠ¹æœ ========== */
function applySongEffect(casterSide, song){
  const enemySide = (casterSide==="player") ? "cpu" : "player";

  switch(song.effect){
    case "boardwipe":{
      battle.player.field=[];
      battle.cpu.field=[];
      addLog("å ´ã®ã‚­ãƒ£ãƒ©ãŒå…¨ã¦é€€å ´ã—ãŸã€‚");
      break;
    }
    case "draw3":{
      for(let i=0;i<3;i++) drawCardFor(casterSide,"effect");
      addLog(`${sideLabel(casterSide)}ã¯3æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
      break;
    }
    case "discard1":{
      const enemy=battle[enemySide];
      if(enemy.hand.length===0){ addLog(`${sideLabel(enemySide)}ã®æ‰‹æœ­ã¯0æšã ã£ãŸã€‚`); break; }
      if(enemySide==="player"){
        let msg="æ¨ã¦ã‚‹æ‰‹æœ­ã‚’ç•ªå·ã§é¸ã‚“ã§ãã ã•ã„\n";
        enemy.hand.forEach((c,i)=> msg+=`${i}: ${c.name}\n`);
        const pick=prompt(msg,"0"); if(pick===null) break;
        const idx=parseInt(pick,10);
        if(Number.isNaN(idx)||idx<0||idx>=enemy.hand.length){ alert("ä¸æ­£"); break; }
        const removed=enemy.hand.splice(idx,1)[0];
        addLog(`è‡ªåˆ†ã¯ã€Œ${removed.name}ã€ã‚’æ¨ã¦ãŸã€‚`);
      }else{
        // é¬¼AIï¼šæ¨ã¦ã•ã›ãŸã„ï¼é«˜ã‚³ã‚¹ãƒˆå„ªå…ˆã§è½ã¨ã™
        let idx=0;
        for(let i=1;i<enemy.hand.length;i++){
          if(enemy.hand[i].cost > enemy.hand[idx].cost) idx=i;
        }
        const removed=enemy.hand.splice(idx,1)[0];
        addLog(`ç›¸æ‰‹ã¯æ‰‹æœ­ã‚’1æšæ¨ã¦ãŸã€‚ï¼ˆ${removed.name}ï¼‰`);
      }
      break;
    }
    case "songToInk1":{
      const caster=battle[casterSide];
      if(caster.field.length===0){ addLog(`${sideLabel(casterSide)}ã®å ´ã«ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ä¸ç™ºã€‚`); break; }

      let idx;
      if(casterSide==="player"){
        idx = pickTargetFromField(casterSide, "ã‚¤ãƒ³ã‚¯ã«ã™ã‚‹ï¼ˆé€€å ´ã•ã›ã‚‹ï¼‰è‡ªåˆ†ã®å ´ã®ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„");
        if(idx===null) break;
      }else{
        // é¬¼AIï¼šãƒ­ã‚¢ãŒä½ã„/ä»•äº‹ãŒå°‘ãªã„é †ã«ã‚¤ãƒ³ã‚¯åŒ–
        idx = 0;
        for(let i=1;i<caster.field.length;i++){
          const a=caster.field[i], b=caster.field[idx];
          const scoreA = (a.lore*2) + a.atk + a.hp;
          const scoreB = (b.lore*2) + b.atk + b.hp;
          if(scoreA < scoreB) idx=i;
        }
      }

      const chosen = caster.field.splice(idx,1)[0];
      caster.inkZone.push(chosen);
      rebuildInkNumbers(casterSide);
      caster.inkCurrent += 1;
      addLog(`${sideLabel(casterSide)}ã¯ã€Œ${chosen.name}ã€ã‚’é€€å ´ã•ã›ã€ã‚¤ãƒ³ã‚¯ã«ç½®ã„ãŸã€‚ï¼ˆã‚¤ãƒ³ã‚¯ ${caster.inkCurrent}/${caster.inkMax}ï¼‰`);
      break;
    }
    case "handReset7":{
      ["player","cpu"].forEach(side=>{
        battle[side].hand=[];
        for(let i=0;i<7;i++) drawCardFor(side,"effect");
      });
      addLog("ãŠäº’ã„æ‰‹æœ­ã‚’ãƒªã‚»ãƒƒãƒˆã—ã€7æšå¼•ã„ãŸã€‚");
      break;
    }
    case "damage3":{
      const enemy=battle[enemySide];
      if(enemy.field.length===0){ addLog(`${sideLabel(enemySide)}ã®å ´ã«ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ä¸ç™ºã€‚`); break; }

      let idx;
      if(casterSide==="player"){
        idx = pickTargetFromField(enemySide, "3ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„");
        if(idx===null) break;
      }else{
        // é¬¼AIï¼šå€’ã›ã‚‹ãªã‚‰å€’ã™ã€ç„¡ç†ãªã‚‰ãƒ­ã‚¢æœ€å¤§ã‚’ç‹™ã†
        idx = 0;
        let best=-999;
        for(let i=0;i<enemy.field.length;i++){
          const c=enemy.field[i];
          const killBonus = (c.hp<=3) ? 50 : 0;
          const v = killBonus + (c.lore*10) + c.atk*2 + (c.rest?2:0);
          if(v>best){ best=v; idx=i; }
        }
      }
      dealDamageTo(enemySide, idx, 3);
      break;
    }
    case "aoe2":{
      const enemy=battle[enemySide];
      if(enemy.field.length===0){ addLog(`${sideLabel(enemySide)}ã®å ´ã«ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ä¸ç™ºã€‚`); break; }
      for(let i=enemy.field.length-1;i>=0;i--) dealDamageTo(enemySide, i, 2);
      addLog(`${sideLabel(enemySide)}ã®å ´ã®å…¨ä½“ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`);
      break;
    }
  }
}

/* ========== å¬å–šæ™‚åŠ¹æœ ========== */
function handleOnSummonEffects(side, card){
  if(!card?.effect) return;
  const enemySide = (side==="player") ? "cpu" : "player";

  switch(card.effect){
    case "freeze2":{
      const enemy=battle[enemySide];
      if(enemy.field.length===0){ addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœï¼šå‡çµå¯¾è±¡ãªã—`); break; }

      if(side==="player"){
        const idx1 = pickTargetFromField(enemySide, "å‡çµã™ã‚‹ç›¸æ‰‹ã‚’æœ€å¤§2ä½“ã¾ã§ï¼š1ä½“ç›®ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§çµ‚äº†ï¼‰");
        if(idx1===null) break;
        enemy.field[idx1].frozen=true; addLog(`ã€Œ${card.name}ã€ã§ç›¸æ‰‹ã®ã€Œ${enemy.field[idx1].name}ã€ã‚’å‡çµã—ãŸã€‚`);

        const idx2 = pickTargetFromField(enemySide, "2ä½“ç›®ï¼ˆåŒã˜ã§ã‚‚OKï¼ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§çµ‚äº†ï¼‰");
        if(idx2===null) break;
        enemy.field[idx2].frozen=true; addLog(`ã€Œ${card.name}ã€ã§ç›¸æ‰‹ã®ã€Œ${enemy.field[idx2].name}ã€ã‚’å‡çµã—ãŸã€‚`);
      }else{
        // é¬¼AIï¼šãƒ­ã‚¢é«˜ã„é †ã«å‡çµ
        const sorted = enemy.field.map((c,i)=>({c,i})).sort((a,b)=> (b.c.lore-a.c.lore) || (b.c.atk-a.c.atk));
        sorted.slice(0,2).forEach(obj=>{
          obj.c.frozen=true;
          addLog(`ç›¸æ‰‹ã®ã€Œ${card.name}ã€ã§è‡ªåˆ†ã®ã€Œ${obj.c.name}ã€ãŒå‡çµã—ãŸã€‚`);
        });
      }
      break;
    }

    case "destroyOnSummon":{
      const enemy=battle[enemySide];
      if(enemy.field.length===0){ addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœï¼šå¯¾è±¡ãªã—`); break; }
      let idx=0;
      // é¬¼AIï¼šãƒ­ã‚¢æœ€å¤§ã‚’é€€å ´
      if(side!=="player"){
        let best=-1;
        for(let i=0;i<enemy.field.length;i++){
          const c=enemy.field[i];
          const v=c.lore*100 + c.atk*3 + c.hp;
          if(v>best){ best=v; idx=i; }
        }
      }else{
        idx = pickTargetFromField(enemySide, "é€€å ´ã•ã›ã‚‹ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„");
        if(idx===null) break;
      }
      addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœã§ã€Œ${enemy.field[idx].name}ã€ã‚’é€€å ´ã•ã›ãŸã€‚`);
      enemy.field.splice(idx,1);
      break;
    }

    case "bounceOnSummon":{
      const enemy=battle[enemySide];
      if(enemy.field.length===0){ addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœï¼šå¯¾è±¡ãªã—`); break; }
      let idx=0;
      if(side==="player"){
        idx = pickTargetFromField(enemySide, "æ‰‹æœ­ã«æˆ»ã™ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„");
        if(idx===null) break;
      }else{
        // é¬¼AIï¼šãƒ­ã‚¢æœ€å¤§ã‚’æˆ»ã™
        let best=-1;
        for(let i=0;i<enemy.field.length;i++){
          const c=enemy.field[i];
          const v=c.lore*100 + c.atk*2 + c.hp;
          if(v>best){ best=v; idx=i; }
        }
      }
      const bounced = enemy.field.splice(idx,1)[0];
      battle[enemySide].hand.push(bounced);
      addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœã§ã€Œ${bounced.name}ã€ã‚’æ‰‹æœ­ã«æˆ»ã—ãŸã€‚`);
      break;
    }

    case "drawOnSummon1":{
      drawCardFor(side,"effect");
      addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœã§${sideLabel(side)}ã¯1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
      break;
    }

    case "toInkOnSummon":{
      const s=battle[side];
      if(s.hand.length===0){ addLog(`ã€Œ${card.name}ã€ã®åŠ¹æœï¼šæ‰‹æœ­ãŒãªã„ãŸã‚ä¸ç™º`); break; }

      if(side==="player"){
        let msg="ã‚¤ãƒ³ã‚¯ã«ç½®ãæ‰‹æœ­ã‚’ç•ªå·ã§é¸ã‚“ã§ãã ã•ã„ï¼ˆåŠ¹æœãªã®ã§Ã—ã§ã‚‚OKï¼‰\n";
        s.hand.forEach((c,i)=> msg+=`${i}: ${c.name} ${c.inkable?"":"(Ã—)"}\n`);
        const pick=prompt(msg,"0"); if(pick===null) break;
        const idx=parseInt(pick,10);
        if(Number.isNaN(idx)||idx<0||idx>=s.hand.length){ alert("ä¸æ­£"); break; }
        inkFromHand(side, idx, true);
      }else{
        // é¬¼AIï¼šä¸€ç•ªé‡ã„ã‚«ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ã‚¯ã¸ï¼ˆå®‰å®šåŒ–ï¼‰
        let idx=0;
        for(let i=1;i<s.hand.length;i++){
          if(s.hand[i].cost > s.hand[idx].cost) idx=i;
        }
        inkFromHand(side, idx, true);
      }
      break;
    }

    case "pretzelHealDraw":{
      // 3å›å¾©ã¾ã§åˆ†é…â†’ãã®å›å¾©é‡ã ã‘ãƒ‰ãƒ­ãƒ¼
      const s=battle[side];
      if(s.field.length===0){ addLog(`ã€Œ${card.name}ã€åŠ¹æœï¼šå¯¾è±¡ãªã—`); break; }

      let remaining=3;
      let healed=0;

      if(side==="player"){
        while(remaining>0){
          const idx = pickTargetFromField(side, `å›å¾©ã™ã‚‹è‡ªåˆ†ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆæ®‹ã‚Šå›å¾©${remaining}ã€‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§çµ‚äº†ï¼‰`);
          if(idx===null) break;
          const target=s.field[idx];
          const can = Math.min(remaining, target.maxHp - target.hp);
          if(can<=0){ alert("ãã®ã‚­ãƒ£ãƒ©ã¯å›å¾©ã§ããªã„"); continue; }
          const amt = parseInt(prompt(`ã€Œ${target.name}ã€ã‚’ä½•å›å¾©ï¼Ÿï¼ˆ1ã€œ${can}ï¼‰`, String(can))||"0",10);
          if(!amt || amt<1 || amt>can){ alert("ä¸æ­£"); continue; }
          target.hp += amt;
          remaining -= amt;
          healed += amt;
          addLog(`ã€Œ${target.name}ã€ã‚’${amt}å›å¾©ï¼ˆHP ${target.hp}/${target.maxHp}ï¼‰`);
        }
      }else{
        // é¬¼AIï¼šè½ã¡ãã†ãªé †ã«å›å¾©
        const order=s.field.map((c,i)=>({c,i})).sort((a,b)=> (a.c.hp-a.c.maxHp) - (b.c.hp-b.c.maxHp));
        for(const obj of order){
          if(remaining<=0) break;
          const t=obj.c;
          const can = Math.min(remaining, t.maxHp - t.hp);
          if(can<=0) continue;
          t.hp += can;
          remaining -= can;
          healed += can;
          addLog(`ç›¸æ‰‹ã¯ã€Œ${t.name}ã€ã‚’${can}å›å¾©ã—ãŸã€‚`);
        }
      }

      for(let i=0;i<healed;i++) drawCardFor(side,"effect");
      addLog(`å›å¾©ã—ãŸåˆ†ã ã‘${sideLabel(side)}ã¯${healed}æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚`);
      break;
    }

    case "arienaiSearchSong":{
      const s=battle[side];
      // ãƒ‡ãƒƒã‚­ä¸Š4æšã‹ã‚‰songã‚’1æšã¾ã§æ‰‹æœ­ã¸
      const peek = s.deck.slice(0,4);
      if(peek.length===0){ addLog("ã‚¢ãƒªã‚¨ãƒŠã‚¤åŠ¹æœï¼šå±±æœ­ãŒãªã„"); break; }
      const songs = peek.filter(c=>c.type==="song");
      if(songs.length===0){ addLog("ã‚¢ãƒªã‚¨ãƒŠã‚¤åŠ¹æœï¼šã‚½ãƒ³ã‚°ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸ"); break; }

      let chosen=null;
      if(side==="player"){
        let msg="ä¸Š4æšã‹ã‚‰æ‰‹æœ­ã«åŠ ãˆã‚‹ã‚½ãƒ³ã‚°ã‚’é¸ã‚“ã§ãã ã•ã„ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ç„¡ã—ï¼‰\n";
        songs.forEach((c,i)=> msg+=`${i}: ${c.name}(cost${c.cost})\n`);
        const pick=prompt(msg,"0");
        if(pick!==null){
          const idx=parseInt(pick,10);
          if(!Number.isNaN(idx) && idx>=0 && idx<songs.length) chosen=songs[idx];
        }
      }else{
        // é¬¼AIï¼šç›¤é¢/æ‰‹æœ­çŠ¶æ³ã§å¼·ã„ã‚½ãƒ³ã‚°å„ªå…ˆï¼ˆå¤§ç«>å…¨ä½“>å˜ä½“>ãƒ‰ãƒ­ãƒ¼>æ¨ã¦ï¼‰
        const scoreSong=(c)=>{
          if(c.effect==="boardwipe") return 1000;
          if(c.effect==="aoe2") return 700;
          if(c.effect==="damage3") return 500;
          if(c.effect==="discard1") return 400;
          if(c.effect==="draw3") return 350;
          if(c.effect==="handReset7") return 200;
          if(c.effect==="songToInk1") return 250;
          return 0;
        };
        chosen = songs.slice().sort((a,b)=>scoreSong(b)-scoreSong(a))[0];
      }

      // ãƒ‡ãƒƒã‚­ä¸Š4æšã‚’å–ã‚Šå‡ºã™
      s.deck = s.deck.slice(4);
      // chosenã‚’æ‰‹æœ­ã«ã€æ®‹ã‚Šã¯ä¸‹ã¸ï¼ˆé †åºã¯ç°¡ç•¥ï¼šãã®ã¾ã¾ä¸‹ï¼‰
      if(chosen){
        s.hand.push(chosen);
        addLog(`ã€Œã‚¢ãƒªã‚¨ãƒŠã‚¤ã€åŠ¹æœï¼šã‚½ãƒ³ã‚°ã€Œ${chosen.name}ã€ã‚’æ‰‹æœ­ã«åŠ ãˆãŸã€‚`);
        peek.filter(x=>x!==chosen).forEach(x=> s.deck.push(x));
      }else{
        addLog("ã‚¢ãƒªã‚¨ãƒŠã‚¤åŠ¹æœï¼šã‚½ãƒ³ã‚°ã‚’åŠ ãˆãªã‹ã£ãŸã€‚");
        peek.forEach(x=> s.deck.push(x));
      }
      break;
    }
  }
}

/* ========== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œ ========== */
function onPlayerHandCardClick(index){
  if(!battle) return;
  if(battle.currentPlayer!=="player") return;

  const card=battle.player.hand[index];
  if(!card) return;

  let html = `<div>æ‰‹æœ­ï¼šã€Œ${card.name}ã€</div>`;

  // ã‚¤ãƒ³ã‚¯åŒ–
  const canInk = canInkCardFromHand("player", card);
  html += `<button class="btn small" ${canInk?"":"disabled"} onclick="inkFromHand('player', ${index}, false)">
    ã‚¤ãƒ³ã‚¯åŒ– ${canInk?"":"ï¼ˆä¸å¯/ä¸Šé™ï¼‰"}
  </button>`;

  // å¬å–š
  if(card.type==="character"){
    html += `<button class="btn small" onclick="playPlayerCharacter(${index})">å¬å–šï¼ˆcost${card.cost}ï¼‰</button>`;
  }

  // ã‚½ãƒ³ã‚°ä½¿ç”¨ï¼ˆæ­Œã†/æ”¯æ‰•ã„ï¼‰
  if(card.type==="song"){
    html += `<button class="btn small" onclick="playPlayerSong(${index})">ã‚½ãƒ³ã‚°ä½¿ç”¨ï¼ˆcost${card.cost}ï¼‰</button>`;
  }

  html += `<button class="btn small" onclick="showCardDetail(cardFromBattle('player','hand',${index}))">ã‚«ãƒ¼ãƒ‰è©³ç´°</button>`;
  document.getElementById("actionArea").innerHTML=html;
}

function onPlayerFieldCardClick(index){
  if(!battle) return;
  const card=battle.player.field[index];
  if(!card) return;

  let html = `<div>å ´ï¼šã€Œ${card.name}ã€</div>`;

  if(battle.currentPlayer==="player"){
    if(canCharacterAct(card)){
      if(card.lore>0){
        html += `<button class="btn small" onclick="doSeek('player', ${index})">ã‚·ãƒ¼ã‚¯ï¼ˆ+${card.lore}ï¼‰</button>`;
      }

      // ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼šç›¸æ‰‹ã®ãƒ¬ã‚¹ãƒˆã ã‘
      const restTargets = battle.cpu.field.filter(c=>c.rest);
      if(restTargets.length>0 && card.atk>0){
        html += `<button class="btn small" onclick="doChallengePlayer(${index})">ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼ˆç›¸æ‰‹RESTã®ã¿ï¼‰</button>`;
      }else{
        html += `<div style="font-size:11px;opacity:0.8;">ãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆï¼šç›¸æ‰‹ã«RESTãŒã„ãªã„</div>`;
      }
    }else{
      html += `<div style="font-size:11px;opacity:0.8;">ã“ã®ã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ããªã„ï¼ˆREST/å‡çµï¼‰</div>`;
    }
  }

  html += `<button class="btn small" onclick="showCardDetail(cardFromBattle('player','field',${index}))">ã‚«ãƒ¼ãƒ‰è©³ç´°</button>`;
  document.getElementById("actionArea").innerHTML=html;
}

function cardFromBattle(side, place, index){
  if(place==="hand") return battle[side].hand[index];
  if(place==="field") return battle[side].field[index];
  return null;
}

function playPlayerCharacter(handIndex){
  const s=battle.player;
  const card=s.hand[handIndex];
  if(!card || card.type!=="character") return;
  if(s.inkCurrent < card.cost){ alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“"); return; }

  s.inkCurrent -= card.cost;
  s.hand.splice(handIndex,1);
  card.rest=false;
  card.frozen=false;
  card.summonTurn=battle.turnCount;
  s.field.push(card);

  addLog(`è‡ªåˆ†ã¯ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);
  handleOnSummonEffects("player", card);
  updateBattleUI();
}

function playPlayerSong(handIndex){
  const s=battle.player;
  const song=s.hand[handIndex];
  if(!song || song.type!=="song") return;

  const singers = listSingersForSong("player", song);

  let msg = `ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ï¼ˆcost${song.cost}ï¼‰\n`;
  msg += `0: ã‚¤ãƒ³ã‚¯ã§æ”¯æ‰•ã£ã¦ä½¿ç”¨\n`;
  singers.forEach((x,n)=> msg += `${n+1}: ã€Œ${x.card.name}ã€ã§æ­Œã†ï¼ˆã‚¤ãƒ³ã‚¯ä¸è¦ï¼ãã®ã‚­ãƒ£ãƒ©ã¯RESTï¼‰\n`);
  const pick = prompt(msg,"0");
  if(pick===null) return;
  const n=parseInt(pick,10);
  if(Number.isNaN(n) || n<0 || n> singers.length){ alert("ä¸æ­£"); return; }

  if(n===0){
    if(s.inkCurrent < song.cost){ alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“"); return; }
    s.inkCurrent -= song.cost;
    s.hand.splice(handIndex,1);
    addLog(`è‡ªåˆ†ã¯ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã‚’ã‚¤ãƒ³ã‚¯ã§ä½¿ç”¨ã—ãŸã€‚`);
    applySongEffect("player", song);
  }else{
    const singer=singers[n-1];
    battle.player.field[singer.idx].rest=true;
    s.hand.splice(handIndex,1);
    addLog(`è‡ªåˆ†ã¯ã€Œ${singer.card.name}ã€ã§ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã‚’æ­Œã£ãŸã€‚`);
    applySongEffect("player", song);
  }

  addLog(`ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã¯ä½¿ç”¨å¾Œã«ç ´å£Šã•ã‚ŒãŸã€‚`);
  updateBattleUI();
  checkWin();
}

function doChallengePlayer(fieldIndex){
  const attacker=battle.player.field[fieldIndex];
  if(!attacker || !canCharacterAttack("player", attacker)){
    alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯ã¾ã ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã§ãã¾ã›ã‚“ï¼ˆå¬å–šã‚¿ãƒ¼ãƒ³/REST/å‡çµï¼‰");
    return;
  }
  const restTargets = battle.cpu.field.map((c,i)=>({c,i})).filter(x=>x.c.rest);
  if(restTargets.length===0){ alert("ç›¸æ‰‹ã«RESTãŒã„ã¾ã›ã‚“"); return; }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯é¸æŠ
  let msg="ãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆï¼ˆRESTï¼‰ã‚’é¸ã‚“ã§ãã ã•ã„\n";
  restTargets.forEach((x,k)=> msg += `${k}: ${x.c.name} (HP${x.c.hp})\n`);
  const pick=prompt(msg,"0"); if(pick===null) return;
  const k=parseInt(pick,10);
  if(Number.isNaN(k)||k<0||k>=restTargets.length){ alert("ä¸æ­£"); return; }
  resolveCombat("player", fieldIndex, restTargets[k].i);

  updateBattleUI();
  checkWin();
}

/* ========== CPUï¼ˆé¬¼AIï¼‰ ========== */
function cpuTryInk(){
  const cpu=battle.cpu;
  const allowed = inkPlacementsAllowed("cpu");
  if(cpu.inkPlacedThisTurn >= allowed) return false;
  if(cpu.hand.length===0) return false;

  // é¬¼AIï¼šåŸºæœ¬ã¯ â€œé‡ã„ã‚«ãƒ¼ãƒ‰â€ ã‚’å„ªå…ˆã§ã‚¤ãƒ³ã‚¯åŒ–ï¼ˆãŸã ã—inkableã®ã¿ï¼‰
  let idx=-1;
  let best=-1;
  for(let i=0;i<cpu.hand.length;i++){
    const c=cpu.hand[i];
    if(!c.inkable) continue;
    const v = c.cost*10 + (c.type==="song"?5:0) + (c.rarity==="L"?4:0);
    if(v>best){ best=v; idx=i; }
  }
  if(idx<0) return false;
  return inkFromHand("cpu", idx, false);
}

function cpuBestSingerFor(song){
  const singers=listSingersForSong("cpu", song);
  // é¬¼AIï¼šä½¿ã„çµ‚ã‚ã‚‹ï¼ˆRESTã«ãªã‚‹ï¼‰ã®ã§ã€ãƒ­ã‚¢ãŒä½ã„ã‚­ãƒ£ãƒ©ã‹ã‚‰æ­Œã‚ã›ã‚‹
  singers.sort((a,b)=> (a.card.lore-b.card.lore) || (a.card.atk-b.card.atk));
  return singers[0] || null;
}

function cpuTryPlaySongOnce(){
  const cpu=battle.cpu;
  // é¬¼AIï¼šåŠ¹æœå„ªå…ˆé †ä½
  const scoreSong=(song)=>{
    if(song.effect==="boardwipe"){
      // ç›¸æ‰‹ãŒå¤šã„ã»ã©å¼·ã„
      return 900 + battle.player.field.length*50;
    }
    if(song.effect==="aoe2") return 700 + battle.player.field.length*30;
    if(song.effect==="damage3") return 520;
    if(song.effect==="discard1") return 450 + battle.player.hand.length*10;
    if(song.effect==="draw3") return 360;
    if(song.effect==="songToInk1") return 300;
    if(song.effect==="handReset7") return 120;
    return 0;
  };

  // æ‰‹æœ­ã®ã‚½ãƒ³ã‚°å€™è£œ
  const songs = cpu.hand.map((c,i)=>({c,i})).filter(x=>x.c.type==="song");
  if(!songs.length) return false;

  songs.sort((a,b)=> scoreSong(b.c)-scoreSong(a.c));

  for(const obj of songs){
    const song=obj.c;

    // 1) æ­Œãˆã‚‹ãªã‚‰æ­Œã†ï¼ˆã‚¤ãƒ³ã‚¯ç¯€ç´„ï¼‰
    const singer = cpuBestSingerFor(song);
    if(singer){
      battle.cpu.field[singer.idx].rest=true;
      cpu.hand.splice(obj.i,1);
      addLog(`ç›¸æ‰‹ã¯ã€Œ${singer.card.name}ã€ã§ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã‚’æ­Œã£ãŸã€‚`);
      applySongEffect("cpu", song);
      addLog(`ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã¯ä½¿ç”¨å¾Œã«ç ´å£Šã•ã‚ŒãŸã€‚`);
      return true;
    }

    // 2) ã‚¤ãƒ³ã‚¯ã§æ‰•ãˆã‚‹ãªã‚‰æ‰•ã†
    if(cpu.inkCurrent >= song.cost){
      cpu.inkCurrent -= song.cost;
      cpu.hand.splice(obj.i,1);
      addLog(`ç›¸æ‰‹ã¯ã‚¤ãƒ³ã‚¯ã§ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã‚’ä½¿ç”¨ã—ãŸã€‚`);
      applySongEffect("cpu", song);
      addLog(`ã‚½ãƒ³ã‚°ã€Œ${song.name}ã€ã¯ä½¿ç”¨å¾Œã«ç ´å£Šã•ã‚ŒãŸã€‚`);
      return true;
    }
  }
  return false;
}

function cpuTrySummonBest(){
  const cpu=battle.cpu;
  const chars = cpu.hand.map((c,i)=>({c,i})).filter(x=>x.c.type==="character" && x.c.cost<=cpu.inkCurrent);
  if(!chars.length) return false;

  // é¬¼AIï¼šä¾¡å€¤é–¢æ•°ï¼ˆãƒ­ã‚¢é‡è¦–ï¼‹åŠ¹æœï¼‹ATK/HPï¼‰
  const value=(c)=>{
    let v = c.lore*50 + c.atk*8 + c.hp*6;
    if(c.effect==="freeze2") v+=120;
    if(c.effect==="destroyOnSummon") v+=140;
    if(c.effect==="bounceOnSummon") v+=110;
    if(c.effect==="toInkOnSummon") v+=80;
    if(c.effect==="pretzelHealDraw") v+=60;
    if(c.id===ID_LIN) v+=70; // ã‚¤ãƒ³ã‚¯ç½®ã+1ã¯è¶…å¼·ã„
    if(c.rush) v+=20;
    if(c.mustAttack) v-=10;
    return v;
  };

  chars.sort((a,b)=> value(b.c)-value(a.c));
  const pick=chars[0];

  const card=pick.c;
  cpu.inkCurrent -= card.cost;
  cpu.hand.splice(pick.i,1);
  card.rest=false;
  card.frozen=false;
  card.summonTurn=battle.turnCount;
  cpu.field.push(card);
  addLog(`ç›¸æ‰‹ã¯ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);
  handleOnSummonEffects("cpu", card);
  return true;
}

function cpuTryChallengeOrSeek(){
  const cpu=battle.cpu;
  const me=battle.player;

  // é¬¼AIï¼šã¾ãšã€Œå¿…ãšæ”»æ’ƒã€æŒã¡ã‚’å‡¦ç†
  const attackers = cpu.field.map((c,i)=>({c,i})).filter(x=>canCharacterAttack("cpu", x.c));

  // ç›¸æ‰‹RESTã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸€è¦§
  const restTargets = me.field.map((c,i)=>({c,i})).filter(x=>x.c.rest);

  // ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼šã§ãã‚‹ãªã‚‰ã€Œå€’ã›ã‚‹/ãƒ­ã‚¢é«˜ã„ã€é †
  function scoreTarget(attacker, target){
    const kill = (target.c.hp <= attacker.atk) ? 200 : 0;
    const lore = target.c.lore*80;
    const atk  = target.c.atk*8;
    return kill + lore + atk;
  }

  // 1) mustAttack ã‚­ãƒ£ãƒ©
  const must = attackers.filter(x=>x.c.mustAttack);
  for(const a of must){
    if(restTargets.length>0){
      // æœ€é«˜ã‚¹ã‚³ã‚¢ã«æ”»æ’ƒ
      let bestK=0, best=-999;
      restTargets.forEach((t,k)=>{
        const s=scoreTarget(a.c,t.c);
        if(s>best){ best=s; bestK=k; }
      });
      resolveCombat("cpu", a.i, restTargets[bestK].i);
      updateBattleUI();
      return true;
    }
  }

  // 2) é€šå¸¸ï¼šå‹ã¡ç­‹ï¼ˆãƒ­ã‚¢ï¼‰å„ªå…ˆ
  // - ç›¸æ‰‹RESTãŒã„ã‚‹ãªã‚‰ã€å€’ã›ã‚‹/ãƒ­ã‚¢é«˜ã„ã‚’å©ã
  for(const a of attackers){
    if(restTargets.length>0 && a.c.atk>0){
      let bestK=0, best=-999;
      restTargets.forEach((t,k)=>{
        const s=scoreTarget(a.c,t.c);
        if(s>best){ best=s; bestK=k; }
      });
      const ok = resolveCombat("cpu", a.i, restTargets[bestK].i);
      if(ok){ updateBattleUI(); return true; }
    }
  }

  // 3) ç›¸æ‰‹RESTãŒã„ãªã„/æ”»æ’ƒã§ããªã„ãªã‚‰ã€ã‚·ãƒ¼ã‚¯ï¼ˆãƒ­ã‚¢æœ€å¤§ã‹ã‚‰ï¼‰
  const seekers = cpu.field.map((c,i)=>({c,i})).filter(x=>canCharacterAct(x.c) && x.c.lore>0);
  if(seekers.length){
    seekers.sort((a,b)=> b.c.lore-a.c.lore);
    doSeek("cpu", seekers[0].i);
    return true;
  }

  return false;
}

function cpuDoTurn(){
  // CPUã®è¡Œå‹•å›æ•°ã‚’å¢—ã‚„ã™ï¼ˆé¬¼ã»ã©æ€è€ƒ/å®Ÿè¡Œã‚’å¢—ã‚„ã™ï¼‰
  const loops = (battle.cpuStrength==="god") ? 18 : (battle.cpuStrength==="strong") ? 10 : 6;

  for(let t=0;t<loops;t++){
    if(checkWin()) return;

    // ã¾ãšã‚¤ãƒ³ã‚¯ã‚’ç½®ãï¼ˆå¿…è¦ãªæ™‚ã«æœ€å„ªå…ˆï¼‰
    if(cpuTryInk()){
      if(battle.cpuStrength!=="normal") continue;
    }

    // ã‚½ãƒ³ã‚°å„ªå…ˆï¼ˆé¬¼ã¯é€£æ‰“ã™ã‚‹ï¼‰
    if(cpuTryPlaySongOnce()){
      if(battle.cpuStrength==="god") continue;
    }

    // å¬å–šã§ãã‚‹ãªã‚‰å¬å–š
    if(cpuTrySummonBest()){
      if(battle.cpuStrength!=="normal") continue;
    }

    // æ”»æ’ƒ/ã‚·ãƒ¼ã‚¯
    if(cpuTryChallengeOrSeek()){
      if(battle.cpuStrength==="god") continue;
    }

    // ä½•ã‚‚ã§ããªã„ãªã‚‰çµ‚äº†
    break;
  }

  updateBattleUI();
  if(checkWin()) return;

  addLog("ç›¸æ‰‹ã¯ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ãŸã€‚");
  startTurn("player");
}

/* ========== ç”»é¢æ›´æ–° ========== */
function updateBattleUI(){
  if(!battle) return;

  // CPU
  document.getElementById("cpuHandCount").textContent = battle.cpu.hand.length;
  document.getElementById("cLore").textContent = battle.cpu.lore;
  document.getElementById("cDeck").textContent = battle.cpu.deck.length;
  document.getElementById("cpuInkCurrent").textContent = battle.cpu.inkCurrent;
  document.getElementById("cpuInkMax").textContent = battle.cpu.inkMax;

  // Player
  document.getElementById("playerLore").textContent = battle.player.lore;
  document.getElementById("playerInkCurrent").textContent = battle.player.inkCurrent;
  document.getElementById("playerInkMax").textContent = battle.player.inkMax;
  document.getElementById("playerDeck").textContent = battle.player.deck.length;

  document.getElementById("turnInfo").textContent = (battle.currentPlayer==="player") ? "è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³" : "ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³";

  const cpuFieldEl=document.getElementById("cpuField");
  cpuFieldEl.innerHTML="";
  battle.cpu.field.forEach(card=>{
    const wrap=document.createElement("div");
    wrap.innerHTML=renderCardHtml(card);
    cpuFieldEl.appendChild(wrap.firstElementChild);
  });

  const playerFieldEl=document.getElementById("playerField");
  playerFieldEl.innerHTML="";
  battle.player.field.forEach((card,idx)=>{
    const wrap=document.createElement("div");
    wrap.innerHTML=renderCardHtml(card);
    const el=wrap.firstElementChild;
    el.onclick=()=>onPlayerFieldCardClick(idx);
    playerFieldEl.appendChild(el);
  });

  const playerHandEl=document.getElementById("playerHand");
  playerHandEl.innerHTML="";
  battle.player.hand.forEach((card,idx)=>{
    const wrap=document.createElement("div");
    wrap.innerHTML=renderCardHtml(card);
    const el=wrap.firstElementChild;
    el.onclick=()=>onPlayerHandCardClick(idx);
    playerHandEl.appendChild(el);
  });
}

/* ========== åˆæœŸåŒ– ========== */
window.addEventListener("load", ()=>{
  loadData();
});
</script>
</body>
</html>

