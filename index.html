
<!DOCTYPE html>
<html lang="ja">
<head>
 <meta charset="UTF-8" />
 <title>Dream-seeker TCG</title>
 <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <style>
   * { box-sizing: border-box; }

   body {
     margin: 0;
     font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
     background: #181818;
     color: #f5f5f5;
   }

   h1, h2 { text-align: center; margin: 12px 0; }

   .screen {
     display: none;
     padding: 10px;
     max-width: 520px;
     margin: 0 auto;
   }
   .screen.active { display: block; }

   .btn {
     width: 100%;
     padding: 10px;
     margin: 6px 0;
     border-radius: 8px;
     border: none;
     cursor: pointer;
     font-size: 14px;
     background: #444;
     color: #f5f5f5;
   }
   .btn.primary { background: #2ecc71; color: #000; }
   .btn.danger  { background: #e74c3c; }
   .btn.small {
     width: auto;
     padding: 4px 8px;
     font-size: 12px;
     margin: 2px 4px 0 0;
   }

   .topbar {
     display: flex;
     justify-content: space-between;
     font-size: 12px;
     margin-bottom: 8px;
   }

   .card-box {
     border: 1px solid #555;
     border-radius: 8px;
     padding: 6px;
     margin: 4px 0;
     font-size: 12px;
     background: #202020;
   }
   .card-name  { font-weight: bold; }
   .card-stats { font-size: 11px; opacity: 0.9; margin-top: 2px; }

   .red    { border-color: #e74c3c; }
   .purple { border-color: #9b59b6; }
   .blue   { border-color: #3498db; }
   .yellow { border-color: #f1c40f; }
   .white  { border-color: #ecf0f1; }
   .green  { border-color: #2ecc71; }

   .log {
     background: #111;
     border-radius: 8px;
     padding: 6px;
     font-size: 11px;
     height: 120px;
     overflow-y: auto;
     border: 1px solid #333;
     margin-top: 6px;
   }

   .section-title {
     font-size: 13px;
     margin: 10px 0 4px;
     font-weight: bold;
   }

   .stone-bar {
     font-size: 13px;
     padding: 4px 6px;
     border-radius: 8px;
     background: #222;
     display: inline-block;
     margin-bottom: 8px;
   }

   .row { display: flex; gap: 6px; }
   .row > .btn { flex: 1; }

   .toggle-selected {
     background: #f39c12 !important;
     color: #000 !important;
   }

   /* ===== ãƒãƒˆãƒ«ç”»é¢ç”¨ ===== */

   .battle-screen { padding: 16px; }

   .enemy-title {
     text-align: center;
     font-size: 20px;
     margin-bottom: 8px;
   }

   .enemy-status {
     display: flex;
     justify-content: space-around;
     margin-bottom: 16px;
     font-size: 12px;
   }

   /* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ / æ‰‹æœ­ï¼ˆæ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰ */
   .field,
   .hand-area {
     display: flex;
     align-items: flex-start;
     gap: 12px;
     margin-bottom: 16px;
     min-height: 150px;
     overflow-x: auto;
     overflow-y: visible;
     padding-bottom: 8px;
     -webkit-overflow-scrolling: touch;
     justify-content: flex-start;
   }

   /* ã‚«ãƒ¼ãƒ‰å…±é€šè¦‹ãŸç›® */
   .card {
     flex: 0 0 auto;
     width: 96px;
     height: 160px;
     border-radius: 10px;
     border: 3px solid #555;
     background: #b30000;
     color: #ffffff;
     font-size: 10px;
     box-sizing: border-box;
     padding: 4px;
     display: flex;
     flex-direction: column;
     justify-content: flex-start;
     cursor: pointer;
     transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
   }

   .card:hover {
     transform: translateY(-2px);
     box-shadow: 0 0 8px rgba(255,255,255,0.3);
   }

   /* è¡Œå‹•æ¸ˆã¿ */
   .card.rest { opacity: 0.6; }

   /* è‰²åˆ¥ */
   .card.red {
     border-color: #e74c3c;
     background: #8b1a1a;
   }
   .card.purple {
     border-color: #9b59b6;
     background: #4b2b63;
   }
   .card.blue {
     border-color: #3498db;
     background: #1f3f5f;
   }
   .card.yellow {
     border-color: #f1c40f;
     background: #866d07;
   }
   .card.white {
     border-color: #ecf0f1;
     background: #aaaaaa;
     color: #000;
   }
   .card.green {
     border-color: #2ecc71;
     background: #145437;
   }

   .card-header {
     display: flex;
     align-items: center;
     justify-content: space-between;
     background: #000000;
     border-radius: 4px;
     padding: 2px 3px;
     margin-bottom: 3px;
     font-weight: bold;
   }

   .card-cost {
     min-width: 16px;
     text-align: center;
   }

   .card-name-header {
     flex: 1;
     text-align: center;
     font-size: 9px;
   }

   .card-inkable {
     min-width: 16px;
     text-align: center;
   }

   .card-illust {
     flex: 1;
     background: #ffffff;
     border-radius: 4px;
     margin-bottom: 3px;
   }

   .card-stats-row {
     display: flex;
     justify-content: space-between;
     font-size: 9px;
     padding: 0 2px;
     margin-bottom: 3px;
   }

   .card-power { font-weight: bold; }
   .card-lore  { font-size: 9px; }

   .card-footer {
     background: #000000;
     border-radius: 4px;
     padding: 2px 3px;
     font-size: 9px;
   }

   .divider {
     border-top: 3px dashed #ffffff;
     margin: 16px 0;
   }

   .bottom-ui {
     display: flex;
     justify-content: space-between;
     gap: 16px;
     flex-wrap: wrap;
   }

   .status-box,
   .effect-box {
     width: 48%;
     min-height: 120px;
     border: 3px solid #ffffff;
     box-sizing: border-box;
     padding: 8px;
     font-size: 13px;
   }

   .status-box-title,
   .effect-box-title {
     font-weight: bold;
     margin-bottom: 4px;
   }

   .turn-info {
     margin-top: 4px;
     font-weight: bold;
   }

   .status-buttons {
     margin-top: 8px;
     display: flex;
     flex-wrap: wrap;
     gap: 4px;
   }

   .status-buttons button {
     font-size: 12px;
     padding: 4px 8px;
   }

   /* å‹åˆ©ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
   .win-overlay {
     position: fixed;
     inset: 0;
     background: rgba(0,0,0,0.7);
     display: flex;
     align-items: center;
     justify-content: center;
     z-index: 9999;
   }
   .win-overlay.hidden { display: none; }

   .win-dialog {
     background: #222;
     border-radius: 10px;
     padding: 16px;
     max-width: 320px;
     text-align: center;
     border: 2px solid #fff;
   }
   .win-dialog-message {
     margin-bottom: 12px;
     font-size: 16px;
     font-weight: bold;
   }
 </style>
</head>
<body>

<!-- ===== ãƒ›ãƒ¼ãƒ  ===== -->
<div id="menuScreen" class="screen active">
 <h1>Dream-seeker TCG</h1>
 <div class="stone-bar">
   ğŸ’ ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="stoneCount">0</span>
 </div>
 <button class="btn primary" onclick="openCpuConfig()">ãƒãƒˆãƒ«</button>
 <button class="btn" onclick="showShop()">ã‚·ãƒ§ãƒƒãƒ—</button>
 <button class="btn" onclick="showPack()">ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</button>
 <button class="btn" onclick="openDeckBuilder()">ãƒ‡ãƒƒã‚­ç·¨é›†</button>
 <button class="btn" onclick="openCollection()">ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</button>
</div>

<!-- ===== CPUè¨­å®š ===== -->
<div id="cpuScreen" class="screen">
 <h2>CPUè¨­å®š</h2>

 <div class="section-title">CPUã®å¼·ã•</div>
 <div class="row">
   <button id="btnCpuNormal" class="btn" onclick="setCpuStrength('normal')">æ™®é€šï¼ˆSRã¾ã§ï¼‰</button>
   <button id="btnCpuStrong" class="btn" onclick="setCpuStrength('strong')">å¼·ã„ï¼ˆLä½¿ç”¨ï¼‰</button>
 </div>

 <div class="section-title">CPUãƒ‡ãƒƒã‚­è‰²</div>
 <div class="row">
   <button id="cpuRed"    class="btn" onclick="setCpuColor('red')">èµ¤</button>
   <button id="cpuPurple" class="btn" onclick="setCpuColor('purple')">ç´«</button>
 </div>
 <div class="row">
   <button id="cpuBlue"   class="btn" onclick="setCpuColor('blue')">é’</button>
   <button id="cpuYellow" class="btn" onclick="setCpuColor('yellow')">é»„</button>
 </div>
 <div class="row">
   <button id="cpuWhite"  class="btn" onclick="setCpuColor('white')">ç™½</button>
   <button id="cpuGreen"  class="btn" onclick="setCpuColor('green')">ç·‘</button>
 </div>

 <div class="section-title">è‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­</div>
 <button id="btnPlayerDefault" class="btn" onclick="selectPlayerDeck('default')">
   ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèµ¤ãƒ‡ãƒƒã‚­
 </button>
 <button id="btnDeck1" class="btn" onclick="selectPlayerDeck('slot1')">
   ãƒ‡ãƒƒã‚­1ï¼ˆæœªä¿å­˜ï¼‰
 </button>
 <button id="btnDeck2" class="btn" onclick="selectPlayerDeck('slot2')">
   ãƒ‡ãƒƒã‚­2ï¼ˆæœªä¿å­˜ï¼‰
 </button>
 <button id="btnDeck3" class="btn" onclick="selectPlayerDeck('slot3')">
   ãƒ‡ãƒƒã‚­3ï¼ˆæœªä¿å­˜ï¼‰
 </button>

 <button class="btn primary" onclick="startBattle()">ãƒãƒˆãƒ«é–‹å§‹</button>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒãƒˆãƒ« ===== -->
<div id="battleScreen" class="screen">
 <div class="battle-screen">

   <!-- ç›¸æ‰‹ã‚¨ãƒªã‚¢ -->
   <div class="enemy-area">
     <div class="enemy-title">ç›¸æ‰‹</div>
     <div class="enemy-status">
       <span>æ‰‹æœ­ï¼š<span id="cpuHandCount">0</span>æš</span>
       <span>ãƒ­ã‚¢ï¼š<span id="cLore">0</span>å€‹</span>
       <span>æ®‹ã‚Šå±±æœ­ï¼š<span id="cDeck">25</span>æš</span>
     </div>

     <div class="field enemy-field" id="cpuField"></div>
   </div>

   <div class="divider"></div>

   <!-- è‡ªåˆ†ã‚¨ãƒªã‚¢ -->
   <div class="player-area">

     <div class="field player-field" id="playerField"></div>

     <div class="hand-area" id="playerHand"></div>

     <div class="bottom-ui">
       <div class="status-box">
         <div class="status-box-title">è‡ªåˆ†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
         <div>ãƒ­ã‚¢ï¼š<span id="playerLore">0</span></div>
         <div>ã‚¤ãƒ³ã‚¯ï¼š<span id="playerInkCurrent">0</span> / <span id="playerInkMax">0</span></div>
         <div>æ®‹ã‚Šå±±æœ­ï¼š<span id="playerDeck">25</span></div>
         <div id="turnInfo" class="turn-info">è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³</div>

         <div class="status-buttons">
           <button id="btnDraw" class="btn small" onclick="playerDraw()">ãƒ‰ãƒ­ãƒ¼</button>
           <button id="endTurnBtn" class="btn small" onclick="endTurn()">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
         </div>
       </div>

       <div class="effect-box">
         <div class="effect-box-title">ã‚¿ãƒƒãƒ—ã—ãŸã‚«ãƒ¼ãƒ‰ã®æƒ…å ± / è¡Œå‹•</div>
         <div id="actionArea">ã“ã“ã«ã‚«ãƒ¼ãƒ‰æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
       </div>
     </div>

     <div class="section-title">ãƒ­ã‚°</div>
     <div id="log" class="log"></div>

     <button class="btn danger" onclick="quitBattleToMenu()">
       ãƒãƒˆãƒ«ã‚’ã‚„ã‚ã¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹
     </button>
   </div>

 </div>

 <!-- å‹åˆ©æ¼”å‡º -->
 <div id="winOverlay" class="win-overlay hidden">
   <div class="win-dialog">
     <div id="winMessage" class="win-dialog-message">å‹åˆ©ï¼</div>
     <button class="btn primary" onclick="returnToMenuFromBattle()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
   </div>
 </div>
</div>

<!-- ===== ã‚·ãƒ§ãƒƒãƒ— ===== -->
<div id="shopScreen" class="screen">
 <h2>ã‚·ãƒ§ãƒƒãƒ—</h2>
 <p>â€» ä»Šã¯ãƒ†ã‚¹ãƒˆç”¨ã€‚çŸ³ã‚’å¢—ã‚„ã—æ”¾é¡Œã«ã—ã¦ã‚ã‚Šã¾ã™ã€‚</p>
 <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="shopStoneCount">0</span></p>
 <button class="btn" onclick="debugAddStones()">çŸ³ã‚’100å€‹å¢—ã‚„ã™ï¼ˆãƒ†ã‚¹ãƒˆï¼‰</button>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‘ãƒƒã‚¯ ===== -->
<div id="packScreen" class="screen">
 <h2>ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</h2>
 <p>ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³5å€‹ã§1ãƒ‘ãƒƒã‚¯ï¼ˆ5æšå…¥ã‚Šï¼‰</p>
 <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="packStoneCount">0</span></p>
 <button class="btn primary" onclick="openPack()">ãƒ‘ãƒƒã‚¯ã‚’é–‹ã‘ã‚‹</button>
 <div class="section-title">ä»Šå›ã®çµæœ</div>
 <div id="packResult"></div>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ãƒ‡ãƒƒã‚­ç·¨é›† ===== -->
<div id="deckScreen" class="screen">
 <h2>ãƒ‡ãƒƒã‚­ç·¨é›†</h2>

 <div class="section-title">ç·¨é›†ã™ã‚‹ãƒ‡ãƒƒã‚­ã‚¹ãƒ­ãƒƒãƒˆ</div>
 <div class="row">
   <button id="editDeck1" class="btn small" onclick="setCurrentDeckSlot(0)">ãƒ‡ãƒƒã‚­1</button>
   <button id="editDeck2" class="btn small" onclick="setCurrentDeckSlot(1)">ãƒ‡ãƒƒã‚­2</button>
   <button id="editDeck3" class="btn small" onclick="setCurrentDeckSlot(2)">ãƒ‡ãƒƒã‚­3</button>
 </div>

 <p style="font-size:12px; opacity:0.8;">
   æ‰€æŒã‚«ãƒ¼ãƒ‰ã‹ã‚‰ãƒ‡ãƒƒã‚­ã«å…¥ã‚Œã‚‹æšæ•°ã‚’æ±ºã‚ã¦ãã ã•ã„ã€‚<br>
   ãƒ‡ãƒƒã‚­ã¯æœ€å¤§3ã¤ã¾ã§ä¿å­˜ã§ãã€ãƒãƒˆãƒ«é–‹å§‹æ™‚ã«é¸æŠã§ãã¾ã™ã€‚
 </p>
 <div id="deckCardList"></div>
 <button class="btn primary" onclick="saveDeck()">ã“ã®ã‚¹ãƒ­ãƒƒãƒˆã«ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜</button>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<!-- ===== ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ« ===== -->
<div id="collectionScreen" class="screen">
 <h2>ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</h2>
 <div id="collectionList"></div>
 <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
</div>

<script>
/* ========== ç”»é¢åˆ‡ã‚Šæ›¿ãˆ ========== */
function showScreen(name) {
 const ids = ["menuScreen","cpuScreen","battleScreen","shopScreen","packScreen","deckScreen","collectionScreen"];
 ids.forEach(id => {
   const el = document.getElementById(id);
   if (el) el.classList.remove("active");
 });
 const map = {
   menu: "menuScreen",
   cpu: "cpuScreen",
   battle: "battleScreen",
   shop: "shopScreen",
   pack: "packScreen",
   deck: "deckScreen",
   collection: "collectionScreen"
 };
 document.getElementById(map[name]).classList.add("active");
}

/* ========== ã‚«ãƒ¼ãƒ‰å®šç¾© ========== */
/*
 æ–°èƒ½åŠ›:
 - å¤‰èº«: è¦šé†’ã‚¨ãƒ«ã‚µã®ã¿ã€‚transformCost:6
 - å›é¿: evade:true
 - çµ‚ç„‰ã®å¤§ç«: type:"song" å…¨ã‚­ãƒ£ãƒ©ç ´å£Š
*/

const cards = [
 {id:0, name:"ã‚«ãƒ¼",   color:"red",    type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:1, name:"ãƒ«ãƒ‘ãƒ—", color:"purple", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:2, name:"ãƒ«ãƒ–ãƒ–", color:"blue",   type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:3, name:"ãƒ­ã‚¤ã‚¨", color:"yellow", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:4, name:"ãƒ­ãƒ¼ã‚·", color:"white",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
 {id:5, name:"ãƒ‰ãƒªãƒŸ", color:"green",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},

 {id:6, name:"çµ‚ç„‰ã®å¤§ç«",          color:"red",    type:"song",      cost:7, atk:0, hp:0, lore:0, rarity:"SR", inkable:false},
 {id:7, name:"è¦šé†’ã‚¨ãƒ«ã‚µ",          color:"purple", type:"character", cost:8, atk:4, hp:6, lore:3, rarity:"L",  inkable:false, transformCost:6},
 {id:8, name:"ä¼èª¬ã®å‹‡è€…ã‚¤ãƒ•ãƒªãƒ¼ãƒˆ", color:"red",    type:"character", cost:8, atk:5, hp:5, lore:4, rarity:"L",  inkable:true,  evade:true}
];

function makeCardInstance(base) {
 const c = Object.assign({}, base);
 c.hp = base.hp;
 c.maxHp = base.hp;
 c.rest = false;
 c.summonTurn = -1;
 c.skipReadyTurn = 0;
 return c;
}

/* ========== ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ ========== */
let stones = 0;
let collection = {};
let savedDecks = [[],[],[]];
let currentDeckSlot = 0;

function loadData() {
 const s = localStorage.getItem("ds_stones");
 stones = s ? parseInt(s,10) : 0;

 const c = localStorage.getItem("ds_collection");
 collection = c ? JSON.parse(c) : {};

 const dAll = localStorage.getItem("ds_playerDecks");
 if (dAll) {
   try {
     const parsed = JSON.parse(dAll);
     if (Array.isArray(parsed) && parsed.length === 3) {
       savedDecks = parsed;
     }
   } catch(e){}
 } else {
   const dOld = localStorage.getItem("ds_playerDeck");
   if (dOld) {
     try {
       savedDecks[0] = JSON.parse(dOld);
     } catch(e){}
   }
 }

 updateStoneDisplays();
}

function saveStones() {
 localStorage.setItem("ds_stones", String(stones));
 updateStoneDisplays();
}
function saveCollection() {
 localStorage.setItem("ds_collection", JSON.stringify(collection));
}
function savePlayerDecks() {
 localStorage.setItem("ds_playerDecks", JSON.stringify(savedDecks));
}

function updateStoneDisplays() {
 const v1 = document.getElementById("stoneCount");
 const v2 = document.getElementById("shopStoneCount");
 const v3 = document.getElementById("packStoneCount");
 if (v1) v1.textContent = stones;
 if (v2) v2.textContent = stones;
 if (v3) v3.textContent = stones;
}

/* ========== ã‚·ãƒ§ãƒƒãƒ— ========== */
function showShop() {
 updateStoneDisplays();
 showScreen("shop");
}
function debugAddStones() {
 stones += 100;
 saveStones();
}

/* ========== ã‚¬ãƒãƒ£ ========== */
function showPack() {
 updateStoneDisplays();
 document.getElementById("packResult").innerHTML = "";
 showScreen("pack");
}

function openPack() {
 const COST = 5;
 if (stones < COST) {
   alert("ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³ãŒè¶³ã‚Šã¾ã›ã‚“ï¼ˆ5å€‹å¿…è¦ï¼‰");
   return;
 }
 stones -= COST;
 saveStones();

 const pulled = [];

 for (let i=0;i<5;i++) {
   const r = Math.random();
   let rarity;
   if (r < 0.78) rarity = "N";
   else if (r < 0.90) rarity = "R";
   else if (r < 0.98) rarity = "SR";
   else rarity = "L";

   let candidates = cards.filter(c => c.rarity === rarity);
   if (candidates.length === 0) {
     const order = ["L","SR","R","N"];
     for (const rr of order) {
       const list = cards.filter(c => c.rarity === rr);
       if (list.length) { candidates = list; break; }
     }
     if (!candidates.length) candidates = cards.slice();
   }

   const card = candidates[Math.floor(Math.random()*candidates.length)];
   pulled.push(card);
   if (!collection[card.id]) collection[card.id] = 0;
   collection[card.id]++;
 }
 saveCollection();

 const pr = document.getElementById("packResult");
 pr.innerHTML = pulled.map(c => `
   <div class="card-box ${c.color}">
     <div class="card-name">${c.name}</div>
     <div class="card-stats">è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type}</div>
   </div>
 `).join("");
}

/* ========== ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ ========== */
function openCollection() {
 const list = document.getElementById("collectionList");
 let html = "";
 cards.forEach(c => {
   const cnt = collection[c.id] || 0;
   html += `
     <div class="card-box ${c.color}">
       <div class="card-name">${c.name}</div>
       <div class="card-stats">è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type}</div>
       <div class="card-stats">æ‰€æŒæšæ•°: Ã—${cnt}</div>
     </div>`;
 });
 list.innerHTML = html;
 showScreen("collection");
}

/* ========== ãƒ‡ãƒƒã‚­ç·¨é›† ========== */
let deckCounts = {};

function setCurrentDeckSlot(slot) {
 currentDeckSlot = slot;
 updateDeckSlotButtons();
 buildDeckEditor();
}

function updateDeckSlotButtons() {
 for (let i=0;i<3;i++) {
   const btn = document.getElementById("editDeck"+(i+1));
   if (!btn) continue;
   btn.classList.toggle("toggle-selected", i === currentDeckSlot);
 }
}

function openDeckBuilder() {
 updateDeckSlotButtons();
 buildDeckEditor();
 showScreen("deck");
}

function buildDeckEditor() {
 deckCounts = {};
 const deck = savedDecks[currentDeckSlot] || [];
 deck.forEach(id => {
   deckCounts[id] = (deckCounts[id] || 0) + 1;
 });

 const area = document.getElementById("deckCardList");
 let html = "";
 cards.forEach(c => {
   const have = collection[c.id] || 0;
   const inDeck = deckCounts[c.id] || 0;
   html += `
     <div class="card-box ${c.color}">
       <div class="card-name">${c.name}</div>
       <div class="card-stats">
         è‰²:${c.color} / ãƒ¬ã‚¢:${c.rarity} / ç¨®é¡:${c.type} / ã‚³ã‚¹ãƒˆ:${c.cost}
       </div>
       <div class="card-stats">
         æ‰€æŒ: Ã—${have} ï¼ ãƒ‡ãƒƒã‚­: Ã—<span id="deck-count-${c.id}">${inDeck}</span>
       </div>
       <button class="btn small" onclick="changeDeckCount(${c.id}, -1)">ï¼</button>
       <button class="btn small" onclick="changeDeckCount(${c.id}, +1)">ï¼‹</button>
     </div>`;
 });
 area.innerHTML = html;
}

function changeDeckCount(cardId, diff) {
 const have = collection[cardId] || 0;
 let cur = deckCounts[cardId] || 0;
 cur += diff;
 if (cur < 0) cur = 0;
 if (cur > have) cur = have;
 deckCounts[cardId] = cur;
 const span = document.getElementById("deck-count-"+cardId);
 if (span) span.textContent = cur;
}

function saveDeck() {
 const newDeck = [];
 Object.entries(deckCounts).forEach(([idStr,cnt]) => {
   const id = parseInt(idStr,10);
   for (let i=0;i<cnt;i++) newDeck.push(id);
 });
 savedDecks[currentDeckSlot] = newDeck;
 savePlayerDecks();
 alert(`ãƒ‡ãƒƒã‚­${currentDeckSlot+1}ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼`);
}

/* ========== CPUè¨­å®š ========== */
let cpuStrength = "normal";
let cpuColor = "red";
let playerDeckMode = "default";

function openCpuConfig() {
 updateCpuButtons();
 updatePlayerDeckButtons();
 showScreen("cpu");
}
function setCpuStrength(s) {
 cpuStrength = s;
 updateCpuButtons();
}
function setCpuColor(color) {
 cpuColor = color;
 updateCpuButtons();
}
function updateCpuButtons() {
 document.getElementById("btnCpuNormal").classList.toggle("toggle-selected", cpuStrength==="normal");
 document.getElementById("btnCpuStrong").classList.toggle("toggle-selected", cpuStrength==="strong");
 const colors = ["red","purple","blue","yellow","white","green"];
 colors.forEach(c => {
   const btnId = "cpu" + c.charAt(0).toUpperCase() + c.slice(1);
   const btn = document.getElementById(btnId);
   if (!btn) return;
   btn.classList.toggle("toggle-selected", cpuColor===c);
 });
}
function hasDeckInSlot(slotIndex) {
 const deck = savedDecks[slotIndex];
 return deck && deck.length > 0;
}
function updatePlayerDeckButtons() {
 const btnDef = document.getElementById("btnPlayerDefault");
 const b1 = document.getElementById("btnDeck1");
 const b2 = document.getElementById("btnDeck2");
 const b3 = document.getElementById("btnDeck3");

 if (btnDef) {
   btnDef.classList.toggle("toggle-selected", playerDeckMode==="default");
 }
 const arr = [b1,b2,b3];
 ["slot1","slot2","slot3"].forEach((mode,idx) => {
   const btn = arr[idx];
   if (!btn) return;
   const has = hasDeckInSlot(idx);
   btn.disabled = !has;
   btn.classList.toggle("toggle-selected", playerDeckMode===mode);
   btn.textContent = has ? `ãƒ‡ãƒƒã‚­${idx+1}` : `ãƒ‡ãƒƒã‚­${idx+1}ï¼ˆæœªä¿å­˜ï¼‰`;
 });
}
function selectPlayerDeck(mode) {
 if (mode.startsWith("slot")) {
   const idx = parseInt(mode.slice(-1),10) - 1;
   if (!hasDeckInSlot(idx)) {
     alert("ã¾ãšãƒ‡ãƒƒã‚­ç·¨é›†ã§ã“ã®ã‚¹ãƒ­ãƒƒãƒˆã«ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜ã—ã¦ãã ã•ã„ã€‚");
     return;
   }
 }
 playerDeckMode = mode;
 updatePlayerDeckButtons();
}

/* ========== ãƒãƒˆãƒ« ========== */
let battle = null;
let pendingChallenge = null;
let elsaEffectState = null;

function shuffle(arr) {
 for (let i=arr.length-1;i>0;i--) {
   const j = Math.floor(Math.random()*(i+1));
   [arr[i],arr[j]] = [arr[j],arr[i]];
 }
}

function startBattle() {
 let playerDeckCards = [];
 if (playerDeckMode !== "default") {
   const idx = parseInt(playerDeckMode.slice(-1),10) - 1;
   const deckIds = savedDecks[idx] || [];
   deckIds.forEach(id => {
     const base = cards.find(c => c.id===id);
     if (base) playerDeckCards.push(makeCardInstance(base));
   });
 }

 if (playerDeckCards.length === 0) {
   for (let i=0;i<24;i++) playerDeckCards.push(makeCardInstance(cards[0]));
   playerDeckCards.push(makeCardInstance(cards[6]));
   playerDeckCards.push(makeCardInstance(cards[8]));
 }

 let cpuDeckCards = [];
 const baseN  = cards.filter(c => c.rarity==="N"  && c.color===cpuColor);
 const baseSR = cards.filter(c => c.rarity==="SR" && (cpuStrength==="normal" || cpuStrength==="strong"));
 const baseL  = cards.filter(c => c.rarity==="L"  && cpuStrength==="strong");
 for (let i=0;i<24;i++) {
   const src = baseN.length ? baseN : cards.filter(c=>c.rarity==="N");
   cpuDeckCards.push(makeCardInstance(src[i % src.length]));
 }
 if (baseSR.length) cpuDeckCards.push(makeCardInstance(baseSR[0]));
 if (baseL.length)  cpuDeckCards.push(makeCardInstance(baseL[0]));

 shuffle(playerDeckCards);
 shuffle(cpuDeckCards);

 battle = {
   turn: "player",
   turnCount: 0,
   gameOver: false,
   player: {
     deck: playerDeckCards,
     hand: [],
     field: [],
     lore: 0,
     inkTotal: 0,
     inkAvail: 0,
     hasDrawn: false,
     hasInked: false
   },
   cpu: {
     deck: cpuDeckCards,
     hand: [],
     field: [],
     lore: 0,
     inkTotal: 0,
     inkAvail: 0,
     hasDrawn: false,
     hasInked: false
   }
 };

 for (let i=0;i<7;i++) {
   if (battle.player.deck.length) battle.player.hand.push(battle.player.deck.pop());
   if (battle.cpu.deck.length)    battle.cpu.hand.push(battle.cpu.deck.pop());
 }

 clearLog();
 addLog("ãƒãƒˆãƒ«é–‹å§‹ï¼");
 startPlayerTurn();
 showScreen("battle");
}

/* --- ã‚¿ãƒ¼ãƒ³ç®¡ç† --- */

function readyFieldCardsForSide(sideObj) {
 sideObj.field.forEach(card => {
   const skip = card.skipReadyTurn || 0;
   if (skip >= battle.turnCount) {
     card.rest = true;
   } else {
     card.rest = false;
   }
 });
}

function startPlayerTurn() {
 if (!battle) return;
 battle.turn = "player";
 battle.turnCount++;

 const p = battle.player;
 p.inkAvail = p.inkTotal;
 p.hasDrawn = false;
 p.hasInked = false;

 readyFieldCardsForSide(p);

 pendingChallenge = null;
 elsaEffectState = null;

 const turnInfo = document.getElementById("turnInfo");
 if (turnInfo) turnInfo.textContent = "è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³";

 const area = document.getElementById("actionArea");
 if (area) area.textContent = "ã¾ãšãƒ‰ãƒ­ãƒ¼ã—ã¦ãã ã•ã„ã€‚";

 updateBattleView();
}

function startCpuTurn() {
 if (!battle) return;
 battle.turn = "cpu";
 battle.turnCount++;

 const c = battle.cpu;
 c.inkAvail = c.inkTotal;
 c.hasDrawn = false;
 c.hasInked = false;

 readyFieldCardsForSide(c);
 pendingChallenge = null;
 elsaEffectState = null;

 if (c.deck.length) {
   c.hand.push(c.deck.pop());
   c.hasDrawn = true;
   addLog("CPUã¯1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚");
 }

 for (let i=0;i<c.hand.length;i++) {
   const card = c.hand[i];
   if (card.inkable) {
     c.hand.splice(i,1);
     c.inkTotal++;
     c.inkAvail++;
     c.hasInked = true;
     addLog("CPUã¯1æšã‚¤ãƒ³ã‚¯ã«ç½®ã„ãŸã€‚");
     break;
   }
 }

 let bestIndex = -1;
 let bestCost  = -1;
 c.hand.forEach((card,idx) => {
   if (card.cost <= c.inkAvail && card.cost > bestCost) {
     bestCost = card.cost;
     bestIndex = idx;
   }
 });

 if (bestIndex >= 0) {
   const card = c.hand[bestIndex];
   c.inkAvail -= card.cost;
   c.hand.splice(bestIndex,1);

   if (card.type === "song" && card.name === "çµ‚ç„‰ã®å¤§ç«") {
     addLog(`CPUã¯ã‚½ãƒ³ã‚°ã€Œ${card.name}ã€ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸï¼ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¸Šã®ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ç ´å£Šã™ã‚‹ã€‚`);
     wipeAllCharacters();
   } else {
     card.summonTurn = battle.turnCount;
     card.rest = true;
     c.field.push(card);
     addLog(`CPUã¯ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);

     if (card.name === "è¦šé†’ã‚¨ãƒ«ã‚µ") {
       triggerElsaEffectCpu();
     }
   }
 }

 if (c.field.length) {
   c.lore += 1;
   addLog("CPUã¯ãƒ­ã‚¢ã‚’1å¾—ãŸã€‚ï¼ˆãƒ†ã‚¹ãƒˆï¼‰");
 }

 updateBattleView();

 if (battle && !battle.gameOver) {
   startPlayerTurn();
 }
}

/* --- æç”» --- */

function updateBattleView() {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;

 const pLore = document.getElementById("playerLore");
 const pInkCur = document.getElementById("playerInkCurrent");
 const pInkMax = document.getElementById("playerInkMax");
 const pDeck = document.getElementById("playerDeck");
 const cLore = document.getElementById("cLore");
 const cDeck = document.getElementById("cDeck");
 const cpuHand = document.getElementById("cpuHandCount");

 if (pLore)   pLore.textContent   = p.lore;
 if (pInkCur) pInkCur.textContent = p.inkAvail;
 if (pInkMax) pInkMax.textContent = p.inkTotal;
 if (pDeck)   pDeck.textContent   = p.deck.length;
 if (cLore)   cLore.textContent   = c.lore;
 if (cDeck)   cDeck.textContent   = c.deck.length;
 if (cpuHand) cpuHand.textContent = c.hand.length;

 const pf = document.getElementById("playerField");
 pf.innerHTML = p.field.map((card, idx) => `
   <div class="card ${card.color || ''} ${card.rest ? 'rest' : ''}"
        onclick="onPlayerFieldClick(${idx})">
     <div class="card-header">
       <span class="card-cost">${card.cost}</span>
       <span class="card-name-header">${card.name}</span>
       <span class="card-inkable">${card.inkable ? "â­•ï¸" : "âŒ"}</span>
     </div>
     <div class="card-illust"></div>
     <div class="card-stats-row">
       <span class="card-power">${
         card.type === "character"
           ? `${card.atk} / ${card.hp}/${card.maxHp}`
           : "ã‚¹ãƒšãƒ«"
       }</span>
       <span class="card-lore">${card.lore ? "ãƒ­ã‚¢"+card.lore : ""}</span>
     </div>
     <div class="card-footer">
       ${
         card.type === "song"
           ? "songï¼ˆã‚¹ãƒšãƒ«ï¼‰"
           : ("character" + (card.evade ? " / å›é¿" : ""))
       }
     </div>
   </div>
 `).join("");

 const cf = document.getElementById("cpuField");
 cf.innerHTML = c.field.map((card, idx) => `
   <div class="card ${card.color || ''} ${card.rest ? 'rest' : ''}"
        onclick="onCpuFieldClick(${idx})">
     <div class="card-header">
       <span class="card-cost">${card.cost}</span>
       <span class="card-name-header">${card.name}</span>
       <span class="card-inkable">æ•µ</span>
     </div>
     <div class="card-illust"></div>
     <div class="card-stats-row">
       <span class="card-power">${
         card.type === "character"
           ? `${card.atk} / ${card.hp}/${card.maxHp}`
           : "ã‚¹ãƒšãƒ«"
       }</span>
       <span class="card-lore">${card.lore ? "ãƒ­ã‚¢"+card.lore : ""}</span>
     </div>
     <div class="card-footer">
       ${
         card.type === "song"
           ? "song"
           : ("character" + (card.evade ? " / å›é¿" : ""))
       }
     </div>
   </div>
 `).join("");

 const ph = document.getElementById("playerHand");
 ph.innerHTML = p.hand.map((card, idx) => `
   <div class="card ${card.color || ''}">
     <div class="card-header">
       <span class="card-cost">${card.cost}</span>
       <span class="card-name-header">${card.name}</span>
       <span class="card-inkable">${card.inkable ? "â­•ï¸" : "âŒ"}</span>
     </div>
     <div class="card-illust"></div>
     <div class="card-stats-row">
       <span class="card-power">${
         card.type === "character"
           ? `${card.atk} / ${card.hp}/${card.maxHp}`
           : "ã‚¹ãƒšãƒ«"
       }</span>
       <span class="card-lore">${card.lore ? "ãƒ­ã‚¢"+card.lore : ""}</span>
     </div>
     <div class="card-footer">
       <div class="card-footer-buttons">
         <button class="btn small" onclick="inkFromHand(${idx})">ã‚¤ãƒ³ã‚¯</button>
         <button class="btn small" onclick="playFromHand(${idx})">å¬å–š</button>
       </div>
     </div>
   </div>
 `).join("");

 const btnDraw = document.getElementById("btnDraw");
 if (btnDraw) {
   btnDraw.disabled = (battle.turn !== "player") || p.hasDrawn || battle.gameOver;
 }

 checkWin();
}

/* --- å‹æ•—åˆ¤å®š --- */

function checkWin() {
 if (!battle || battle.gameOver) return;
 const p = battle.player;
 const c = battle.cpu;

 if (p.lore >= 20 && c.lore >= 20) {
   showWin("draw");
 } else if (p.lore >= 20) {
   showWin("player");
 } else if (c.lore >= 20) {
   showWin("cpu");
 }
}

function showWin(who) {
 if (!battle) return;
 battle.gameOver = true;

 const overlay = document.getElementById("winOverlay");
 const msg = document.getElementById("winMessage");
 if (!overlay || !msg) return;

 if (who === "player") {
   msg.textContent = "ã‚ãªãŸã®å‹ã¡ï¼ 20ãƒ­ã‚¢é”æˆï¼";
 } else if (who === "cpu") {
   msg.textContent = "CPUã®å‹ã¡â€¦ 20ãƒ­ã‚¢ã‚’å…ˆã«å–ã‚‰ã‚Œã¾ã—ãŸã€‚";
 } else {
   msg.textContent = "å¼•ãåˆ†ã‘ï¼";
 }

 overlay.classList.remove("hidden");
}

function returnToMenuFromBattle() {
 const overlay = document.getElementById("winOverlay");
 if (overlay) overlay.classList.add("hidden");
 battle = null;
 showScreen("menu");
}

/* --- è¦šé†’ã‚¨ãƒ«ã‚µï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å´ï¼‰ --- */

function triggerElsaEffect() {
 if (!battle) return;
 const c = battle.cpu;
 if (!c.field.length) {
   addLog("è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ã€ä½•ã‚‚èµ·ã“ã‚‰ãªã‹ã£ãŸã€‚");
   return;
 }

 addLog("è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœï¼šç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’æœ€å¤§2ä½“ã¾ã§ãƒ¬ã‚¹ãƒˆã—ã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã‚‚ãƒ¬ãƒ‡ã‚£ã—ãªã„ã€‚");

 elsaEffectState = {
   selected: [null, null],
   activeSlot: 0
 };

 const area = document.getElementById("actionArea");
 if (area) {
   area.innerHTML = `
     <div style="margin-bottom:4px;">
       è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœï¼š<br>
       ã€Œãƒ¬ã‚¹ãƒˆã•ã›ã¦æ¬¡ã®ã‚¿ãƒ¼ãƒ³å‹•ã‹ã›ãªããªã‚‹ã‚­ãƒ£ãƒ©ã€ã‚’
       æœ€å¤§2ä½“ã¾ã§é¸ã‚“ã§ãã ã•ã„ã€‚<br>
       ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã‚ã¨ã€ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠã—ã¾ã™ã€‚
     </div>
     <button class="btn small" onclick="startElsaSelect(1)">1ä½“ç›®ã‚’é¸æŠ</button>
     <button class="btn small" onclick="startElsaSelect(2)">2ä½“ç›®ã‚’é¸æŠ</button>
     <button class="btn small" onclick="finishElsaSelect()">é¸æŠçµ‚äº†</button>
   `;
 }
}

function startElsaSelect(slot) {
 if (!battle) return;
 const c = battle.cpu;
 if (!c.field.length) {
   alert("ç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ãŒã„ã¾ã›ã‚“ã€‚");
   return;
 }
 if (!elsaEffectState) {
   elsaEffectState = { selected:[null,null], activeSlot:0 };
 }
 elsaEffectState.activeSlot = slot;

 const area = document.getElementById("actionArea");
 if (area) {
   area.innerHTML = `
     <div style="margin-bottom:4px;">
       è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœï¼š${slot}ä½“ç›®ã®å¯¾è±¡ã‚’é¸æŠä¸­ã§ã™ã€‚<br>
       ç›¸æ‰‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚
     </div>
     <button class="btn small" onclick="startElsaSelect(1)">1ä½“ç›®ã‚’é¸æŠ</button>
     <button class="btn small" onclick="startElsaSelect(2)">2ä½“ç›®ã‚’é¸æŠ</button>
     <button class="btn small" onclick="finishElsaSelect()">é¸æŠçµ‚äº†</button>
   `;
 }
}

function finishElsaSelect() {
 elsaEffectState = null;
 const area = document.getElementById("actionArea");
 if (area) {
   area.innerHTML = `
     <div>
       è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœã®å¯¾è±¡é¸æŠã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚<br>
       æ®‹ã‚Šã®ã‚­ãƒ£ãƒ©ã¯é€šå¸¸é€šã‚Šè¡Œå‹•ã§ãã¾ã™ã€‚
     </div>
   `;
 }
}

function triggerElsaEffectCpu() {
 if (!battle) return;
 const p = battle.player;
 if (!p.field.length) {
   addLog("CPUã®è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚­ãƒ£ãƒ©ãŒã„ãªã„ãŸã‚ã€ä½•ã‚‚èµ·ã“ã‚‰ãªã‹ã£ãŸã€‚");
   return;
 }
 const indices = p.field.map((_,idx)=>idx);
 shuffle(indices);
 const targets = indices.slice(0,2);
 targets.forEach(idx => {
   const card = p.field[idx];
   card.rest = true;
   card.skipReadyTurn = battle.turnCount + 1;
   addLog(`CPUã®è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœã§ã€Œ${card.name}ã€ãŒãƒ¬ã‚¹ãƒˆã•ã‚Œã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã‚‚ãƒ¬ãƒ‡ã‚£ã—ãªã„ã€‚`);
 });
}

/* --- çµ‚ç„‰ã®å¤§ç« --- */

function wipeAllCharacters() {
 if (!battle) return;
 const p = battle.player;
 const c = battle.cpu;

 p.field = p.field.filter(card => card.type !== "character");
 c.field = c.field.filter(card => card.type !== "character");

 updateBattleView();
}

/* --- è‡ªåˆ†ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¯ãƒªãƒƒã‚¯ --- */

function onPlayerFieldClick(index) {
 if (!battle) return;
 const p = battle.player;
 const card = p.field[index];
 if (!card) return;

 const area = document.getElementById("actionArea");
 let html = `
   <div class="card-box ${card.color || ''}">
     <div class="card-name">${card.name}</div>
     <div class="card-stats">
       ATK:${card.atk} / HP:${card.hp}/${card.maxHp} / ãƒ­ã‚¢:${card.lore || 0}
     </div>
     <div class="card-stats">
       ç¨®é¡:${card.type}${card.evade ? " / å›é¿" : ""}
     </div>
   </div>
 `;

 if (battle.turn !== "player" || battle.gameOver) {
   area.innerHTML = html + `<div class="card-stats">ä»Šã¯è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</div>`;
   return;
 }

 if (card.summonTurn === battle.turnCount) {
   area.innerHTML = html + `<div class="card-stats">ã“ã®ã‚¿ãƒ¼ãƒ³ã«å‡ºãŸã‚­ãƒ£ãƒ©ã§ã™ï¼ˆå¬å–šé…”ã„ï¼‰ã€‚</div>`;
   return;
 }

 if (card.rest) {
   area.innerHTML = html + `<div class="card-stats">ã“ã®ã‚­ãƒ£ãƒ©ã¯ã™ã§ã«è¡Œå‹•ã—ã¾ã—ãŸã€‚</div>`;
   return;
 }

 area.innerHTML = html + `
   <div class="card-stats">è¡Œå‹•ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</div>
   <button class="btn small" onclick="doSeek(${index})">Seekï¼ˆãƒ­ã‚¢ã‚’å¾—ã‚‹ï¼‰</button>
   <button class="btn small" onclick="prepareChallenge(${index})">ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼ˆæ”»æ’ƒï¼‰</button>
 `;
}

/* --- CPUãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¯ãƒªãƒƒã‚¯ --- */

function onCpuFieldClick(index) {
 if (!battle) return;
 const c = battle.cpu;
 const card = c.field[index];
 if (!card) return;

 if (elsaEffectState && elsaEffectState.activeSlot) {
   const slot = elsaEffectState.activeSlot;
   const pos  = slot - 1;

   elsaEffectState.selected[pos] = index;

   card.rest = true;
   card.skipReadyTurn = battle.turnCount + 1;

   addLog(`è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœã§ã€Œ${card.name}ã€ã‚’${slot}ä½“ç›®ã®å¯¾è±¡ã¨ã—ã¦ãƒ¬ã‚¹ãƒˆã—ã€æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã‚‚ãƒ¬ãƒ‡ã‚£ã—ãªã„ã€‚`);

   elsaEffectState.activeSlot = 0;
   updateBattleView();

   const area2 = document.getElementById("actionArea");
   if (area2) {
     area2.innerHTML = `
       <div style="margin-bottom:4px;">
         è¦šé†’ã‚¨ãƒ«ã‚µã®åŠ¹æœï¼š${slot}ä½“ç›®ã«ã€Œ${card.name}ã€ã‚’é¸ã³ã¾ã—ãŸã€‚<br>
         ç¶šã‘ã¦ã€Œ1ä½“ç›®ã€ã¾ãŸã¯ã€Œ2ä½“ç›®ã€ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦åˆ¥ã®ã‚­ãƒ£ãƒ©ã‚’é¸ã¶ã‹ã€<br>
         ã€Œé¸æŠçµ‚äº†ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚
       </div>
       <button class="btn small" onclick="startElsaSelect(1)">1ä½“ç›®ã‚’é¸æŠ</button>
       <button class="btn small" onclick="startElsaSelect(2)">2ä½“ç›®ã‚’é¸æŠ</button>
       <button class="btn small" onclick="finishElsaSelect()">é¸æŠçµ‚äº†</button>
     `;
   }
   return;
 }

 const area = document.getElementById("actionArea");
 let html = `
   <div class="card-box ${card.color || ''}">
     <div class="card-name">${card.name}</div>
     <div class="card-stats">
       ATK:${card.atk} / HP:${card.hp}/${card.maxHp} / ãƒ­ã‚¢:${card.lore || 0}
     </div>
     <div class="card-stats">
       ç¨®é¡:${card.type}${card.evade ? " / å›é¿" : ""}ï¼ˆç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ï¼‰
     </div>
   </div>
 `;

 if (pendingChallenge !== null) {
   resolvePlayerChallenge(pendingChallenge, index);
   pendingChallenge = null;
   return;
 }

 area.innerHTML = html;
}

/* --- Seek & ãƒãƒ£ãƒ¬ãƒ³ã‚¸ --- */

function doSeek(index) {
 if (!battle || battle.gameOver) return;
 const p = battle.player;
 const card = p.field[index];
 if (!card || card.type!=="character") return;
 if (battle.turn !== "player") return;
 if (card.summonTurn === battle.turnCount) {
   alert("ã“ã®ã‚¿ãƒ¼ãƒ³ã«å‡ºãŸã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ãã¾ã›ã‚“ã€‚");
   return;
 }
 if (card.rest) {
   alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯ã™ã§ã«è¡Œå‹•ã—ã¦ã„ã¾ã™ã€‚");
   return;
 }
 p.lore += card.lore || 0;
 card.rest = true;
 addLog(`è‡ªåˆ†ã®ã€Œ${card.name}ã€ãŒSeekã—ã¦ãƒ­ã‚¢ã‚’${card.lore || 0}å¾—ãŸã€‚`);
 const area = document.getElementById("actionArea");
 if (area) area.innerHTML = "";
 updateBattleView();
}

function prepareChallenge(index) {
 if (!battle || battle.gameOver) return;
 const p = battle.player;
 const card = p.field[index];
 if (!card || card.type!=="character") return;
 if (battle.turn !== "player") return;
 if (card.summonTurn === battle.turnCount) {
   alert("ã“ã®ã‚¿ãƒ¼ãƒ³ã«å‡ºãŸã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ãã¾ã›ã‚“ã€‚");
   return;
 }
 if (card.rest) {
   alert("ã“ã®ã‚­ãƒ£ãƒ©ã¯ã™ã§ã«è¡Œå‹•ã—ã¦ã„ã¾ã™ã€‚");
   return;
 }
 pendingChallenge = index;
 addLog(`ã€Œ${card.name}ã€ã®ãƒãƒ£ãƒ¬ãƒ³ã‚¸å¯¾è±¡ã«ã™ã‚‹ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚`);
}

function resolvePlayerChallenge(pIndex, cIndex) {
 if (!battle || battle.gameOver) return;
 const p = battle.player;
 const c = battle.cpu;
 const attacker = p.field[pIndex];
 const target   = c.field[cIndex];
 if (!attacker || !target) {
   addLog("æ”»æ’ƒå¯¾è±¡ãŒã„ã¾ã›ã‚“ã§ã—ãŸã€‚");
   return;
 }
 if (attacker.summonTurn === battle.turnCount || attacker.rest) {
   addLog("ã“ã®ã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ãã¾ã›ã‚“ã€‚");
   return;
 }

 if (target.evade && !attacker.evade) {
   addLog(`ã€Œ${target.name}ã€ã¯å›é¿ã‚’æŒã¤ãŸã‚ã€ã€Œ${attacker.name}ã€ã¯ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã§ããªã„ã€‚`);
   return;
 }

 target.hp   -= attacker.atk;
 attacker.hp -= target.atk;

 addLog(`ã€Œ${attacker.name}ã€ãŒã€Œ${target.name}ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`);
 addLog(`  ${target.name} ã«${attacker.atk}ãƒ€ãƒ¡ãƒ¼ã‚¸ / ${attacker.name} ã«${target.atk}ãƒ€ãƒ¡ãƒ¼ã‚¸`);

 if (target.hp <= 0) {
   c.field.splice(cIndex,1);
   addLog(`  ã€Œ${target.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
 }
 if (attacker.hp <= 0) {
   p.field.splice(pIndex,1);
   addLog(`  ã€Œ${attacker.name}ã€ã¯é€€å ´ã—ãŸã€‚`);
 } else {
   attacker.rest = true;
 }

 const area = document.getElementById("actionArea");
 if (area) area.innerHTML = "";
 updateBattleView();
}

/* --- æ‰‹æœ­ã®è¡Œå‹• --- */

function playerDraw() {
 if (!battle || battle.gameOver) return;
 const p = battle.player;
 if (battle.turn !== "player") return;
 if (p.hasDrawn) {
   alert("ã“ã®ã‚¿ãƒ¼ãƒ³ã¯æ—¢ã«ãƒ‰ãƒ­ãƒ¼ã—ã¦ã„ã¾ã™ã€‚");
   return;
 }
 if (!p.deck.length) {
   alert("å±±æœ­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");
   return;
 }
 p.hand.push(p.deck.pop());
 p.hasDrawn = true;
 addLog("è‡ªåˆ†ã¯1æšãƒ‰ãƒ­ãƒ¼ã—ãŸã€‚");
 updateBattleView();
}

function requireDrawFirst() {
 const p = battle.player;
 if (!p.hasDrawn) {
   alert("ã¾ãšãƒ‰ãƒ­ãƒ¼ã—ã¦ãã ã•ã„ã€‚");
   return false;
 }
 return true;
}

function inkFromHand(index) {
 if (!battle || battle.gameOver) return;
 if (battle.turn !== "player") return;
 const p = battle.player;
 if (!requireDrawFirst()) return;
 if (p.hasInked) {
   alert("ã“ã®ã‚¿ãƒ¼ãƒ³ã¯æ—¢ã«ã‚¤ãƒ³ã‚¯ã‚’ç½®ã„ã¦ã„ã¾ã™ã€‚");
   return;
 }
 const card = p.hand[index];
 if (!card || !card.inkable) {
   alert("ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ã‚¤ãƒ³ã‚¯ã«ã§ãã¾ã›ã‚“ã€‚");
   return;
 }
 p.hand.splice(index,1);
 p.inkTotal++;
 p.inkAvail++;
 p.hasInked = true;
 addLog(`è‡ªåˆ†ã¯ã€Œ${card.name}ã€ã‚’ã‚¤ãƒ³ã‚¯ã«ç½®ã„ãŸã€‚`);
 updateBattleView();
}

function playFromHand(index) {
 if (!battle || battle.gameOver) return;
 if (battle.turn !== "player") return;
 const p = battle.player;
 if (!requireDrawFirst()) return;
 const card = p.hand[index];
 if (!card) return;

 if (card.type === "song" && card.name === "çµ‚ç„‰ã®å¤§ç«") {
   if (p.inkAvail < card.cost) {
     alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
     return;
   }
   p.inkAvail -= card.cost;
   p.hand.splice(index,1);
   addLog(`è‡ªåˆ†ã¯ã‚½ãƒ³ã‚°ã€Œ${card.name}ã€ã‚’ãƒ—ãƒ¬ã‚¤ã—ãŸï¼ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¸Šã®ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ç ´å£Šã™ã‚‹ã€‚`);
   wipeAllCharacters();
   return;
 }

 if (card.name === "è¦šé†’ã‚¨ãƒ«ã‚µ" && typeof card.transformCost === "number") {
   const candidates = p.field
     .map((c,idx) => ({ card:c, idx }))
     .filter(obj => obj.card.type === "character" && obj.card.name.includes("ã‚¨ãƒ«ã‚µ"));

   if (candidates.length > 0 && p.inkAvail >= card.transformCost) {
     const useTransform = confirm(`åŒåã®ã‚­ãƒ£ãƒ©ãŒã„ã‚‹ã®ã§ã€å¤‰èº«ã‚³ã‚¹ãƒˆ${card.transformCost}ã§å‡ºã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆOKã§å¤‰èº« / ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§é€šå¸¸ã‚³ã‚¹ãƒˆ${card.cost}ï¼‰`);
     if (useTransform) {
       const baseObj = candidates[0];
       const baseCard = baseObj.card;

       const damage = baseCard.maxHp - baseCard.hp;
       const newCard = card;

       newCard.maxHp = 6;
       newCard.hp = Math.max(1, newCard.maxHp - damage);

       if (baseCard.summonTurn < battle.turnCount && !baseCard.rest) {
         newCard.summonTurn = battle.turnCount - 1;
         newCard.rest = false;
       } else {
         newCard.summonTurn = battle.turnCount;
         newCard.rest = true;
       }

       p.field[baseObj.idx] = newCard;

       p.inkAvail -= newCard.transformCost;
       p.hand.splice(index,1);

       addLog(`è‡ªåˆ†ã¯ã€Œ${baseCard.name}ã€ã‚’ã€Œè¦šé†’ã‚¨ãƒ«ã‚µã€ã«å¤‰èº«ã•ã›ãŸï¼ï¼ˆå¤‰èº«ã‚³ã‚¹ãƒˆ${newCard.transformCost}ï¼‰`);

       triggerElsaEffect();
       updateBattleView();
       return;
     }
   }
 }

 if (p.inkAvail < card.cost) {
   alert("ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚");
   return;
 }
 p.inkAvail -= card.cost;
 card.summonTurn = battle.turnCount;
 card.rest = true;
 p.hand.splice(index,1);
 p.field.push(card);
 addLog(`è‡ªåˆ†ã¯ã€Œ${card.name}ã€ã‚’å¬å–šã—ãŸã€‚`);

 if (card.name === "è¦šé†’ã‚¨ãƒ«ã‚µ") {
   triggerElsaEffect();
 }

 updateBattleView();
}

function endTurn() {
 if (!battle || battle.gameOver) return;
 if (battle.turn !== "player") return;
 addLog("è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³çµ‚äº†ã€‚CPUã®ã‚¿ãƒ¼ãƒ³ã€‚");
 updateBattleView();
 startCpuTurn();
}

/* --- ãƒãƒˆãƒ«ä¸­æ–­ --- */
function quitBattleToMenu() {
 if (!battle) {
   showScreen("menu");
   return;
 }
 const ok = confirm("æœ¬å½“ã«ãƒãƒˆãƒ«ã‚’çµ‚äº†ã—ã¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ");
 if (!ok) return;
 battle = null;
 showScreen("menu");
}

/* --- ãƒ­ã‚° --- */
function clearLog() {
 const el = document.getElementById("log");
 if (el) el.innerHTML = "";
}
function addLog(text) {
 const el = document.getElementById("log");
 if (!el) return;
 const div = document.createElement("div");
 div.textContent = text;
 el.appendChild(div);
 el.scrollTop = el.scrollHeight;
}

/* ========== åˆæœŸåŒ– ========== */
window.onload = function() {
 loadData();
 updateDeckSlotButtons();
 showScreen("menu");
};
</script>
</body>
</html>
