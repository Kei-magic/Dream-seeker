<!-- ===========================
  Dream-seeker TCG (Single HTML)
  Part 1 / 2
=========================== -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Dream-seeker TCG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#181818;color:#f5f5f5}
    h1,h2{text-align:center;margin:12px 0}
    .screen{display:none;padding:10px;max-width:780px;margin:0 auto}
    .screen.active{display:block}
    .btn{width:100%;padding:10px;margin:6px 0;border-radius:10px;border:none;cursor:pointer;font-size:14px;background:#444;color:#f5f5f5}
    .btn.primary{background:#2ecc71;color:#000}
    .btn.danger{background:#e74c3c}
    .btn.small{width:auto;padding:4px 8px;font-size:12px;margin:2px 4px 0 0;border-radius:8px}
    .row{display:flex;gap:6px}
    .row>.btn{flex:1}
    .toggle-selected{background:#f39c12!important;color:#000!important}
    .stone-bar{font-size:13px;padding:6px 8px;border-radius:10px;background:#222;display:inline-block;margin-bottom:8px}
    .section-title{font-size:13px;margin:10px 0 4px;font-weight:bold}

    .battle-screen{padding:12px}
    .enemy-title{text-align:center;font-size:18px;margin-bottom:6px}
    .enemy-status{display:flex;justify-content:space-around;margin-bottom:6px;font-size:13px;gap:8px;flex-wrap:wrap}
    #cpuField,#playerField,#playerHand{display:flex;align-items:flex-start;gap:10px;overflow-x:auto;padding:8px 0;min-height:170px;-webkit-overflow-scrolling:touch}
    .divider{border-top:3px dashed #fff;margin:12px 0}

    .bottom-ui{display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .status-box,.effect-box{width:49%;min-height:130px;border:2px solid #fff;padding:8px;border-radius:12px}
    .status-box-title,.effect-box-title{font-weight:bold;margin-bottom:4px}
    .turn-info{margin-top:4px;font-weight:bold}
    .status-buttons{margin-top:8px;display:flex;flex-wrap:wrap;gap:6px}

    .log{background:#111;border-radius:12px;padding:8px;font-size:11px;height:150px;overflow-y:auto;border:1px solid #333;margin-top:6px}

    /* Card */
    .card{flex:0 0 auto;width:104px;height:168px;border-radius:12px;border:3px solid #555;background:#222;color:#fff;font-size:10px;padding:4px;display:flex;flex-direction:column;gap:3px;cursor:pointer;position:relative;overflow:hidden;transition:transform .1s,opacity .1s}
    .card:hover{transform:translateY(-2px)}
    .card.rest{opacity:.6;transform:rotate(8deg)}
    .card.frozen{outline:2px solid #00e5ff}
    .card.enchanted{border-color:#ffd700;box-shadow:0 0 10px rgba(255,215,0,.5)}
    .card-header{display:flex;justify-content:space-between;align-items:center;background:#000;border-radius:6px;padding:2px 4px;font-weight:bold}
    .card-name{flex:1;text-align:center;font-size:9px;line-height:1.1;margin:0 2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .card-ill{flex:1;border-radius:6px;background:#fff}
    .card-row{display:flex;justify-content:space-between;font-size:9px;opacity:.95}
    .card-footer{background:#000;border-radius:6px;padding:2px 4px;font-size:9px}

    .red{border-color:#e74c3c}.purple{border-color:#9b59b6}.blue{border-color:#3498db}
    .yellow{border-color:#f1c40f}.white{border-color:#ecf0f1;color:#000;background:#aaa}.green{border-color:#2ecc71}
    .white .card-header,.white .card-footer{background:#fff;color:#000}

    /* Modal */
    #overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,.72);z-index:999}
    #modal{background:#222;max-width:420px;margin:40px auto;padding:12px;border-radius:12px;border:1px solid #fff}
    #modalTitle{font-weight:bold;margin-bottom:6px}
    #modalBody{font-size:13px;white-space:pre-wrap}
    #modalBtns{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    #modalBtns .btn{width:auto;margin:0}

    /* Deck editor */
    .card-box{border:1px solid #555;border-radius:10px;padding:8px;margin:6px 0;font-size:12px;background:#202020}
    .card-box .line{opacity:.9;font-size:11px;margin-top:2px}
    .deck-meta{display:flex;gap:8px;flex-wrap:wrap;font-size:12px;opacity:.95;margin:6px 0}
    .pill{background:#222;border:1px solid #444;border-radius:999px;padding:4px 8px}
    .warn{color:#ffcc66}
  </style>
</head>
<body>

<!-- ===== Menu ===== -->
<div id="menuScreen" class="screen active">
  <h1>Dream-seeker TCG</h1>
  <div class="stone-bar">ğŸ’ ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="stoneCount">0</span></div>
  <button class="btn primary" onclick="openCpuConfig()">ãƒãƒˆãƒ«</button>
  <button class="btn" onclick="showShop()">ã‚·ãƒ§ãƒƒãƒ—</button>
  <button class="btn" onclick="showPack()">ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</button>
  <button class="btn" onclick="openDeckBuilder(0)">ãƒ‡ãƒƒã‚­ç·¨é›†</button>
  <button class="btn" onclick="openCollection()">ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</button>
</div>

<!-- ===== CPU config ===== -->
<div id="cpuScreen" class="screen">
  <h2>CPUè¨­å®š</h2>
  <div class="section-title">CPUã®å¼·ã•</div>
  <div class="row">
    <button id="btnCpuNormal" class="btn" onclick="setCpuStrength('normal')">æ™®é€š</button>
    <button id="btnCpuStrong" class="btn" onclick="setCpuStrength('strong')">å¼·ã„</button>
    <button id="btnCpuGod" class="btn" onclick="setCpuStrength('god')">é¬¼ï¼ˆæœ€å¼·ï¼‰</button>
  </div>

  <div class="section-title">CPUãƒ‡ãƒƒã‚­è‰²ï¼ˆ2è‰²ã¾ã§ï¼‰</div>
  <div class="row">
    <button id="cpuRed" class="btn" onclick="setCpuColor('red')">èµ¤</button>
    <button id="cpuPurple" class="btn" onclick="setCpuColor('purple')">ç´«</button>
    <button id="cpuBlue" class="btn" onclick="setCpuColor('blue')">é’</button>
  </div>
  <div class="row">
    <button id="cpuYellow" class="btn" onclick="setCpuColor('yellow')">é»„</button>
    <button id="cpuWhite" class="btn" onclick="setCpuColor('white')">ç™½</button>
    <button id="cpuGreen" class="btn" onclick="setCpuColor('green')">ç·‘</button>
  </div>

  <div class="section-title">è‡ªåˆ†ã®ä½¿ç”¨ãƒ‡ãƒƒã‚­</div>
  <button id="btnPlayerDefault" class="btn" onclick="selectPlayerDeck('default')">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆèµ¤ç³»ï¼‰</button>
  <button id="btnDeck1" class="btn" onclick="selectPlayerDeck('deck1')">ãƒ‡ãƒƒã‚­1ï¼ˆæœªä¿å­˜ï¼‰</button>
  <button id="btnDeck2" class="btn" onclick="selectPlayerDeck('deck2')">ãƒ‡ãƒƒã‚­2ï¼ˆæœªä¿å­˜ï¼‰</button>
  <button id="btnDeck3" class="btn" onclick="selectPlayerDeck('deck3')">ãƒ‡ãƒƒã‚­3ï¼ˆæœªä¿å­˜ï¼‰</button>

  <button class="btn primary" onclick="startBattle()">ãƒãƒˆãƒ«é–‹å§‹</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>
</div>

<!-- ===== Battle ===== -->
<div id="battleScreen" class="screen">
  <div class="battle-screen">
    <div class="enemy-area">
      <div class="enemy-title">ç›¸æ‰‹</div>
      <div class="enemy-status">
        <span>æ‰‹æœ­ï¼š<span id="cpuHandCount">0</span>æš</span>
        <span>ãƒ­ã‚¢ï¼š<span id="cLore">0</span></span>
        <span>ã‚¤ãƒ³ã‚¯ï¼š<span id="cpuInkCur">0</span>/<span id="cpuInkMax">0</span></span>
        <span>å±±æœ­ï¼š<span id="cDeck">0</span>æš</span>
      </div>
      <div id="cpuField"></div>
    </div>

    <div class="divider"></div>

    <div class="player-area">
      <div id="playerField"></div>
      <div id="playerHand"></div>

      <div class="bottom-ui">
        <div class="status-box">
          <div class="status-box-title">è‡ªåˆ†ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
          <div>ãƒ­ã‚¢ï¼š<span id="playerLore">0</span></div>
          <div>ã‚¤ãƒ³ã‚¯ï¼š<span id="playerInkCurrent">0</span> / <span id="playerInkMax">0</span></div>
          <div>å±±æœ­ï¼š<span id="playerDeck">0</span></div>
          <div id="turnInfo" class="turn-info">è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³</div>
          <div style="font-size:11px;opacity:.85;margin-top:4px;">
            â€» ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ãƒ‰ãƒ­ãƒ¼ã¯è‡ªå‹•ï¼ˆå…ˆè¡Œ1Tç›®ã¯ç„¡ã—ï¼‰<br>
            â€» è¿½åŠ ãƒ‰ãƒ­ãƒ¼ã¯ã‚«ãƒ¼ãƒ‰åŠ¹æœã®ã¿
          </div>

          <div class="status-buttons">
            <button class="btn small" onclick="endTurn()">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
            <button class="btn small danger" onclick="endBattleToMenu()">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸</button>
          </div>
        </div>

        <div class="effect-box">
          <div class="effect-box-title">è¡Œå‹•</div>
          <div id="actionArea">ã‚«ãƒ¼ãƒ‰ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨è¡Œå‹•ãŒå‡ºã¾ã™ã€‚</div>
        </div>
      </div>

      <div class="section-title">ãƒ­ã‚°</div>
      <div id="log" class="log"></div>
    </div>
  </div>
</div>

<!-- ===== Shop ===== -->
<div id="shopScreen" class="screen">
  <h2>ã‚·ãƒ§ãƒƒãƒ—</h2>
  <p style="font-size:12px;opacity:.85;">çŸ³ã‚’è²·ã†ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰ã€‚</p>
  <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="shopStoneCount">0</span></p>
  <button class="btn" onclick="addStones(20)">çŸ³ã‚’+20</button>
  <button class="btn" onclick="addStones(100)">çŸ³ã‚’+100</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>
</div>

<!-- ===== Pack ===== -->
<div id="packScreen" class="screen">
  <h2>ãƒ‘ãƒƒã‚¯ï¼ˆã‚¬ãƒãƒ£ï¼‰</h2>
  <p>ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³5å€‹ã§1ãƒ‘ãƒƒã‚¯ï¼ˆ5æšï¼‰</p>
  <p>æ‰€æŒãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³: <span id="packStoneCount">0</span></p>
  <button class="btn primary" onclick="openPack()">ãƒ‘ãƒƒã‚¯ã‚’é–‹ã‘ã‚‹</button>
  <div class="section-title">ä»Šå›ã®çµæœ</div>
  <div id="packResult"></div>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>
</div>

<!-- ===== Deck ===== -->
<div id="deckScreen" class="screen">
  <h2>ãƒ‡ãƒƒã‚­ç·¨é›†</h2>
  <div class="deck-meta">
    <span class="pill">ç·¨é›†ä¸­: ãƒ‡ãƒƒã‚­<span id="currentDeckLabel">1</span></span>
    <span class="pill">åˆè¨ˆ: <span id="deckTotal">0</span>æš</span>
    <span class="pill">è‰²: <span id="deckColors">-</span></span>
    <span class="pill warn">åŒåã¯4æšã¾ã§ï¼ˆé€šå¸¸ï¼‹Eåˆç®—ï¼‰</span>
  </div>

  <div class="row">
    <button class="btn" onclick="switchDeck(0)">ãƒ‡ãƒƒã‚­1</button>
    <button class="btn" onclick="switchDeck(1)">ãƒ‡ãƒƒã‚­2</button>
    <button class="btn" onclick="switchDeck(2)">ãƒ‡ãƒƒã‚­3</button>
  </div>

  <div id="deckCardList"></div>
  <button class="btn primary" onclick="saveDeck()">ä¿å­˜</button>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>
</div>

<!-- ===== Collection ===== -->
<div id="collectionScreen" class="screen">
  <h2>ã‚«ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«</h2>
  <div id="collectionList"></div>
  <button class="btn danger" onclick="showScreen('menu')">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>
</div>

<!-- ===== Modal ===== -->
<div id="overlay">
  <div id="modal">
    <div id="modalTitle"></div>
    <div id="modalBody"></div>
    <div id="modalBtns"></div>
  </div>
</div>

<script>
/* ===========================
  Fixed Rules (important)
  - Ink: from hand, 1 per turn, only if inkable (â—). No auto ink.
  - Turn start draw: automatic 1 (except first player turn1)
  - Challenge: only can target RESTED defender
  - Song: can be paid by ink OR sung by a character (cost >= song cost). Singing rests singer. Song goes to discard.
  - Extra draw: ONLY by effects (credit system)
=========================== */

const ENCHANTED_RATE = 1 / (288 * 5); // 1 carton approx
let stones = 0;
let collection = {};
let enchantedCollection = {};
let savedDecks = [[],[],[]];
let currentDeckIndex = 0;

function qs(id){return document.getElementById(id);}
function showScreen(name){
  const ids=["menuScreen","cpuScreen","battleScreen","shopScreen","packScreen","deckScreen","collectionScreen"];
  ids.forEach(x=>qs(x)?.classList.remove("active"));
  const map={menu:"menuScreen",cpu:"cpuScreen",battle:"battleScreen",shop:"shopScreen",pack:"packScreen",deck:"deckScreen",collection:"collectionScreen"};
  qs(map[name])?.classList.add("active");
}
function openModal(title, body, buttons){
  qs("modalTitle").textContent = title || "";
  qs("modalBody").textContent = body || "";
  const btns = qs("modalBtns");
  btns.innerHTML = "";
  (buttons||[{label:"OK",onClick:closeModal}]).forEach(b=>{
    const el=document.createElement("button");
    el.className="btn small";
    el.textContent=b.label;
    el.onclick=b.onClick;
    btns.appendChild(el);
  });
  qs("overlay").style.display="block";
}
function closeModal(){ qs("overlay").style.display="none"; }

function loadData(){
  stones = parseInt(localStorage.getItem("ds_stones")||"0",10);
  collection = JSON.parse(localStorage.getItem("ds_collection")||"{}");
  enchantedCollection = JSON.parse(localStorage.getItem("ds_collection_enchanted")||"{}");
  const d = localStorage.getItem("ds_playerDecks");
  if(d){ try{ const p=JSON.parse(d); if(Array.isArray(p)&&p.length===3) savedDecks=p; }catch(e){} }
  updateStoneDisplays();
  updatePlayerDeckButtons();
}
function saveAll(){
  localStorage.setItem("ds_stones", String(stones));
  localStorage.setItem("ds_collection", JSON.stringify(collection));
  localStorage.setItem("ds_collection_enchanted", JSON.stringify(enchantedCollection));
  localStorage.setItem("ds_playerDecks", JSON.stringify(savedDecks));
  updateStoneDisplays();
}
function updateStoneDisplays(){
  qs("stoneCount").textContent = stones;
  qs("shopStoneCount").textContent = stones;
  qs("packStoneCount").textContent = stones;
}
function addStones(n){ stones+=n; saveAll(); }

/* ===== Cards ===== */
const cards = [
  // basic 0-5
  {id:0, name:"ã‚«ãƒ¼",   color:"red",    type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:1, name:"ãƒ«ãƒ‘ãƒ—", color:"purple", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:2, name:"ãƒ«ãƒ–ãƒ–", color:"blue",   type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:3, name:"ãƒ­ã‚¤ã‚¨", color:"yellow", type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:4, name:"ãƒ­ãƒ¼ã‚·", color:"white",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},
  {id:5, name:"ãƒ‰ãƒªãƒŸ", color:"green",  type:"character", cost:1, atk:1, hp:3, lore:1, rarity:"N",  inkable:true},

  // songs / chars
  {id:6,  name:"çµ‚ç„‰ã®å¤§ç«",          color:"red",    type:"song",      cost:7, rarity:"SR", inkable:false, effect:"boardwipe"},
  {id:7,  name:"æ°·çµã®å¥³ç‹ã‚±ãƒ«ã‚µ",    color:"purple", type:"character", cost:8, atk:4, hp:6, lore:3, rarity:"L",  inkable:false, effect:"freeze2", evolveCost:6, evolveFrom:0},
  {id:8,  name:"ä¼èª¬ã®å‹‡è€…ã‚¤ãƒ•ãƒªãƒ¼ãƒˆ", color:"red",   type:"character", cost:8, atk:5, hp:5, lore:4, rarity:"L",  inkable:true,  evade:true},

  {id:9,  name:"ã‚¿ã‚¤ã‚¿ãƒ³",        color:"red",    type:"character", cost:5, atk:6, hp:5, lore:0, rarity:"SR", inkable:true, mustAttack:true, rush:true},
  {id:10, name:"ãƒã‚¸ãƒ§ãƒ‰ãƒ©",      color:"red",    type:"character", cost:9, atk:7, hp:5, lore:2, rarity:"L",  inkable:true, effect:"destroyOnSummon"},
  {id:11, name:"ãã‚ãã‚ãƒ€ãƒƒã‚¯",  color:"red",    type:"character", cost:2, atk:2, hp:3, lore:1, rarity:"N",  inkable:true},

  {id:12, name:"ã‚´ãƒ¼ã‚º",       color:"blue",   type:"character", cost:7, atk:3, hp:6, lore:2, rarity:"L",  inkable:false, effect:"toInkOnSummon"},
  {id:13, name:"ãƒªãƒ³",         color:"blue",   type:"character", cost:4, atk:2, hp:4, lore:1, rarity:"L",  inkable:true, effect:"extraInkPerTurn"},
  {id:14, name:"ã‚‰ãŸã°ã‚",     color:"blue",   type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N",  inkable:true, effect:"deathToInk"},
  {id:15, name:"ã‚ã‚Šã®ã¾ã¾ã§", color:"blue",   type:"song",      cost:5, rarity:"SR", inkable:true, effect:"songToInk1"},

  {id:16, name:"ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«",   color:"yellow", type:"character", cost:4, atk:1, hp:5, lore:2, rarity:"L",  inkable:true,  effect:"pretzelHealDraw"},
  {id:17, name:"ãƒŸã‚¹ã‚¿ãƒ¼ãƒã‚¸",   color:"yellow", type:"character", cost:3, atk:2, hp:5, lore:1, rarity:"N",  inkable:true},
  {id:18, name:"ãƒ•ãƒ³ãƒãƒ¼",       color:"yellow", type:"character", cost:4, atk:3, hp:5, lore:1, rarity:"N",  inkable:true},
  {id:19, name:"ã‚¢ãƒªã‚¨ãƒŠã‚¤",     color:"yellow", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"SR", inkable:true,  effect:"arienaiSearchSong", songPower:5},

  {id:20, name:"ã‚¸ãƒ¼ãƒ¦ãƒ¼",     color:"green",  type:"character", cost:6, atk:3, hp:4, lore:2, rarity:"SR", inkable:false, effect:"bounceOnSummon"},
  {id:21, name:"ã‚¨ãƒ³ãƒãƒ³ã‚¹",   color:"green",  type:"character", cost:4, atk:3, hp:3, lore:3, rarity:"N",  inkable:true},
  {id:22, name:"èƒŒç­‹ãŒãƒ’ãƒ¤ãƒª", color:"green",  type:"song",      cost:2, rarity:"N",  inkable:true, effect:"discard1"},

  {id:23, name:"ã»ã†ã",               color:"purple", type:"character", cost:2, atk:2, hp:2, lore:1, rarity:"N", inkable:true},
  {id:24, name:"ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³",           color:"purple", type:"character", cost:1, atk:1, hp:1, lore:1, rarity:"N", inkable:true, effect:"evadeIfAlly"},
  {id:25, name:"ãƒ†ã‚£ãƒ©ãƒŸã‚¹ã®ãŸãã‚‰ã¿", color:"purple", type:"song",      cost:3, rarity:"R", inkable:true, effect:"draw3"},
  {id:26, name:"ãƒã‚¸ãƒ§",               color:"purple", type:"character", cost:3, atk:2, hp:2, lore:1, rarity:"N", inkable:true, effect:"drawOnSummon1"},
  {id:27, name:"ã‚±ãƒ«ã‚µ",               color:"purple", type:"character", cost:3, atk:2, hp:3, lore:1, rarity:"N", inkable:true},

  {id:28, name:"AHNW",        color:"white", type:"song",      cost:5, rarity:"SR", inkable:false, effect:"handReset7"},
  {id:29, name:"ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼", color:"white", type:"action",   cost:3, rarity:"R",  inkable:true,  effect:"damage3"}, // action (not singable)
  {id:30, name:"å‰£ã§åˆºã›",    color:"white", type:"song",      cost:5, rarity:"R",  inkable:false, effect:"aoe2"},
  {id:31, name:"ã‚¨ãƒ©ãƒƒã‚¿ç‹å­", color:"white", type:"character", cost:2, atk:1, hp:3, lore:1, rarity:"N", inkable:true, effect:"frenzy2"}
];

function baseById(id){ return cards.find(c=>c.id===id); }
function isBasicId(id){ return id>=0 && id<=5; }
function makeInst(base, isEnchanted=false){
  return {
    id:base.id,name:base.name,color:base.color,type:base.type,cost:base.cost,
    atk:base.atk||0,hp:base.hp||0,maxHp:base.hp||0,lore:base.lore||0,
    rarity:base.rarity,inkable:(base.inkable??true),effect:base.effect||null,
    evolveCost:base.evolveCost||null,evolveFrom:base.evolveFrom??null,
    evade:!!base.evade,mustAttack:!!base.mustAttack,rush:!!base.rush,
    songPower:base.songPower||base.cost||0,isEnchanted:!!isEnchanted,
    rest:false,frozen:false,summonTurn:0
  };
}
function renderCard(card){
  const cls=["card",card.color];
  if(card.rest) cls.push("rest");
  if(card.frozen) cls.push("frozen");
  if(card.isEnchanted) cls.push("enchanted");
  const inkSym = card.inkable ? "â—" : "Ã—";
  const badge = card.isEnchanted ? "E" : card.rarity;
  const line1 = card.type==="character" ? `ATK:${card.atk} HP:${card.hp}/${card.maxHp}` : (card.type==="song"?"ã‚½ãƒ³ã‚°":"ã‚¢ã‚¯ã‚·ãƒ§ãƒ³");
  const line2 = card.type==="character" ? `ãƒ­ã‚¢:${card.lore}` : "";
  return `
    <div class="${cls.join(" ")}">
      <div class="card-header">
        <div>${card.cost}</div>
        <div class="card-name">${card.name}</div>
        <div>${inkSym}</div>
      </div>
      <div class="card-ill"></div>
      <div class="card-row"><span>${line1}</span><span>${line2}</span></div>
      <div class="card-footer">è‰²:${card.color} / ${badge}</div>
    </div>
  `;
}

/* ===== Pack & Collection ===== */
function showPack(){ updateStoneDisplays(); qs("packResult").innerHTML=""; showScreen("pack"); }
function showShop(){ updateStoneDisplays(); showScreen("shop"); }

function openPack(){
  const COST=5;
  if(stones<COST){ openModal("è¶³ã‚Šãªã„","ãƒ‰ãƒªãƒ¼ãƒ ã‚¹ãƒˆãƒ¼ãƒ³ãŒ5å€‹å¿…è¦ã§ã™ã€‚"); return; }
  stones-=COST;

  const pulled=[];
  for(let i=0;i<5;i++){
    let isE=false, base=null;
    if(Math.random()<ENCHANTED_RATE){
      const cand=cards.filter(c=>c.rarity==="L" && c.type==="character");
      if(cand.length){ base=cand[Math.floor(Math.random()*cand.length)]; isE=true; }
    }
    if(!base){
      const r=Math.random();
      let rarity = r<0.78?"N":r<0.90?"R":r<0.98?"SR":"L";
      let cand=cards.filter(c=>c.rarity===rarity);
      if(!cand.length) cand=cards.slice();
      base=cand[Math.floor(Math.random()*cand.length)];
    }
    pulled.push({base,isE});
    collection[base.id]=(collection[base.id]||0)+1;
    if(isE) enchantedCollection[base.id]=(enchantedCollection[base.id]||0)+1;
  }

  saveAll();
  const area=qs("packResult"); area.innerHTML="";
  pulled.forEach(p=>{
    const inst=makeInst(p.base,p.isE);
    const wrap=document.createElement("div");
    wrap.style.display="inline-block"; wrap.style.margin="4px";
    wrap.innerHTML=renderCard(inst);
    wrap.firstElementChild.onclick=()=>showDetail(inst);
    area.appendChild(wrap);
  });
}

function openCollection(){
  const list=qs("collectionList"); list.innerHTML="";
  cards.forEach(c=>{
    const n=collection[c.id]||0, e=enchantedCollection[c.id]||0;
    const row=document.createElement("div");
    row.style.display="flex"; row.style.gap="10px"; row.style.alignItems="center"; row.style.margin="8px 0";
    const cardDiv=document.createElement("div"); cardDiv.innerHTML=renderCard(makeInst(c,false));
    cardDiv.firstElementChild.onclick=()=>showDetail(makeInst(c,false));
    const info=document.createElement("div");
    info.innerHTML = `<div style="font-weight:bold">${c.name}</div>
      <div style="font-size:12px;opacity:.9">è‰²:${c.color} / ç¨®é¡:${c.type} / ã‚³ã‚¹ãƒˆ:${c.cost} / ãƒ¬ã‚¢:${c.rarity}</div>
      <div style="font-size:12px;opacity:.9">æ‰€æŒï¼šé€šå¸¸Ã—${n} ${e?`/ EÃ—${e}`:""}</div>`;
    row.appendChild(cardDiv.firstElementChild);
    row.appendChild(info);
    list.appendChild(row);
  });
  showScreen("collection");
}

function effectText(card){
  switch(card.effect){
    case "boardwipe": return "ã‚½ãƒ³ã‚°(7)ï¼šå ´ã®å…¨ã‚­ãƒ£ãƒ©ã‚’ç ´å£Šã€‚ä½¿ç”¨å¾Œã“ã®ã‚«ãƒ¼ãƒ‰ã¯å¢“åœ°ã¸ã€‚æ­Œãˆã°ã‚³ã‚¹ãƒˆä¸è¦ã€‚";
    case "freeze2": return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©ã‚’æœ€å¤§2ä½“å‡çµï¼ˆè¡Œå‹•ä¸å¯ï¼‰ã€‚";
    case "destroyOnSummon": return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’ç ´å£Šã€‚";
    case "toInkOnSummon": return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚¤ãƒ³ã‚¯ã¸é€ã‚‹ã€‚";
    case "extraInkPerTurn": return "å ´ã«ã„ã‚‹é–“ã€è‡ªåˆ†ã¯è¿½åŠ ã§ã‚¤ãƒ³ã‚¯ã‚’1æšç½®ã‘ã‚‹ï¼ˆ+1å›ï¼‰ã€‚";
    case "deathToInk": return "ç ´å£Šã•ã‚ŒãŸã¨ãå¢“åœ°ã§ã¯ãªãã‚¤ãƒ³ã‚¯ã¸ã€‚";
    case "songToInk1": return "ã‚½ãƒ³ã‚°(5)ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚¤ãƒ³ã‚¯ã¸é€ã‚‹ã€‚";
    case "pretzelHealDraw": return "å¬å–šæ™‚ï¼šå‘³æ–¹ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’åˆè¨ˆ3ã¾ã§å›å¾©â†’å›å¾©ã—ãŸæ•°ã ã‘è¿½åŠ ãƒ‰ãƒ­ãƒ¼ã€‚";
    case "arienaiSearchSong": return "å¬å–šæ™‚ï¼šå±±æœ­ä¸Š4æšã‚’è¦‹ã¦ã‚½ãƒ³ã‚°ã‚’1æšã¾ã§æ‰‹æœ­ã¸ã€‚æ­Œå£°5ã€‚";
    case "bounceOnSummon": return "å¬å–šæ™‚ï¼šç›¸æ‰‹ã®ã‚­ãƒ£ãƒ©1ä½“ã‚’æ‰‹æœ­ã«æˆ»ã—ã¦ã‚ˆã„ã€‚";
    case "discard1": return "ã‚½ãƒ³ã‚°(2)ï¼šç›¸æ‰‹ã¯æ‰‹æœ­ã‚’1æšæ¨ã¦ã‚‹ã€‚";
    case "evadeIfAlly": return "å‘³æ–¹ãŒä»–ã«ã„ã‚‹é–“ã€ã“ã®ã‚­ãƒ£ãƒ©ã¯å›é¿ã‚’å¾—ã‚‹ã€‚";
    case "draw3": return "ã‚½ãƒ³ã‚°(3)ï¼š3æšãƒ‰ãƒ­ãƒ¼ï¼ˆåŠ¹æœã§è¿½åŠ ãƒ‰ãƒ­ãƒ¼æ‰±ã„ï¼‰ã€‚";
    case "drawOnSummon1": return "å¬å–šæ™‚ï¼š1æšãƒ‰ãƒ­ãƒ¼ï¼ˆåŠ¹æœã§è¿½åŠ ãƒ‰ãƒ­ãƒ¼æ‰±ã„ï¼‰ã€‚";
    case "handReset7": return "ã‚½ãƒ³ã‚°(5)ï¼šãŠäº’ã„æ‰‹æœ­ã‚’æ¨ã¦ã¦7æšãƒ‰ãƒ­ãƒ¼ï¼ˆåŠ¹æœãƒ‰ãƒ­ãƒ¼ï¼‰ã€‚";
    case "damage3": return "ã‚¢ã‚¯ã‚·ãƒ§ãƒ³(3)ï¼šç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚â€»æ­Œãˆãªã„";
    case "aoe2": return "ã‚½ãƒ³ã‚°(5)ï¼šç›¸æ‰‹ã®å„ã‚­ãƒ£ãƒ©ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚";
    case "frenzy2": return "ç°çŒ›2ï¼šã“ã®ã‚­ãƒ£ãƒ©ãŒãƒãƒ£ãƒ¬ãƒ³ã‚¸ä¸­ã€ATK+2ã€‚";
    default: return "ç‰¹ã«ãªã—ã€‚";
  }
}
function showDetail(card){
  const txt = `è‰²:${card.color} / ç¨®é¡:${card.type} / ã‚³ã‚¹ãƒˆ:${card.cost} / ãƒ¬ã‚¢:${card.isEnchanted?"E":card.rarity}\n` +
    (card.type==="character" ? `ATK:${card.atk} HP:${card.hp}/${card.maxHp} ãƒ­ã‚¢:${card.lore}\n` : "") +
    `\n${effectText(card)}`;
  openModal(card.name, txt, [{label:"é–‰ã˜ã‚‹",onClick:closeModal}]);
}

/* ===== Deck Builder ===== */
let deckN={}, deckE={};

function openDeckBuilder(index){
  if(typeof index==="number") currentDeckIndex=index;
  rebuildDeckEditor();
  showScreen("deck");
}
function switchDeck(i){ currentDeckIndex=i; rebuildDeckEditor(); }
function hasCustomDeck(i){ return Array.isArray(savedDecks[i]) && savedDecks[i].length>0; }

function rebuildDeckEditor(){
  deckN={}; deckE={};
  const cur=savedDecks[currentDeckIndex]||[];
  cur.forEach(ent=>{
    const id= typeof ent==="number" ? ent : ent.id;
    const isE= typeof ent==="object" && !!ent.isEnchanted;
    if(isE) deckE[id]=(deckE[id]||0)+1; else deckN[id]=(deckN[id]||0)+1;
  });

  qs("currentDeckLabel").textContent = String(currentDeckIndex+1);
  const total = Object.values(deckN).reduce((a,b)=>a+b,0) + Object.values(deckE).reduce((a,b)=>a+b,0);
  qs("deckTotal").textContent = String(total);

  const colors = new Set();
  Object.keys(deckN).forEach(k=>{ if(deckN[k]>0) colors.add(baseById(parseInt(k,10))?.color); });
  Object.keys(deckE).forEach(k=>{ if(deckE[k]>0) colors.add(baseById(parseInt(k,10))?.color); });
  qs("deckColors").textContent = colors.size? Array.from(colors).join(" / "): "-";

  const area=qs("deckCardList"); area.innerHTML="";
  cards.forEach(c=>{
    const haveN=collection[c.id]||0, haveE=enchantedCollection[c.id]||0;
    const inN=deckN[c.id]||0, inE=deckE[c.id]||0;
    const sameTotal=inN+inE;
    const row=document.createElement("div");
    row.className="card-box";
    row.innerHTML = `
      <div style="display:flex;align-items:center;gap:10px;">
        <div>${renderCard(makeInst(c,false))}</div>
        <div style="flex:1;">
          <div style="font-weight:bold">${c.name}</div>
          <div class="line">è‰²:${c.color} / ç¨®é¡:${c.type} / ã‚³ã‚¹ãƒˆ:${c.cost} / ãƒ¬ã‚¢:${c.rarity} / ã‚¤ãƒ³ã‚¯:${c.inkable?"â—":"Ã—"}</div>
          <div class="line">æ‰€æŒï¼šé€šå¸¸Ã—${haveN} / EÃ—${haveE}</div>
          <div class="line">ãƒ‡ãƒƒã‚­ï¼šé€šå¸¸Ã—${inN} / EÃ—${inE} <b>(åˆè¨ˆ${sameTotal}/4)</b></div>
          <div style="margin-top:6px;">
            <button class="btn small" data-act="minusN">ï¼é€šå¸¸</button>
            <button class="btn small" data-act="plusN">ï¼‹é€šå¸¸</button>
            <button class="btn small" data-act="minusE">ï¼E</button>
            <button class="btn small" data-act="plusE">ï¼‹E</button>
            <button class="btn small" data-act="detail">è©³ç´°</button>
          </div>
        </div>
      </div>
    `;
    const btn=(act)=>row.querySelector(`[data-act="${act}"]`);
    btn("detail").onclick=()=>showDetail(makeInst(c,false));
    btn("minusN").onclick=()=>changeDeckCount(c.id,-1,false);
    btn("plusN").onclick=()=>changeDeckCount(c.id,+1,false);
    btn("minusE").onclick=()=>changeDeckCount(c.id,-1,true);
    btn("plusE").onclick=()=>changeDeckCount(c.id,+1,true);
    area.appendChild(row);
  });

  // refresh meta after building
  const total2 = Object.values(deckN).reduce((a,b)=>a+b,0) + Object.values(deckE).reduce((a,b)=>a+b,0);
  qs("deckTotal").textContent = String(total2);
}
function getDeckColors(){
  const s=new Set();
  Object.keys(deckN).forEach(k=>{ if(deckN[k]>0) s.add(baseById(parseInt(k,10))?.color); });
  Object.keys(deckE).forEach(k=>{ if(deckE[k]>0) s.add(baseById(parseInt(k,10))?.color); });
  return s;
}
function changeDeckCount(id, diff, isE){
  const counts=isE?deckE:deckN;
  const before=counts[id]||0;
  let next=before+diff;
  if(next<0) next=0;

  const have=isE?(enchantedCollection[id]||0):(collection[id]||0);
  if(next>have){
    openModal("è¿½åŠ ã§ããªã„", `æ‰€æŒæ•°ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚\næ‰€æŒï¼š${have} / è¿½åŠ å¾Œï¼š${next}`, [{label:"OK",onClick:closeModal}]);
    return;
  }

  // apply tentative
  counts[id]=next;

  // 2 colors max
  const colors=getDeckColors();
  if(colors.size>2){
    counts[id]=before;
    openModal("è¿½åŠ ã§ããªã„","ãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ã§ã™ã€‚", [{label:"OK",onClick:closeModal}]);
    return;
  }

  // same name 4 max (normal+E)
  const totalSame=(deckN[id]||0)+(deckE[id]||0);
  if(!isBasicId(id) && totalSame>4){
    counts[id]=before;
    openModal("è¿½åŠ ã§ããªã„","åŒåã‚«ãƒ¼ãƒ‰ã¯4æšã¾ã§ã§ã™ï¼ˆé€šå¸¸ï¼‹Eåˆç®—ï¼‰ã€‚", [{label:"OK",onClick:closeModal}]);
    return;
  }

  rebuildDeckEditor();
}
function saveDeck(){
  const arr=[];
  Object.keys(deckN).forEach(k=>{
    for(let i=0;i<(deckN[k]||0);i++) arr.push({id:parseInt(k,10),isEnchanted:false});
  });
  Object.keys(deckE).forEach(k=>{
    for(let i=0;i<(deckE[k]||0);i++) arr.push({id:parseInt(k,10),isEnchanted:true});
  });
  if(arr.length<60){
    openModal("ä¿å­˜ã§ããªã„", `ãƒ‡ãƒƒã‚­ã¯60æšä»¥ä¸Šã«ã—ã¦ã­ã€‚ï¼ˆç¾åœ¨${arr.length}æšï¼‰`);
    return;
  }
  savedDecks[currentDeckIndex]=arr;
  saveAll();
  openModal("ä¿å­˜å®Œäº†", `ãƒ‡ãƒƒã‚­${currentDeckIndex+1}ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ï¼ˆ${arr.length}æšï¼‰`);
  updatePlayerDeckButtons();
}

/* ===== CPU config ===== */
let cpuStrength="normal";
let cpuColors=[];
let playerDeckMode="default";
function openCpuConfig(){ updateCpuButtons(); updatePlayerDeckButtons(); showScreen("cpu"); }
function setCpuStrength(s){ cpuStrength=s; updateCpuButtons(); }
function setCpuColor(c){
  const i=cpuColors.indexOf(c);
  if(i>=0) cpuColors.splice(i,1);
  else{
    if(cpuColors.length>=2){ openModal("æ³¨æ„","CPUãƒ‡ãƒƒã‚­ã¯2è‰²ã¾ã§ã€‚"); return; }
    cpuColors.push(c);
  }
  updateCpuButtons();
}
function updateCpuButtons(){
  qs("btnCpuNormal").classList.toggle("toggle-selected", cpuStrength==="normal");
  qs("btnCpuStrong").classList.toggle("toggle-selected", cpuStrength==="strong");
  qs("btnCpuGod").classList.toggle("toggle-selected", cpuStrength==="god");
  ["red","purple","blue","yellow","white","green"].forEach(c=>{
    const id="cpu"+c.charAt(0).toUpperCase()+c.slice(1);
    qs(id)?.classList.toggle("toggle-selected", cpuColors.includes(c));
  });
}
function updatePlayerDeckButtons(){
  qs("btnPlayerDefault")?.classList.toggle("toggle-selected", playerDeckMode==="default");
  const btns=[qs("btnDeck1"),qs("btnDeck2"),qs("btnDeck3")];
  ["deck1","deck2","deck3"].forEach((m,idx)=>{
    btns[idx]?.classList.toggle("toggle-selected", playerDeckMode===m);
    if(!hasCustomDeck(idx)){ btns[idx].disabled=true; btns[idx].textContent=`ãƒ‡ãƒƒã‚­${idx+1}ï¼ˆæœªä¿å­˜ï¼‰`; }
    else{ btns[idx].disabled=false; btns[idx].textContent=`ãƒ‡ãƒƒã‚­${idx+1}`; }
  });
}
function selectPlayerDeck(mode){
  if(mode.startsWith("deck")){
    const idx=parseInt(mode.slice(4),10)-1;
    if(!hasCustomDeck(idx)){ openModal("æœªä¿å­˜", `ãƒ‡ãƒƒã‚­${idx+1}ã‚’å…ˆã«ä¿å­˜ã—ã¦ã­ã€‚`); return; }
  }
  playerDeckMode=mode;
  updatePlayerDeckButtons();
}

/* ========= Battle core ========= */
let battle=null;

function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} }
function buildDeckFromSaved(saved){
  const out=[];
  (saved||[]).forEach(ent=>{
    const id= typeof ent==="number"?ent:ent.id;
    const isE= typeof ent==="object" && !!ent.isEnchanted;
    const base=baseById(id);
    if(base) out.push(makeInst(base,isE));
  });
  shuffle(out); return out;
}
function makeDefaultDeck(){
  const ids=[];
  for(let i=0;i<16;i++) ids.push(0);
  for(let i=0;i<8;i++) ids.push(11);
  for(let i=0;i<4;i++) ids.push(9);
  for(let i=0;i<4;i++) ids.push(6);
  for(let i=0;i<4;i++) ids.push(8);
  for(let i=0;i<4;i++) ids.push(21);
  for(let i=0;i<4;i++) ids.push(22);
  while(ids.length<60) ids.push(0);
  return ids.map(id=>({id,isEnchanted:false}));
}
function buildCpuDeck(colors){
  if(!colors||!colors.length) colors=["red","purple"];
  if(colors.length===1) colors=[colors[0],colors[0]];
  const pool=cards.filter(c=>colors.includes(c.color));
  const raw=[];
  while(raw.length<60){
    const b=pool[Math.floor(Math.random()*pool.length)];
    raw.push({id:b.id,isEnchanted:false});
  }
  return buildDeckFromSaved(raw);
}
function log(t){
  const el=qs("log"); if(!el) return;
  const d=document.createElement("div"); d.textContent=t; el.appendChild(d); el.scrollTop=el.scrollHeight;
}
function sideName(side){ return side==="player"?"è‡ªåˆ†":"ç›¸æ‰‹"; }
function enemySide(side){ return side==="player"?"cpu":"player"; }

function canAct(card){
  if(!card) return false;
  if(card.rest) return false;
  if(card.frozen) return false;
  return true;
}
function canChallenge(attacker){
  if(!canAct(attacker)) return false;
  if(!attacker.rush && attacker.summonTurn===battle.turn.turnCount) return false;
  return true;
}

/* ===== Turn & Draw control =====
  start-of-turn draw is automatic:
   - first player turn1: 0 draw
   - otherwise: 1 draw
  extra draws only by effects => battle.turn.extraDrawCredit
*/
function drawOne(side){
  const s=battle[side];
  if(s.deck.length===0){ log(`${sideName(side)}ã®å±±æœ­ãŒ0ï¼`); return null; }
  const c=s.deck.shift(); s.hand.push(c); return c;
}
function grantExtraDraw(side, n){
  battle.turn.extraDrawCredit[side] += n;
}
function effectDraw(side, n, reason){
  grantExtraDraw(side,n);
  for(let i=0;i<n;i++){
    const c=drawOne(side);
    if(c) log(`${sideName(side)}ã¯åŠ¹æœã§1æšãƒ‰ãƒ­ãƒ¼ï¼ˆ${reason||"åŠ¹æœ"}ï¼‰`);
  }
}

/* ===== Ink rules =====
 - place ink from hand: once per turn + bonus from "ãƒªãƒ³" if on field (extraInkPerTurn)
 - card must be inkable (â—) unless effect uses moveToInk(...,true)
 - placed ink is immediately available (no sickness), so inkMax++, inkCurrent++
*/
function calcInkPlacementLimit(side){
  const s=battle[side];
  let bonus=0;
  s.field.forEach(c=>{ if(c.effect==="extraInkPerTurn") bonus+=1; });
  return 1 + bonus;
}
</script>
<!-- Part2 continues below -->
<script>
function tryPlaceInkFromHand(side, handIndex){
  const s=battle[side];
  const card=s.hand[handIndex];
  if(!card) return;

  const limit = calcInkPlacementLimit(side);
  if(battle.turn.inkPlaced[side] >= limit){
    openModal("ã‚¤ãƒ³ã‚¯åŒ–ã§ããªã„", `ã“ã®ã‚¿ãƒ¼ãƒ³ã®ã‚¤ãƒ³ã‚¯åŒ–ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ï¼ˆ${limit}å›ï¼‰ã€‚`);
    return;
  }
  if(!card.inkable){
    openModal("ã‚¤ãƒ³ã‚¯åŒ–ã§ããªã„","ã“ã®ã‚«ãƒ¼ãƒ‰ã¯ã‚¤ãƒ³ã‚¯åŒ–ä¸å¯ï¼ˆÃ—ï¼‰ã§ã™ã€‚");
    return;
  }
  // place
  s.hand.splice(handIndex,1);
  s.ink.push(card);
  s.inkMax += 1;
  s.inkCurrent += 1;
  battle.turn.inkPlaced[side] += 1;
  log(`${sideName(side)}ã¯æ‰‹æœ­ã®ã€Œ${card.name}ã€ã‚’ã‚¤ãƒ³ã‚¯ã«ç½®ã„ãŸï¼ˆ+1ï¼‰ã€‚`);
  updateUI();
}

function moveToInkByEffect(targetSide, card, reason){
  // effect can ink even if inkable=false
  const s=battle[targetSide];
  s.ink.push(card);
  s.inkMax += 1;
  s.inkCurrent += 1;
  log(`${sideName(targetSide)}ã®ã‚¤ãƒ³ã‚¯ã«ã€Œ${card.name}ã€ãŒç½®ã‹ã‚ŒãŸï¼ˆåŠ¹æœï¼š${reason||""}ï¼‰ã€‚`);
}

function startBattle(){
  if(!cpuColors.length) cpuColors=["red","purple"];
  let playerDef;
  if(playerDeckMode==="default") playerDef=makeDefaultDeck();
  else if(playerDeckMode==="deck1") playerDef=savedDecks[0]||[];
  else if(playerDeckMode==="deck2") playerDef=savedDecks[1]||[];
  else if(playerDeckMode==="deck3") playerDef=savedDecks[2]||[];
  else playerDef=[];

  const pDeck = buildDeckFromSaved(playerDef);
  if(pDeck.length<60){ openModal("ãƒ‡ãƒƒã‚­ä¸è¶³","ãƒ‡ãƒƒã‚­ãŒ60æšæœªæº€ã§ã™ã€‚ãƒ‡ãƒƒã‚­ç·¨é›†ã§ä¿å­˜ã—ã¦ã­ã€‚"); return; }

  battle = {
    firstPlayer: "player",
    turn: {
      turnCount: 1,
      current: "player",
      autoDrawDone: {player:false,cpu:false},
      inkPlaced: {player:0,cpu:0},
      extraDrawCredit: {player:0,cpu:0}
    },
    player: {deck:pDeck, hand:[], field:[], discard:[], ink:[], inkCurrent:0, inkMax:0, lore:0},
    cpu:    {deck:buildCpuDeck(cpuColors), hand:[], field:[], discard:[], ink:[], inkCurrent:0, inkMax:0, lore:0}
  };

  qs("log").innerHTML="";
  // initial hand 7
  for(let i=0;i<7;i++){ drawOne("player"); drawOne("cpu"); }

  showScreen("battle");
  log("ãƒãƒˆãƒ«é–‹å§‹ï¼");
  beginTurn("player", true);
}

function beginTurn(side, isFirstTurn){
  battle.turn.current = side;

  // refresh ink (all available)
  const s=battle[side];
  s.inkCurrent = s.inkMax;

  // ready & thaw
  s.field.forEach(c=>{ c.rest=false; c.frozen=false; });

  // reset per-turn trackers
  battle.turn.inkPlaced[side]=0;
  battle.turn.extraDrawCredit[side]=0;
  battle.turn.autoDrawDone[side]=false;

  log(`=== ${sideName(side)}ã®ã‚¿ãƒ¼ãƒ³ ${battle.turn.turnCount} ===`);

  // auto draw (except first player turn1)
  const isFirstPlayerTurn1 = (side===battle.firstPlayer && battle.turn.turnCount===1);
  if(!isFirstPlayerTurn1){
    drawOne(side);
    battle.turn.autoDrawDone[side]=true;
    log(`${sideName(side)}ã¯ã‚¿ãƒ¼ãƒ³é–‹å§‹æ™‚ã«1æšãƒ‰ãƒ­ãƒ¼ã€‚`);
  } else {
    log(`å…ˆè¡Œ1ã‚¿ãƒ¼ãƒ³ç›®ã®ãŸã‚ã€ã‚¿ãƒ¼ãƒ³é–‹å§‹ãƒ‰ãƒ­ãƒ¼ãªã—ã€‚`);
  }

  updateUI();

  if(side==="cpu"){
    setTimeout(cpuTakeTurn, 150);
  }
}

function endTurn(){
  if(!battle) return;
  if(battle.turn.current!=="player") return;
  log("è‡ªåˆ†ã¯ã‚¿ãƒ¼ãƒ³çµ‚äº†ã€‚");
  updateUI();
  // cpu turn
  beginTurn("cpu", false);
}

function endBattleToMenu(){
  battle=null;
  showScreen("menu");
}

/* ===== Victory ===== */
function checkWin(){
  if(!battle) return false;
  if(battle.player.lore>=20){ openModal("å‹åˆ©ï¼","ãƒ­ã‚¢20åˆ°é”ï¼ã‚ãªãŸã®å‹ã¡ï¼",[{label:"OK",onClick:()=>{closeModal();endBattleToMenu();}}]); return true; }
  if(battle.cpu.lore>=20){ openModal("æ•—åŒ—â€¦","ç›¸æ‰‹ãŒãƒ­ã‚¢20åˆ°é”â€¦",[{label:"OK",onClick:()=>{closeModal();endBattleToMenu();}}]); return true; }
  return false;
}

/* ===== Combat rules =====
 - target must be RESTED
 - evade: only evade attackers can target evade defenders (ç°¡ç•¥ï¼šé˜²å¾¡å´ãŒå›é¿ãªã‚‰ã€æ”»æ’ƒå´ã‚‚å›é¿æŒã¡ã®ã¿)
 - frenzy2: attacker gets +2 atk during challenge
*/
function canTarget(attacker, defender){
  if(!defender.rest) return false; // MUST be rested
  if(defender.evade && !attacker.evade) return false;
  return true;
}

function dealDamageToChar(targetSide, idx, dmg, reason){
  const s=battle[targetSide];
  const c=s.field[idx];
  if(!c) return;
  c.hp -= dmg;
  log(`${sideName(targetSide)}ã®ã€Œ${c.name}ã€ã«${dmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆ${reason||"åŠ¹æœ"}ï¼‰`);
  if(c.hp<=0){
    destroyChar(targetSide, idx, "ãƒ€ãƒ¡ãƒ¼ã‚¸");
  }
}
function destroyChar(side, idx, reason){
  const s=battle[side];
  const c=s.field[idx];
  if(!c) return;

  s.field.splice(idx,1);

  // deathToInk
  if(c.effect==="deathToInk"){
    moveToInkByEffect(side, c, "ã‚‰ãŸã°ã‚");
  } else {
    s.discard.push(c);
    log(`${sideName(side)}ã®ã€Œ${c.name}ã€ã¯ç ´å£Šã•ã‚ŒãŸï¼ˆ${reason||""}ï¼‰â†’å¢“åœ°ã¸`);
  }
}

function resolveChallenge(attSide, attIdx, defIdx){
  const A = battle[attSide];
  const D = battle[enemySide(attSide)];
  const attacker=A.field[attIdx];
  const defender=D.field[defIdx];
  if(!attacker||!defender) return;

  if(!canChallenge(attacker)){ if(attSide==="player") openModal("ã§ããªã„","ã“ã®ã‚­ãƒ£ãƒ©ã¯ä»Šãƒãƒ£ãƒ¬ãƒ³ã‚¸ã§ãã¾ã›ã‚“ï¼ˆå¬å–šé…”ã„/ãƒ¬ã‚¹ãƒˆ/å‡çµï¼‰ã€‚"); return; }
  if(!canTarget(attacker, defender)){ if(attSide==="player") openModal("ã§ããªã„","ãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆã¯ã€Œãƒ¬ã‚¹ãƒˆã—ã¦ã„ã‚‹ã‚­ãƒ£ãƒ©ã€ã®ã¿ã§ã™ã€‚"); return; }

  let attAtk = attacker.atk;
  if(attacker.effect==="frenzy2") attAtk += 2;

  log(`${sideName(attSide)}ã®ã€Œ${attacker.name}ã€ãŒã€Œ${defender.name}ã€ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼`);

  defender.hp -= attAtk;
  attacker.hp -= defender.atk;
  attacker.rest = true;

  if(defender.hp<=0){
    // find current index again (it might shift if multiple calls, but here safe)
    const i = D.field.indexOf(defender);
    if(i>=0) destroyChar(enemySide(attSide), i, "æˆ¦é—˜");
  }
  if(attacker.hp<=0){
    const i = A.field.indexOf(attacker);
    if(i>=0) destroyChar(attSide, i, "æˆ¦é—˜");
  }
}

/* ===== Seek ===== */
function doSeek(side, fieldIdx){
  const s=battle[side];
  const c=s.field[fieldIdx];
  if(!c||!canAct(c)) return;
  c.rest=true;
  s.lore += c.lore;
  log(`${sideName(side)}ã®ã€Œ${c.name}ã€ãŒã‚·ãƒ¼ã‚¯ï¼ˆãƒ­ã‚¢+${c.lore}ï¼‰â†’è¨ˆ${s.lore}`);
  updateUI(); checkWin();
}

/* ===== Summon / Play ===== */
function summonFromHand(side, handIdx){
  const s=battle[side];
  const c=s.hand[handIdx];
  if(!c||c.type!=="character") return;
  if(s.inkCurrent < c.cost){ if(side==="player") openModal("è¶³ã‚Šãªã„","ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }
  s.inkCurrent -= c.cost;
  s.hand.splice(handIdx,1);
  c.summonTurn = battle.turn.turnCount;
  c.rest = false;
  c.frozen = false;
  s.field.push(c);
  log(`${sideName(side)}ã¯ã€Œ${c.name}ã€ã‚’å¬å–šã€‚`);
  onSummon(side, c);
  updateUI();
}

function playActionFromHand(side, handIdx){
  const s=battle[side];
  const c=s.hand[handIdx];
  if(!c||c.type!=="action") return;
  if(s.inkCurrent < c.cost){ if(side==="player") openModal("è¶³ã‚Šãªã„","ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }
  s.inkCurrent -= c.cost;
  s.hand.splice(handIdx,1);
  log(`${sideName(side)}ã¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€Œ${c.name}ã€ã‚’ä½¿ç”¨ã€‚`);
  applyEffectCard(side, c, null); // no singer
  s.discard.push(c);
  updateUI(); checkWin();
}

function playSongFromHand(side, handIdx, singerIdxOrNull){
  const s=battle[side];
  const c=s.hand[handIdx];
  if(!c||c.type!=="song") return;

  let paidByInk=true;
  let singer=null;
  if(typeof singerIdxOrNull==="number"){
    singer=s.field[singerIdxOrNull];
    if(!singer || !canAct(singer)){ if(side==="player") openModal("ã§ããªã„","ãã®ã‚­ãƒ£ãƒ©ã¯æ­Œãˆã¾ã›ã‚“ï¼ˆãƒ¬ã‚¹ãƒˆ/å‡çµï¼‰ã€‚"); return; }
    if(singer.cost < c.cost){ if(side==="player") openModal("ã§ããªã„","æ­Œãˆã‚‹ã®ã¯ã‚­ãƒ£ãƒ©ã®ã‚³ã‚¹ãƒˆãŒã‚½ãƒ³ã‚°ã‚³ã‚¹ãƒˆä»¥ä¸Šã®ã¨ãã€‚"); return; }
    // sing => no ink cost
    paidByInk=false;
  }

  if(paidByInk){
    if(s.inkCurrent < c.cost){ if(side==="player") openModal("è¶³ã‚Šãªã„","ã‚¤ãƒ³ã‚¯ãŒè¶³ã‚Šã¾ã›ã‚“ã€‚"); return; }
    s.inkCurrent -= c.cost;
  } else {
    singer.rest = true;
    log(`${sideName(side)}ã®ã€Œ${singer.name}ã€ãŒã€Œ${c.name}ã€ã‚’æ­Œã£ãŸï¼ˆã‚³ã‚¹ãƒˆè¸ã¿å€’ã—ï¼‰`);
  }

  s.hand.splice(handIdx,1);
  log(`${sideName(side)}ã¯ã‚½ãƒ³ã‚°ã€Œ${c.name}ã€ã‚’ä½¿ç”¨ã€‚`);
  applyEffectCard(side, c, singer);
  s.discard.push(c);
  updateUI(); checkWin();
}

/* ===== Effects ===== */
function findEnemyChars(side){ return battle[enemySide(side)].field; }
function onSummon(side, card){
  switch(card.effect){
    case "freeze2": return effectFreeze2(side);
    case "destroyOnSummon": return effectDestroyOne(side);
    case "toInkOnSummon": return effectEnemyCharToInk(side);
    case "bounceOnSummon": return effectBounceOne(side);
    case "drawOnSummon1": return effectDraw(side,1,"å¬å–šæ™‚");
    case "pretzelHealDraw": return effectPretzel(side);
    case "arienaiSearchSong": return effectArienai(side);
    default: return;
  }
}

function chooseEnemyCharIndexUI(side, title, msg){
  const enemy=battle[enemySide(side)];
  if(enemy.field.length===0) return Promise.resolve(null);

  return new Promise(resolve=>{
    const lines = enemy.field.map((c,i)=>`${i}: ${c.name} (HP:${c.hp}) ${c.rest?"[REST]":"[READY]"}`).join("\n");
    openModal(title, `${msg}\n\n${lines}`, [
      {label:"ã‚­ãƒ£ãƒ³ã‚»ãƒ«",onClick:()=>{closeModal();resolve(null);}},
      ...enemy.field.map((c,i)=>({label:`${i}`,onClick:()=>{closeModal();resolve(i);}}))
    ]);
  });
}

function effectFreeze2(side){
  const enemy=battle[enemySide(side)];
  if(enemy.field.length===0){ log("å‡çµå…ˆãªã—ã€‚"); return; }

  if(side==="cpu"){
    // freeze best attackers
    const idxs = enemy.field
      .map((c,i)=>({i,score:c.atk*10 + c.lore}))
      .sort((a,b)=>b.score-a.score)
      .slice(0,2).map(x=>x.i);
    idxs.forEach(i=>{ enemy.field[i].frozen=true; log(`ç›¸æ‰‹ã®ã€Œ${enemy.field[i].name}ã€ãŒå‡çµã—ãŸã€‚`); });
    return;
  }

  // player chooses up to 2
  const lines = enemy.field.map((c,i)=>`${i}: ${c.name} (ATK:${c.atk} HP:${c.hp})`).join("\n");
  openModal("å‡çµ(æœ€å¤§2)", `å‡çµã™ã‚‹ç›¸æ‰‹ã‚’æœ€å¤§2ä½“é¸ã‚“ã§ã­ã€‚\n\n${lines}`, [
    {label:"0",onClick:()=>{enemy.field[0]&&(enemy.field[0].frozen=true); log("å‡çµã—ãŸã€‚"); closeModal(); updateUI();}},
    {label:"1",onClick:()=>{enemy.field[1]&&(enemy.field[1].frozen=true); log("å‡çµã—ãŸã€‚"); closeModal(); updateUI();}},
    {label:"0&1",onClick:()=>{[0,1].forEach(i=>enemy.field[i]&&(enemy.field[i].frozen=true)); log("2ä½“å‡çµã—ãŸã€‚"); closeModal(); updateUI();}},
    {label:"é–‰ã˜ã‚‹",onClick:()=>{closeModal();}}
  ]);
}

function effectDestroyOne(side){
  const enemy=battle[enemySide(side)];
  if(enemy.field.length===0){ log("ç ´å£Šå…ˆãªã—ã€‚"); return; }
  if(side==="cpu"){
    // destroy best lore threat
    let best=-1,bScore=-1;
    enemy.field.forEach((c,i)=>{ const sc=c.lore*10 + c.atk*2 + (c.hp); if(sc>bScore){bScore=sc;best=i;} });
    destroyChar(enemySide(side), best, "å¬å–šæ™‚åŠ¹æœ");
    return;
  }
  chooseEnemyCharIndexUI(side, "ç ´å£Š", "ç ´å£Šã™ã‚‹ç›¸æ‰‹ã‚­ãƒ£ãƒ©ã‚’é¸ã‚“ã§ã­ã€‚").then(i=>{
    if(i==null) return;
    destroyChar(enemySide(side), i, "å¬å–šæ™‚åŠ¹æœ");
    updateUI();
  });
}

function effectEnemyCharToInk(side){
  const enemy=battle[enemySide(side)];
  if(enemy.field.length===0){ log("å¯¾è±¡ãªã—ã€‚"); return; }
  if(side==="cpu"){
    let best=0,score=-999;
    enemy.field.forEach((c,i)=>{ const sc=c.lore*10 + c.atk*3 + c.hp; if(sc>score){score=sc;best=i;} });
    const t=enemy.field.splice(best,1)[0];
    moveToInkByEffect(enemySide(side), t, "ã‚´ãƒ¼ã‚º/åŠ¹æœ");
    return;
  }
  chooseEnemyCharIndexUI(side, "ã‚¤ãƒ³ã‚¯é€ã‚Š", "ç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚¤ãƒ³ã‚¯ã¸é€ã‚‹ã€‚å¯¾è±¡ã‚’é¸ã‚“ã§ã­ã€‚").then(i=>{
    if(i==null) return;
    const t=battle[enemySide(side)].field.splice(i,1)[0];
    moveToInkByEffect(enemySide(side), t, "åŠ¹æœ");
    updateUI();
  });
}

function effectBounceOne(side){
  const enemy=battle[enemySide(side)];
  if(enemy.field.length===0){ log("å¯¾è±¡ãªã—ã€‚"); return; }
  if(side==="cpu"){
    // bounce biggest tempo
    let best=0,score=-999;
    enemy.field.forEach((c,i)=>{ const sc=c.cost*10 + c.lore*5 + c.atk*2; if(sc>score){score=sc;best=i;} });
    const t=enemy.field.splice(best,1)[0];
    battle[enemySide(side)].hand.push(t);
    log(`${sideName(enemySide(side))}ã®ã€Œ${t.name}ã€ãŒæ‰‹æœ­ã«æˆ»ã£ãŸã€‚`);
    return;
  }
  chooseEnemyCharIndexUI(side, "ãƒã‚¦ãƒ³ã‚¹", "ç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã‚’æ‰‹æœ­ã«æˆ»ã™ã€‚å¯¾è±¡ã‚’é¸ã‚“ã§ã­ã€‚").then(i=>{
    if(i==null) return;
    const t=battle[enemySide(side)].field.splice(i,1)[0];
    battle[enemySide(side)].hand.push(t);
    log(`${sideName(enemySide(side))}ã®ã€Œ${t.name}ã€ãŒæ‰‹æœ­ã«æˆ»ã£ãŸã€‚`);
    updateUI();
  });
}

function effectPretzel(side){
  const me=battle[side];
  const damaged = me.field.map((c,i)=>({i,need:c.maxHp-c.hp})).filter(x=>x.need>0);
  if(damaged.length===0){ log("å›å¾©å¯¾è±¡ãªã—ã€‚"); return; }

  if(side==="cpu"){
    // heal up to 3 starting from highest lore
    let heal=3, healed=0;
    damaged.sort((a,b)=> (me.field[b.i].lore - me.field[a.i].lore));
    for(const d of damaged){
      if(heal<=0) break;
      const c=me.field[d.i];
      const amt=Math.min(d.need, heal);
      c.hp += amt;
      heal -= amt;
      healed += amt;
      log(`ç›¸æ‰‹ã¯ã€Œ${c.name}ã€ã‚’${amt}å›å¾©ã€‚`);
    }
    if(healed>0) effectDraw(side, healed, "ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«");
    return;
  }

  // player: simple modal choosing distribution is heavy => do quick auto: heal highest lore first
  openModal("ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«", "å›å¾©ã¯ç°¡ç•¥ï¼šãƒ­ã‚¢ãŒé«˜ã„é †ã«æœ€å¤§3å›å¾©ã—ã¾ã™ï¼ˆå›å¾©é‡=è¿½åŠ ãƒ‰ãƒ­ãƒ¼ï¼‰ã€‚", [
    {label:"OK",onClick:()=>{
      closeModal();
      let heal=3, healed=0;
      const dmg=me.field.map((c,i)=>({i,need:c.maxHp-c.hp,lore:c.lore})).filter(x=>x.need>0).sort((a,b)=>b.lore-a.lore);
      for(const d of dmg){
        if(heal<=0) break;
        const c=me.field[d.i];
        const amt=Math.min(d.need, heal);
        c.hp += amt;
        heal -= amt;
        healed += amt;
        log(`è‡ªåˆ†ã®ã€Œ${c.name}ã€ã‚’${amt}å›å¾©ã€‚`);
      }
      if(healed>0) effectDraw(side, healed, "ãƒ—ãƒ¬ãƒƒãƒ„ã‚§ãƒ«");
      updateUI();
    }}
  ]);
}

function effectArienai(side){
  const me=battle[side];
  const look = me.deck.slice(0,4);
  if(look.length===0){ log("å±±æœ­ãŒå°‘ãªã„ã€‚"); return; }

  const songIdx = look.findIndex(c=>c.type==="song");
  if(side==="cpu"){
    if(songIdx>=0){
      const picked = look[songIdx];
      // remove that card from top4 in deck
      const realIndex = me.deck.indexOf(picked);
      if(realIndex>=0) me.deck.splice(realIndex,1);
      me.hand.push(picked);
      log("ç›¸æ‰‹ã¯ã‚¢ãƒªã‚¨ãƒŠã‚¤ã§ã‚½ãƒ³ã‚°ã‚’1æšæ‰‹æœ­ã«åŠ ãˆãŸã€‚");
    } else {
      log("ç›¸æ‰‹ã®ã‚¢ãƒªã‚¨ãƒŠã‚¤ï¼šã‚½ãƒ³ã‚°ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã€‚");
    }
    return;
  }

  const lines = look.map((c,i)=>`${i}: ${c.name} [${c.type}]`).join("\n");
  openModal("ã‚¢ãƒªã‚¨ãƒŠã‚¤", `ä¸Šã‹ã‚‰4æšã‚’è¦‹ã¾ã—ãŸã€‚\nã‚½ãƒ³ã‚°ã‚’1æšã¾ã§æ‰‹æœ­ã«åŠ ãˆã‚‰ã‚Œã¾ã™ã€‚\n\n${lines}`, [
    {label:"å–ã‚‰ãªã„",onClick:()=>{closeModal();}},
    ...look.map((c,i)=>({
      label:`${i}`,
      onClick:()=>{
        closeModal();
        if(c.type!=="song"){ log("ã‚½ãƒ³ã‚°ã§ã¯ãªã„ãŸã‚å–ã‚Œãªã„ã€‚"); return; }
        // remove exact instance from deck (within top4 region)
        const idx = me.deck.indexOf(c);
        if(idx>=0) me.deck.splice(idx,1);
        me.hand.push(c);
        log(`è‡ªåˆ†ã¯ã€Œ${c.name}ã€ã‚’æ‰‹æœ­ã«åŠ ãˆãŸã€‚`);
        updateUI();
      }
    }))
  ]);
}

function applyEffectCard(side, card, singer){
  switch(card.effect){
    case "boardwipe": {
      // destroy all characters
      const p=battle.player, c=battle.cpu;
      while(p.field.length) destroyChar("player",0,"å¤§ç«");
      while(c.field.length) destroyChar("cpu",0,"å¤§ç«");
      break;
    }
    case "songToInk1": {
      if(side==="cpu"){
        // choose best enemy
        const enemy=battle.player;
        if(enemy.field.length){
          let best=0,score=-999;
          enemy.field.forEach((x,i)=>{ const sc=x.lore*10+x.cost*5+x.atk*2; if(sc>score){score=sc;best=i;} });
          const t=enemy.field.splice(best,1)[0];
          moveToInkByEffect("player", t, card.name);
        }
      } else {
        chooseEnemyCharIndexUI(side,"ã‚ã‚Šã®ã¾ã¾ã§","ç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã‚’ã‚¤ãƒ³ã‚¯ã¸ã€‚å¯¾è±¡ã‚’é¸ã‚“ã§ã­ã€‚").then(i=>{
          if(i==null) return;
          const t=battle.cpu.field.splice(i,1)[0];
          moveToInkByEffect("cpu", t, card.name);
          updateUI();
        });
      }
      break;
    }
    case "discard1": {
      const enemy=battle[enemySide(side)];
      if(enemy.hand.length===0){ log("ç›¸æ‰‹ã®æ‰‹æœ­ãŒ0ã€‚"); break; }
      if(side==="cpu"){
        // player discards random
        const i=Math.floor(Math.random()*enemy.hand.length);
        const t=enemy.hand.splice(i,1)[0];
        enemy.discard.push(t);
        log(`è‡ªåˆ†ã¯æ‰‹æœ­ã‚’1æšæ¨ã¦ãŸã€‚`);
      } else {
        // cpu discards random
        const i=Math.floor(Math.random()*enemy.hand.length);
        const t=enemy.hand.splice(i,1)[0];
        enemy.discard.push(t);
        log(`ç›¸æ‰‹ã¯æ‰‹æœ­ã‚’1æšæ¨ã¦ãŸã€‚`);
      }
      break;
    }
    case "draw3": {
      effectDraw(side,3,card.name);
      break;
    }
    case "handReset7": {
      // both discard all then draw 7 by effect
      ["player","cpu"].forEach(s=>{
        const me=battle[s];
        while(me.hand.length) me.discard.push(me.hand.shift());
      });
      effectDraw("player",7,card.name);
      effectDraw("cpu",7,card.name);
      break;
    }
    case "damage3": {
      // action: deal 3 to enemy char
      if(side==="cpu"){
        const enemy=battle.player;
        if(enemy.field.length){
          let best=0,score=-999;
          enemy.field.forEach((x,i)=>{ const sc=(x.lore*10)+(x.atk*2)+(x.hp); if(sc>score){score=sc;best=i;} });
          dealDamageToChar("player", best, 3, card.name);
        }
      } else {
        chooseEnemyCharIndexUI(side,"ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ï¼","ç›¸æ‰‹ã‚­ãƒ£ãƒ©1ä½“ã«3ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚å¯¾è±¡ã‚’é¸ã‚“ã§ã­ã€‚").then(i=>{
          if(i==null) return;
          dealDamageToChar("cpu", i, 3, card.name);
          updateUI();
        });
      }
      break;
    }
    case "aoe2": {
      const enemy=battle[enemySide(side)];
      for(let i=enemy.field.length-1;i>=0;i--){
        dealDamageToChar(enemySide(side), i, 2, card.name);
      }
      break;
    }
    default: break;
  }
}

/* ===== Player click handlers ===== */
function onHandClick(i){
  if(!battle||battle.turn.current!=="player") return;
  const c=battle.player.hand[i]; if(!c) return;

  let html = `<div style="margin-bottom:6px;"><b>æ‰‹æœ­ï¼š</b>${c.name}</div>`;
  html += `<button class="btn small" onclick="showDetail(battle.player.hand[${i}])">è©³ç´°</button>`;

  // ink option
  html += `<button class="btn small" onclick="tryPlaceInkFromHand('player',${i})">ã‚¤ãƒ³ã‚¯åŒ–</button>`;

  if(c.type==="character"){
    html += `<button class="btn small" onclick="summonFromHand('player',${i})">å¬å–šï¼ˆ${c.cost}ï¼‰</button>`;
  } else if(c.type==="song"){
    // offer sing options
    html += `<div style="font-size:11px;opacity:.85;margin-top:6px;">ã‚½ãƒ³ã‚°ï¼šã‚¤ãƒ³ã‚¯ã§ä½¿ç”¨ or ã‚­ãƒ£ãƒ©ã§æ­Œã†ï¼ˆã‚­ãƒ£ãƒ©ã®ã‚³ã‚¹ãƒˆâ‰¥${c.cost}ï¼‰</div>`;
    html += `<button class="btn small" onclick="playSongFromHand('player',${i},null)">ã‚¤ãƒ³ã‚¯ã§ä½¿ç”¨</button>`;
    battle.player.field.forEach((x,idx)=>{
      const ok = canAct(x) && x.cost>=c.cost;
      html += `<button class="btn small" ${ok?"":"disabled"} onclick="playSongFromHand('player',${i},${idx})">æ­Œã†:${x.name}</button>`;
    });
  } else if(c.type==="action"){
    html += `<button class="btn small" onclick="playActionFromHand('player',${i})">ä½¿ç”¨ï¼ˆ${c.cost}ï¼‰</button>`;
    html += `<div style="font-size:11px;opacity:.8;">â€»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯æ­Œãˆãªã„</div>`;
  }

  qs("actionArea").innerHTML = html;
}

function onFieldClick(i){
  if(!battle) return;
  const c=battle.player.field[i]; if(!c) return;

  let html = `<div style="margin-bottom:6px;"><b>å ´ï¼š</b>${c.name} ${c.rest?"[REST]":"[READY]"} ${c.frozen?"[å‡çµ]":""}</div>`;
  html += `<button class="btn small" onclick="showDetail(battle.player.field[${i}])">è©³ç´°</button>`;

  if(battle.turn.current==="player"){
    if(canAct(c)){
      if(c.lore>0) html += `<button class="btn small" onclick="doSeek('player',${i})">ã‚·ãƒ¼ã‚¯ï¼ˆ+${c.lore}ï¼‰</button>`;

      // challenge menu: show rested targets only
      const targets = battle.cpu.field
        .map((t,idx)=>({t,idx}))
        .filter(x=>canTarget(c,x.t));

      if(targets.length && c.atk>0){
        html += `<div style="font-size:11px;opacity:.85;margin-top:6px;">ãƒãƒ£ãƒ¬ãƒ³ã‚¸å…ˆï¼ˆãƒ¬ã‚¹ãƒˆã®ã¿ï¼‰</div>`;
        targets.forEach(x=>{
          html += `<button class="btn small" onclick="resolveChallenge('player',${i},${x.idx}); updateUI(); checkWin();">â†’ ${x.t.name}</button>`;
        });
      } else {
        html += `<div style="font-size:11px;opacity:.75;margin-top:6px;">ãƒãƒ£ãƒ¬ãƒ³ã‚¸å¯èƒ½ãªç›¸æ‰‹ï¼ˆãƒ¬ã‚¹ãƒˆï¼‰ãŒã„ã¾ã›ã‚“ã€‚</div>`;
      }
    } else {
      html += `<div style="font-size:11px;opacity:.75;">ã“ã®ã‚­ãƒ£ãƒ©ã¯è¡Œå‹•ã§ãã¾ã›ã‚“ï¼ˆãƒ¬ã‚¹ãƒˆ/å‡çµ/å¬å–šé…”ã„ï¼‰ã€‚</div>`;
    }
  }
  qs("actionArea").innerHTML = html;
}

/* ===== CPU AI (normal/strong/god) ===== */
function cpuTakeTurn(){
  if(!battle) return;

  const cpu=battle.cpu;
  const me=battle.player;

  // 1) ink placement (smart)
  const limit = calcInkPlacementLimit("cpu");
  while(battle.turn.inkPlaced.cpu < limit){
    // choose worst inkable card to ink: highest cost, low impact, or duplicate
    let bestIdx = -1, bestScore = -999999;
    cpu.hand.forEach((c,i)=>{
      if(!c.inkable) return;
      // keep songs sometimes if god
      const isKeyRemoval = (c.effect==="boardwipe"||c.effect==="songToInk1"||c.effect==="damage3"||c.effect==="aoe2");
      let score = c.cost*10 - (c.lore*6 + c.atk*3 + c.hp);
      if(c.type==="song") score += (cpuStrength==="god"? 8 : 3);
      if(isKeyRemoval) score -= (cpuStrength==="god"? 80 : 30);
      if(score>bestScore){bestScore=score;bestIdx=i;}
    });
    if(bestIdx<0) break;
    tryPlaceInkFromHand("cpu", bestIdx);
  }

  // 2) play removals / songs / actions (strong/god)
  if(cpuStrength!=="normal"){
    // use damage3 if can kill something
    const dmgIdx = cpu.hand.findIndex(c=>c.effect==="damage3" && c.cost<=cpu.inkCurrent);
    if(dmgIdx>=0 && me.field.length){
      // pick kill or best value
      let best=0,score=-999;
      me.field.forEach((x,i)=>{
        const kill = (x.hp<=3);
        const sc = (kill?1000:0) + x.lore*10 + x.atk*3 + x.cost*4;
        if(sc>score){score=sc;best=i;}
      });
      cpu.inkCurrent -= cpu.hand[dmgIdx].cost;
      const card = cpu.hand.splice(dmgIdx,1)[0];
      log(`ç›¸æ‰‹ã¯ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€Œ${card.name}ã€ã‚’ä½¿ç”¨ã€‚`);
      applyEffectCard("cpu", card, null);
      cpu.discard.push(card);
      updateUI();
      if(checkWin()) return;
    }

    // boardwipe if behind a lot
    const wipeIdx = cpu.hand.findIndex(c=>c.effect==="boardwipe" && c.type==="song");
    if(wipeIdx>=0){
      const behind = me.field.length - cpu.field.length;
      if(behind>=2 && cpu.field.length<=2){
        // try sing or pay
        const song = cpu.hand[wipeIdx];
        const singerIdx = cpu.field.findIndex(x=>canAct(x) && x.cost>=song.cost);
        if(singerIdx>=0 || cpu.inkCurrent>=song.cost){
          playSongFromHand("cpu", wipeIdx, singerIdx>=0?singerIdx:null);
          updateUI();
        }
      }
    }
  }

  // 3) summon as much as possible (prefer best value)
  let progressed=true;
  while(progressed){
    progressed=false;
    // find best character to summon
    let bestIdx=-1, bestScore=-999;
    cpu.hand.forEach((c,i)=>{
      if(c.type!=="character") return;
      if(c.cost>cpu.inkCurrent) return;
      let sc = c.lore*20 + c.atk*5 + c.hp*3 + c.cost;
      if(c.effect==="destroyOnSummon"||c.effect==="toInkOnSummon") sc += 80;
      if(c.effect==="freeze2") sc += 70;
      if(c.effect==="pretzelHealDraw") sc += 35;
      if(c.effect==="arienaiSearchSong") sc += 30;
      if(cpuStrength==="god") sc += (c.rush?15:0);
      if(sc>bestScore){bestScore=sc;bestIdx=i;}
    });
    if(bestIdx>=0){
      summonFromHand("cpu", bestIdx);
      progressed=true;
    }
  }

  // 4) play remaining key songs if possible (draw3, aoe2, songToInk1)
  if(cpuStrength!=="normal"){
    // songToInk1 (ã‚ã‚Šã®ã¾ã¾ã§)
    const idx=cpu.hand.findIndex(c=>c.effect==="songToInk1" && c.type==="song");
    if(idx>=0 && me.field.length){
      const song=cpu.hand[idx];
      const singerIdx=cpu.field.findIndex(x=>canAct(x)&&x.cost>=song.cost);
      if(singerIdx>=0 || cpu.inkCurrent>=song.cost){
        playSongFromHand("cpu", idx, singerIdx>=0?singerIdx:null);
      }
    }
    // draw3
    const d3=cpu.hand.findIndex(c=>c.effect==="draw3" && c.type==="song");
    if(d3>=0){
      const song=cpu.hand[d3];
      const singerIdx=cpu.field.findIndex(x=>canAct(x)&&x.cost>=song.cost);
      if(singerIdx>=0 || cpu.inkCurrent>=song.cost){
        playSongFromHand("cpu", d3, singerIdx>=0?singerIdx:null);
      }
    }
  }

  // 5) combat/seek (strong/god tries best)
  cpu.field.forEach((att,attIdx)=>{
    if(!battle) return;
    if(!canChallenge(att)) return;

    // mustAttack: if any valid target exists, must attack
    const targets = me.field.map((t,i)=>({t,i})).filter(x=>canTarget(att,x.t));
    if(targets.length){
      // pick best trade: kill highest lore / best value, prefer kill without dying if god
      let best=targets[0].i, score=-9999;
      targets.forEach(x=>{
        const t=x.t;
        let attAtk=att.atk + (att.effect==="frenzy2"?2:0);
        const kill = t.hp - attAtk <= 0;
        const survive = att.hp - t.atk > 0;
        let sc = (kill?200:0) + t.lore*25 + t.cost*6 + t.atk*3;
        if(cpuStrength==="god"){ sc += (survive?60:0); }
        if(sc>score){score=sc;best=x.i;}
      });
      resolveChallenge("cpu", attIdx, best);
      updateUI();
      if(checkWin()) return;
    } else {
      // no rested targets => seek if can
      if(canAct(att) && att.lore>0){
        doSeek("cpu", attIdx);
      }
    }
  });

  updateUI();
  if(checkWin()) return;

  log("ç›¸æ‰‹ã¯ã‚¿ãƒ¼ãƒ³çµ‚äº†ã€‚");
  // next turn
  battle.turn.turnCount += 1;
  beginTurn("player", false);
}

/* ===== UI update ===== */
function updateUI(){
  if(!battle) return;

  qs("cpuHandCount").textContent = battle.cpu.hand.length;
  qs("cLore").textContent = battle.cpu.lore;
  qs("cDeck").textContent = battle.cpu.deck.length;
  qs("cpuInkCur").textContent = battle.cpu.inkCurrent;
  qs("cpuInkMax").textContent = battle.cpu.inkMax;

  qs("playerLore").textContent = battle.player.lore;
  qs("playerInkCurrent").textContent = battle.player.inkCurrent;
  qs("playerInkMax").textContent = battle.player.inkMax;
  qs("playerDeck").textContent = battle.player.deck.length;
  qs("turnInfo").textContent = battle.turn.current==="player" ? "è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³" : "ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³";

  // fields
  const cpuF=qs("cpuField"); cpuF.innerHTML="";
  battle.cpu.field.forEach(c=>{
    const w=document.createElement("div"); w.innerHTML=renderCard(c);
    w.firstElementChild.onclick=()=>showDetail(c);
    cpuF.appendChild(w.firstElementChild);
  });

  const pF=qs("playerField"); pF.innerHTML="";
  battle.player.field.forEach((c,i)=>{
    const w=document.createElement("div"); w.innerHTML=renderCard(c);
    w.firstElementChild.onclick=()=>onFieldClick(i);
    pF.appendChild(w.firstElementChild);
  });

  const pH=qs("playerHand"); pH.innerHTML="";
  battle.player.hand.forEach((c,i)=>{
    const w=document.createElement("div"); w.innerHTML=renderCard(c);
    w.firstElementChild.onclick=()=>onHandClick(i);
    pH.appendChild(w.firstElementChild);
  });
}

/* ===== Boot ===== */
window.addEventListener("load", ()=>{
  loadData();
  showScreen("menu");
});
</script>
</body>
</html>
